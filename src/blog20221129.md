![V](./images/blog20221129/v.png)
<p align="center">Ideas are bulletproof</p>

图文无关
# 红<span style="color:red;">黑</span>树

## Motivation
leetcode上的第[220](https://leetcode.cn/problems/contains-duplicate-iii/)题，在有限区间中查找是否存在两个元素的的差值小于等于某个界限。

基于滑动窗口和有序集合的思想，可以很快的写出[解答](https://leetcode.cn/submissions/detail/385867183/)。但是Go语言的标准库中没有有序集的数据结构，只有哈希的集合，哈希集合中的元素不能有序遍历，难以获得值相邻元素的差值。刚好这几天被封在宿舍，手写一个Go的红黑树。

## 红黑树的性质

1. 节点是红色或黑色。
2. 根是黑色。
3. 所有叶子都是黑色（叶子是NIL节点）。
4. 每个红色节点必须有两个黑色的子节点。（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。）（或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。）（或者说红色节点的父节点和子节点均是黑色的。）
5. 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

![Red-Black Tree](./images/blog20221129/Red-black_tree_example.png)
<p align="center">Example from <a href="https://zh.m.wikipedia.org/zh-cn/%E7%BA%A2%E9%BB%91%E6%A0%91">Wiki</a></p>

红黑树上的任何操作，都是为了保证在红黑树的性质。可视化在[这里](https://www.cs.usfca.edu/~galles/visualization/RedBlack.html)

### 红黑树的操作
> 红黑树相对于AVL树来说，牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树。
>
> 恢复红黑树的性质需要少量（\\( O(\log n) \\)）的颜色变更（实际是非常快速的）和不超过三次树旋转（对于插入操作是两次）。虽然插入和删除很复杂，但操作时间仍可以保持为\\( O(\log n) \\)次

红黑树每个节点的数据结构包括key值（val），颜色值，左右孩子指针，父指针。
```go
type node struct {
	left, right, parent *node
	val int
	color int
}
```

整个树结构如下，注意这里设置了一个Nil，即整棵树的叶子结点的代表
```go
type RBTree struct {
	root *node
	Nil *node
}
```

#### 插入