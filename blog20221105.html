<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CMU 15-445/645 - Sugar&#x27;s Blog</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/toc.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About</a></li><li class="chapter-item expanded affix "><li class="part-title">2023</li><li class="chapter-item expanded "><a href="blog20230222.html">CS 161 REGULUS</a></li><li class="chapter-item expanded "><a href="blog20230406.html">MIT 6.858 Lab3: Symbolic execution</a></li><li class="chapter-item expanded "><a href="blog20230110.html">Computer Security - Buffer overflows</a></li><li class="chapter-item expanded "><div>MIT 6.007 Signals And Systems</div></li><li class="chapter-item expanded affix "><li class="part-title">2022</li><li class="chapter-item expanded "><a href="blog20221209.html">来点utterances</a></li><li class="chapter-item expanded "><a href="blog20221129.html">红黑树</a></li><li class="chapter-item expanded "><a href="blog20221113.html">B+Tree</a></li><li class="chapter-item expanded "><a href="blog20221105.html" class="active">CMU 15-445/645</a></li><li class="chapter-item expanded "><a href="blog20221028.html">构建mdbook的博客</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="blog20220726.html">MIT 6.824 kvraft</a></li><li class="chapter-item expanded "><a href="blog20220630.html">MIT 6.S081 mmap</a></li><li class="chapter-item expanded "><a href="blog20220519.html">frp内网穿透实践</a></li><li class="chapter-item expanded "><a href="blog20220517.html">画饼</a></li><li class="chapter-item expanded "><a href="blog20220507.html">母亲节快乐</a></li><li class="chapter-item expanded "><a href="blog20220430.html">MIT 6.S081 File System</a></li><li class="chapter-item expanded "><a href="blog20220424.html">MIT 6.S081 Locks</a></li><li class="chapter-item expanded "><a href="blog20220422.html">Docker实践</a></li><li class="chapter-item expanded "><a href="blog20220224.html">MIT 6.S081 Network Driver</a></li><li class="chapter-item expanded affix "><li class="part-title">2021</li><li class="chapter-item expanded "><a href="blog20211231.html">Slurm单机部署</a></li><li class="chapter-item expanded "><a href="blog20211119.html">MIT 6.S081 COW</a></li><li class="chapter-item expanded "><a href="blog20211024.html">MIT 6.S081 Traps</a></li><li class="chapter-item expanded "><a href="blog20211017.html">MIT 6.S081 Page Tables</a></li><li class="chapter-item expanded "><a href="blog20211012.html">MIT 6.828 System calls</a></li><li class="chapter-item expanded "><a href="blog20210926.html">MIT 6.828 Util Lab</a></li><li class="chapter-item expanded "><a href="blog20210805.html">可靠数据传输协议</a></li><li class="chapter-item expanded "><a href="blog20210715.html">CSAPP - Proxy Lab</a></li><li class="chapter-item expanded "><a href="blog20210512.html">Raft</a></li><li class="chapter-item expanded "><a href="blog20210503.html">CSAPP - Malloc Lab</a></li><li class="chapter-item expanded "><a href="blog20210419.html">CSAPP - Shell Lab</a></li><li class="chapter-item expanded "><a href="blog20210323.html">CSAPP - Cache Lab</a></li><li class="chapter-item expanded "><a href="blog20210308.html">CSAPP - Arch Lab</a></li><li class="chapter-item expanded "><a href="blog20210219.html">CSAPP - Attack Lab</a></li><li class="chapter-item expanded "><a href="blog20210206.html">CSAPP - Bomb Lab</a></li><li class="chapter-item expanded "><a href="blog20210203.html">CSAPP - Data Lab</a></li><li class="chapter-item expanded affix "><li class="part-title">2020</li><li class="chapter-item expanded "><a href="blog20201011.html">MIT 6.824 MapReduce</a></li><li class="chapter-item expanded "><a href="blog20200201.html">MagicCube</a></li><li class="chapter-item expanded "><a href="blog20200116.html">bluelog</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sugar&#x27;s Blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Sugar-Coder/Sugar-Coder.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="cmu-15-445645-intro-to-database-systems"><a class="header" href="#cmu-15-445645-intro-to-database-systems">CMU 15-445/645 Intro to Database Systems</a></h1>
<p><a href="https://15445.courses.cs.cmu.edu/fall2021/">课程</a>学习总结。
课程内部要求的不要把solution直接放到网上，我这边就贴各种具体实现了，只是记录一些Project的关键想法和实现，另外再补充记录一些c++的知识。</p>
<h2 id="homework-1-sql"><a class="header" href="#homework-1-sql">Homework #1 SQL</a></h2>
<p>数据库系统的接口。课程的第一个assignment是使用<a href="https://sqlite.org/cli.html#getting_started">sqlite3</a>，完成10个查询操作。</p>
<h3 id="group-by"><a class="header" href="#group-by">group by</a></h3>
<blockquote>
<p>any attribute that is not present in the group by clause may appear in the select clause only as an argument to an aggregate function. (Chapter 3.7)</p>
</blockquote>
<h2 id="project-1-buffer-pool-manager"><a class="header" href="#project-1-buffer-pool-manager">Project #1 Buffer Pool Manager</a></h2>
<p>cache从disk中读取的page，使用LRU的替换策略管理Buffer。对于Parallel BPM，可能有多个instance。</p>
<h3 id="task-1-lru-replacer"><a class="header" href="#task-1-lru-replacer">Task #1 LRU Replacer</a></h3>
<p>使用双向链表和hashmap来实现lru，hashmap保存双向链表的迭代器，快速增删。
unpin操作，降低一个page的引用次数。buffer Pool中一个page的refrence count为0了，将这个page放入到Replace的frame中，Replacer调用unpin记录这个frame
pin操作，标记这个page正在被使用。一个已经在Replacer的frame，在buffer pool中又被引用了，增加page的引用计数，从Replacer中移除这个frame</p>
<h3 id="task-2-buffer-pool-manager-instance"><a class="header" href="#task-2-buffer-pool-manager-instance">Task #2 Buffer Pool Manager Instance</a></h3>
<p>使用free_list记录空闲的page，如果free_list为空了，再使用LRU策略淘汰page。</p>
<p>使用页表映射内存中frame_id -&gt; disk的page_id
frame_id_t，指的是buffer中的page pool的下标
page_id_t，指的是物理页号</p>
<h3 id="task-3-parallel-bpm"><a class="header" href="#task-3-parallel-bpm">Task #3 Parallel BPM</a></h3>
<p>用page_id来决定映射到哪个instance。每个instance有自己的latch进行同步。</p>
<h2 id="project-2-hash-index"><a class="header" href="#project-2-hash-index">Project #2 Hash Index</a></h2>
<p>数据库中表的索引（storage/index/extensible_hash_table_index）的实现，基于extensible Hash table，快速查找Key对应的page_id，只支持non-unique key。</p>
<h3 id="task-1-page-layouts"><a class="header" href="#task-1-page-layouts">Task #1 Page Layouts</a></h3>
<p>实现桶的页结构时，在删除一个key value pair（a item）的时候，只把readable置0，认为当readableNum == 0时，一个bucket为空。当从一个桶中删除一个item，不改变Occupied，而设置Readable为false，形成一个“tombstone”。当桶中所有item都被标记为Occupied时，则认为桶是满的，这时候可以使用分裂操作，重新创建两个新的桶。避免的不必要的删除item操作。</p>
<h3 id="task-3-并发控制"><a class="header" href="#task-3-并发控制">Task #3 并发控制</a></h3>
<p>整个hash table的一个大锁table_latch_，和每个桶的小锁page latch（从BPM中获得的raw_page中的锁）配合使用。</p>
<h2 id="project-4-query-execution"><a class="header" href="#project-4-query-execution">Project #4 Query Execution</a></h2>
<p>从test/executor/executor_test.cpp出发，看看怎么使用plan来确定执行的？
每个test构建一个plan，executionEngin完成具体的执行，executor_factory根据plan的类型创建executor，
executor根据plan执行。</p>
<p>关于如何获取table的有关信息？
Catalog保存了table_oid到TableInfo的映射，tableInfo保存了一个tableheap对象，tableHeap保存了table的存储页位置信息，可用于开始获得iterator的起始位置</p>
<h3 id="seqscanexecutor的实现"><a class="header" href="#seqscanexecutor的实现">SeqScanExecutor的实现</a></h3>
<p>增加成员table_info_、itr_，方便保存迭代信息
注意都要使用智能指针来防止内存泄漏 使用unique_ptr管理新创建的itr_，由于table_info是从catalog中获得的一个没有所有权的指针，不使用智能指针管理
另外当plan为nullptr的时候记得Next直接返回true
src/catalog中有table_generator，里面生成的测试用table的 schema信息</p>
<h3 id="insertexecutor"><a class="header" href="#insertexecutor">InsertExecutor</a></h3>
<p>插入tuple到table、更新index
学习table_generator中的FillTable来进行插入，先构造<code>vector&lt;Value&gt;</code>的tuple值，再构造tuple
更新index的时候，使用index提供的接口（insertEntry），接口内部使用的是之前写好的extensible_hash_table来完成的
在catalog_test的里面看使用index的方式</p>
<p>对于复合的insert executor，需要使用child_executor获取select的执行结果。编码时注意使用std::move来获取右值引用来初始化unique_ptr。</p>
<h3 id="updateexecutor"><a class="header" href="#updateexecutor">UpdateExecutor</a></h3>
<p>更新index使用先根据Key Delete，再Insert，在相关测试中增加了index更新的检查，注意Index的创建，使用ParseSQL来确定index的类型（列名无关紧要，因为后面的key_attr会确定建立索引的列序号）</p>
<h3 id="deleteexecutor"><a class="header" href="#deleteexecutor">DeleteExecutor</a></h3>
<p>在测试的时候发现ScanKey的时候发现写入时大小不匹配，因为extendible_hash_table_index的key大小为8，在generic_key.h中的SetFromKey的copy的时候，是根据tuple的大小决定复制的长度的，tuple的大小可能超过key</p>
<pre><code class="language-c++">const Tuple index_key = Tuple(result_set[0]);
</code></pre>
<p>改为根据key_schema获取tuple的方式</p>
<pre><code class="language-c++">const Tuple index_key = result_set[0].KeyFromTuple(table_info-&gt;schema_, *index_info-&gt;index_-&gt;GetKeySchema(), index_info-&gt;index_-&gt;GetKeyAttrs()); 
</code></pre>
<h3 id="nested-loop-join"><a class="header" href="#nested-loop-join">Nested Loop Join</a></h3>
<p>如何构造tuple？发现column_value_expression中有很方便获取join有关schema的列值的接口（EvaluateJoin），重写ConstructTuple。</p>
<h3 id="hash-join"><a class="header" href="#hash-join">Hash Join</a></h3>
<p>怎么根据多个key构建hash，参考aggregate_executor
在hash_join_plan中定义JoinKey和JoinValue，提前实例化，再在hash_join_executor中定义hash_table
在构建JoinKey的时候，由于 plan_-&gt;LeftJoinKeyExpression() 只能获取一个ColumnValueExpression，所以只能获得tuple的一个列，并不能获取多个属性的值，
虽然我的JoinKey设计的时候是支持多个属性进行散列的。</p>
<h3 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h3>
<p>Group by的实现是多个key的hash表，对于没有group_by的聚集查询，输出结果只有一行（一个tuple），所以hash表中只有一个key
注意关联容器的迭代器失效的问题，
hash表的映射是从group_by的列值映射到aggregation的value</p>
<h3 id="distinct"><a class="header" href="#distinct">Distinct</a></h3>
<p>出现了heap_buffer_overflow，在MakeDistinctKey的时候,主要是column_index超出了schema的列数量，直接通过tuple-&gt;GetValue来获取
另外，修改seq_scan_executor，让返回的tuple符合outputSchema格式，同时注意rid的获取要在origin_tuple中获得</p>
<h2 id="concurrency-control"><a class="header" href="#concurrency-control">Concurrency Control</a></h2>
<p>通过使用 two-phase lock 来实现lock_manager。
lock_manager中的lock_table记录每个rid对应的RequestQueue，每个Queue有自己的锁，让想要获取锁的事务在同一把锁上等待，配合condition_variable使用。</p>
<h3 id="deadlock-prevention"><a class="header" href="#deadlock-prevention">Deadlock prevention</a></h3>
<p>wound wait: 老事务让当前拿着锁的事务rollback；新事务需等待锁</p>
<p>如何判断老事务？
在transaction_manager的begin中，使用全局递增的next_txn_id来创建id，可以用这个来判断事务的新老, 老事务的id更小</p>
<p>如何让已经获取锁的年轻线程abort？
拿着锁的、等待锁的年轻事务，都会被请求锁的老事务abort</p>
<p>当老事务请求锁的时候，检查请求队列中的所有事务，如果都比他年轻，则notify all，并将老事务的请求加到最前面，并清空其他在等待的request</p>
<p>在LockRequest中增加Transaction *txn成员，保存指针，便于找到已经获得锁的事务。
老事务在WoundWait过程中，将年轻事务的状态设置为ABORTED。在等待锁的年轻事务返回的时候，会检查自己的状态，抛出异常，最终释放自己所有的锁在transaction_manager的Abort中完成</p>
<h3 id="project-5-concurrent-query-execution"><a class="header" href="#project-5-concurrent-query-execution">Project #5 Concurrent Query Execution</a></h3>
<p>四种隔离级别的区别</p>
<ul>
<li>SERIALIZABLE: No phantoms, all reads repeatable, no dirty reads.</li>
<li>REPEATABLE READS: Phantoms may happen.</li>
<li>READ COMMITTED: Phantoms and unrepeatable reads may happen.</li>
<li>READ UNCOMMITTED: All of them may happen.</li>
</ul>
<p>事务独立性被破坏：</p>
<ol>
<li>unrepeatable read: 一个事务的连续两个read操作获取的结果不一样</li>
<li>phantom read: 事务read的结果和insert、delete操作顺序有关，只锁了当前存在的record，而没有锁index</li>
<li>dirty read: read的结果与其他被回滚的事务有关</li>
</ol>
<p>如何实现：</p>
<ul>
<li>serializable read: 获取所有锁，包括index lock，strict two-phase lock</li>
<li>repeatable read: same as above, 但没有index lock ：本次试验默认行为，同时忽略index lock的管理</li>
<li>read commit: same as above, 但立即释放Shared lock：这个在读query中实现，获取到数据后，立即调用Unlock shared</li>
<li>read uncommitted: same as above，但不获取读锁：这个在lock manager中实现</li>
</ul>
<p>事务ACID性质：</p>
<ul>
<li>Atomicity: “all or nothing”</li>
<li>Consistency: “it looks correct to me”</li>
<li>Isolation: “as if alone”</li>
<li>Durability: “survive failures”</li>
</ul>
<h2 id="c知识补充"><a class="header" href="#c知识补充">C++知识补充</a></h2>
<h3 id="smart-pointer"><a class="header" href="#smart-pointer">Smart Pointer</a></h3>
<p>容器中存放智能指针而非局部对象</p>
<pre><code class="language-c++">std::vector&lt;std::shared_ptr&lt;BufferPoolManager&gt;&gt; instances_;
</code></pre>
<p>unique_ptr的<code>get()</code>方法返回被管理对象的指针，而不是释放所有权</p>
<h3 id="右值引用"><a class="header" href="#右值引用">右值引用</a></h3>
<p>为了实现对象移动而不是拷贝，避免在某些情况下对象拷贝后就被立即销毁了，用于提升性能。</p>
<blockquote>
<p>cpp primer Chapter 13.6
标准库容器、string和shared_ptr类既支持移动有支持拷贝。IO类和unique_ptr类只能移动。</p>
</blockquote>
<pre><code class="language-c++">// 只能使用std::move使用移动构造函数初始化left_executor_的成员，因为left_executor不支持拷贝
NestedLoopJoinExecutor::NestedLoopJoinExecutor(ExecutorContext *exec_ctx, const NestedLoopJoinPlanNode *plan, std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;left_executor,std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;right_executor)
    : AbstractExecutor(exec_ctx), plan_(plan), left_executor_(std::move(left_executor)), right_executor_(std::move(right_executor)) {}
</code></pre>
<p>为了支持移动操作，引入右值引用，右值引用只能绑定到一个即将被销毁的对象上。</p>
<p>标准库的std::move函数
方便构造函数确定使用那种类型的构造（移动构造还是复制构造）</p>
<h3 id="vector"><a class="header" href="#vector">vector</a></h3>
<p>vector的reserve，预留空间，不改变size</p>
<h3 id="type-cast"><a class="header" href="#type-cast">type cast</a></h3>
<p>强制类型转换</p>
<ul>
<li>
<p>static_cast: 不去除常量性和易变性的类型转换</p>
</li>
<li>
<p>const_cast: 改变运算对象的底层const</p>
<blockquote>
<p>top-level const(顶层const): 指针本身是一个常量 <br>
low-level const(底层const): 指针所指对象是一个常量</p>
</blockquote>
</li>
<li>
<p>reinterpret_cast: 纯粹是一个编译时指令，指示编译器将 表达式 视为如同具有 新类型 类型一样处理。</p>
</li>
<li>
<p>dynamic_cast: 用于运行时类型识别，将基类的指针或引用安全地转换成派生类的指针或引用</p>
</li>
</ul>
<pre><code class="language-c++">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;
HashTableDirectoryPage *HASH_TABLE_TYPE::FetchDirectoryPage() {
  return reinterpret_cast&lt;HashTableDirectoryPage*&gt;(buffer_pool_manager_-&gt;FetchPage(directory_page_id_)-&gt;GetData());
}

template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;
HASH_TABLE_BUCKET_TYPE *HASH_TABLE_TYPE::FetchBucketPage(page_id_t bucket_page_id) {
  return reinterpret_cast&lt;HashTableBucketPage&lt;KeyType, ValueType, KeyComparator&gt; *&gt;(buffer_pool_manager_-&gt;FetchPage(bucket_page_id)-&gt;GetData());
}
</code></pre>
<h3 id="模板特例化"><a class="header" href="#模板特例化">模板特例化</a></h3>
<p>参考<a href="https://en.cppreference.com/w/cpp/utility/hash">hash</a></p>
<blockquote>
<p>cpp primer Chapter 16.5
定义函数模板特例化的过程中，我们本质上接管了编译器的工作...</p>
</blockquote>
<p>可以使用类模板特例化的方式实现我们自己定义的类型的hash版本。</p>
<h3 id="迭代器失效问题"><a class="header" href="#迭代器失效问题">迭代器失效问题</a></h3>
<p>cpp primer Chapter 9.3.6
list删除迭代器的时候，当前迭代器失效，不能在循环后置语句中++，最好不用循环的更改。
但是可以使用下面的方式，利用后缀++的性质</p>
<pre><code class="language-c++">for (std::list&lt;int&gt;::iterator it = c.begin(); it != c.end();)
{
    if (*it % 2 == 0)
        c.erase(it++);
    else
        ++it;
}
</code></pre>
<p>或者获得erase的返回值</p>
<pre><code class="language-c++">for (std::list&lt;int&gt;::iterator it = c.begin(); it != c.end();)
{
    if (*it % 2 == 0)
        it = c.erase(it);
    else
        ++it;
}
</code></pre>
<h3 id="类前置声明"><a class="header" href="#类前置声明">类前置声明</a></h3>
<p>在transaction.h中发现了类的前置声明，而不是引用头文件，前置声明只能作为指针或引用，不能定义类的对象，自然也就不能调用对象中的方法了。</p>
<h3 id="condition-variable"><a class="header" href="#condition-variable">condition variable</a></h3>
<p><code>std::condition_variable</code>在锁上等待Predicate 满足</p>
<p><code>cv.wait(lock, predicate)</code> 相当于：</p>
<pre><code class="language-c++">while (!pred()) {
    wait(lock);
}
</code></pre>
<p>如果条件不满足，在锁上等待并释放锁，当收到notify之后，(通过竞争)获取锁，进行predicate判断。因此在调用wait前，lock应该是处于上锁状态的。
配合RAII风格的锁来使用：</p>
<pre><code class="language-c++">{
    std::unique_lock&lt;std::mutex&gt; queue_lk(req_queue.mu_);
    //...
    req_queue.cv_.wait(queue_lk, [&amp;]{
      return txn-&gt;GetState() == TransactionState::ABORTED ||
             req_queue.request_queue_.front().txn_id_ == txn-&gt;GetTransactionId();
    });
}
</code></pre>
<h3 id="lambda"><a class="header" href="#lambda">Lambda</a></h3>
<p>cpp primer 10.3.2
<code>[capture](parameters) -&gt; return_type { body }</code>
按值捕获：在lambda表示创建时进行拷贝，而不是调用的时候进行拷贝
引用捕获：必须保证在lambda执行时变量是存在的</p>
<p>可变lambda:对于按值捕获的变量，想要改变它
<code>auto f = [v1] () mutable { return ++v1; }</code></p>
<h3 id="promise"><a class="header" href="#promise">promise</a></h3>
<p>线程间同步，传递值（用future表示）
<code>promise&lt;void&gt;</code> 在线程间对状态发信号
<code>promise&lt;int&gt;</code> 在线程间传递结果。</p>

                        <div id="comment-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="blog20221113.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="blog20221028.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="blog20221113.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="blog20221028.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        
        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/comments.js"></script>
        <script type="text/javascript" src="theme/toc.js"></script>
    </body>
</html>
