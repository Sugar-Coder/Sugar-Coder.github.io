<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MIT 6.S081 mmap - Sugar&#x27;s Blog</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/toc.css">
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About</a></li><li class="chapter-item expanded affix "><li class="part-title">2023</li><li class="chapter-item expanded "><a href="blog20230222.html">CS 161 REGULUS</a></li><li class="chapter-item expanded "><a href="blog20230406.html">MIT 6.858 Lab3: Symbolic execution</a></li><li class="chapter-item expanded "><a href="blog20230110.html">Computer Security - Buffer overflows</a></li><li class="chapter-item expanded "><div>MIT 6.007 Signals And Systems</div></li><li class="chapter-item expanded affix "><li class="part-title">2022</li><li class="chapter-item expanded "><a href="blog20221209.html">来点utterances</a></li><li class="chapter-item expanded "><a href="blog20221129.html">红黑树</a></li><li class="chapter-item expanded "><a href="blog20221113.html">B+Tree</a></li><li class="chapter-item expanded "><a href="blog20221105.html">CMU 15-445/645</a></li><li class="chapter-item expanded "><a href="blog20221028.html">构建mdbook的博客</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="blog20220726.html">MIT 6.824 kvraft</a></li><li class="chapter-item expanded "><a href="blog20220630.html" class="active">MIT 6.S081 mmap</a></li><li class="chapter-item expanded "><a href="blog20220519.html">frp内网穿透实践</a></li><li class="chapter-item expanded "><a href="blog20220517.html">画饼</a></li><li class="chapter-item expanded "><a href="blog20220507.html">母亲节快乐</a></li><li class="chapter-item expanded "><a href="blog20220430.html">MIT 6.S081 File System</a></li><li class="chapter-item expanded "><a href="blog20220424.html">MIT 6.S081 Locks</a></li><li class="chapter-item expanded "><a href="blog20220422.html">Docker实践</a></li><li class="chapter-item expanded "><a href="blog20220224.html">MIT 6.S081 Network Driver</a></li><li class="chapter-item expanded affix "><li class="part-title">2021</li><li class="chapter-item expanded "><a href="blog20211231.html">Slurm单机部署</a></li><li class="chapter-item expanded "><a href="blog20211119.html">MIT 6.S081 COW</a></li><li class="chapter-item expanded "><a href="blog20211024.html">MIT 6.S081 Traps</a></li><li class="chapter-item expanded "><a href="blog20211017.html">MIT 6.S081 Page Tables</a></li><li class="chapter-item expanded "><a href="blog20211012.html">MIT 6.828 System calls</a></li><li class="chapter-item expanded "><a href="blog20210926.html">MIT 6.828 Util Lab</a></li><li class="chapter-item expanded "><a href="blog20210805.html">可靠数据传输协议</a></li><li class="chapter-item expanded "><a href="blog20210715.html">CSAPP - Proxy Lab</a></li><li class="chapter-item expanded "><a href="blog20210512.html">Raft</a></li><li class="chapter-item expanded "><a href="blog20210503.html">CSAPP - Malloc Lab</a></li><li class="chapter-item expanded "><a href="blog20210419.html">CSAPP - Shell Lab</a></li><li class="chapter-item expanded "><a href="blog20210323.html">CSAPP - Cache Lab</a></li><li class="chapter-item expanded "><a href="blog20210308.html">CSAPP - Arch Lab</a></li><li class="chapter-item expanded "><a href="blog20210219.html">CSAPP - Attack Lab</a></li><li class="chapter-item expanded "><a href="blog20210206.html">CSAPP - Bomb Lab</a></li><li class="chapter-item expanded "><a href="blog20210203.html">CSAPP - Data Lab</a></li><li class="chapter-item expanded affix "><li class="part-title">2020</li><li class="chapter-item expanded "><a href="blog20201011.html">MIT 6.824 MapReduce</a></li><li class="chapter-item expanded "><a href="blog20200201.html">MagicCube</a></li><li class="chapter-item expanded "><a href="blog20200116.html">bluelog</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Sugar&#x27;s Blog</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Sugar-Coder/Sugar-Coder.github.io" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1 id="mmap"><a class="header" href="#mmap">mmap</a></h1>
<p>实现mmap系统调用，将文件内容映射到进程虚拟地址空间，便于共享内存。</p>
<h2 id="预备知识"><a class="header" href="#预备知识">预备知识</a></h2>
<pre><code class="language-c">void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
</code></pre>
<p>mmap系统调用：将fd指向的数据（offset开始）映射到虚拟内存中的addr地址开始的最长length的位置上 本实验addr = 0，那么需要kernel来选择用于映射文件的虚拟内存位置，mmap返回这个地址 prod 指出这个内存是否可读可写可执行 flags指出这个内存是否需要被写回（MAP_SHARED），或者不需要被写回（MAP_PRIVATE） offset 在本实验中为0</p>
<p>lazy load page: 在缺页trap中分配物理页，向页表中加入虚拟地址到物理页的映射</p>
<p>file inode记录的是该文件在磁盘上的位置（块），通过readi将inode的块读到内存，readi调用either_copyout复制块的内容到内存 either_copyout将内核读取的块内容复制到用户空间，在用户进程页表中增加一个虚拟地址到这个物理地址的映射</p>
<h2 id="实现流程"><a class="header" href="#实现流程">实现流程</a></h2>
<p>在makefile中加入mmaptest 增加系统调用mmap munmap</p>
<p>在proc.h中定义VMA结构体，让每个进程保存被映射的地址记录</p>
<pre><code class="language-c">struct vm_area_struct {
    int valid;
    uint64 addr;  // starting mapped virtual address
    uint64 length;  // mapped length
    int prot;    // permission
    int flags;   // whether to write back
    struct file *filep;      // the file structure
    int fd;
};

#define VMASIZE 16

// Per-process state
struct proc {
  struct spinlock lock;
  // ......

  // mapped files
  struct vm_area_struct VMA[VMASIZE];
  uint64 cur_max;   // the current max address for mapping
};
</code></pre>
<h3 id="难点如何选择在地址空间中的哪里存储被映射的内存"><a class="header" href="#难点如何选择在地址空间中的哪里存储被映射的内存">难点：如何选择在地址空间中的哪里存储被映射的内存</a></h3>
<p>用户进程地址空间</p>
<pre><code class="language-txt">MAXVA -&gt;     -------------
             | trampoline |
             -------------
             | trapframe  |
             --------------
             |            |
max addr -&gt;  --------------
of mmap      |            |
             |            |
             |     heap   |
             |            |
             --------------
             | user stack |
             --------------
             | user text &amp; data
     0 -&gt;    --------------
</code></pre>
<p>查看了网上的实现方法，非常简单和巧妙的利用了虚拟地址空间，只是多定义了一个cur_max，记录已经被分配出去的顶端地址，之后不断下移这个cur_max，继续分配就行了。在memlayout.h中定义最高的可映射地址位置，所以分配的虚拟地址从这里开始，之后向下生长</p>
<pre><code class="language-c">#define MMAPMAXADDR (TRAPFRAME - 10 * PGSIZE)
</code></pre>
<p>在sysfile.c中实现mmap</p>
<pre><code class="language-c">uint64
sys_mmap(void)
{
    uint64 addr;
    int length, prot, flags, fd, offset;
    struct file *filep;
    if (argaddr(0, &amp;addr) &lt; 0 || argint(1, &amp;length) &lt; 0|| argint(2, &amp;prot) &lt; 0 || argint(3, &amp;flags) &lt; 0 || argfd(4, &amp;fd, &amp;filep)&lt;0 ||
            argint(5, &amp;offset) &lt; 0) {
        return ~0;
    }
    if (addr != 0) {
        printf(&quot;Only support the kernel assigned address.\n&quot;);
        return ~0;
    }
    // find empty VMA and the length bigger than required
    struct proc *pp = myproc();

    if (flags &amp; MAP_SHARED) {
        if (!(filep-&gt;writable) &amp;&amp; (prot &amp; PROT_WRITE)) {
            printf(&quot;The file is read only, but the mmap prot want to write the memory.\n&quot;);
            return ~0;
        }
    }

    uint64 curmax = pp-&gt;cur_max;
    uint64 start_addr = PGROUNDDOWN(curmax - length);

    struct vm_area_struct *pvma = 0;

    for (int i = 0; i &lt; VMASIZE; ++i) {
        if (pp-&gt;VMA[i].valid == 0) {
            pvma = &amp;pp-&gt;VMA[i];
            break;
        }
    }

    if (pvma) {
        pvma-&gt;valid = 1;
        pvma-&gt;addr = start_addr;
        pvma-&gt;length = length;
        pvma-&gt;prot = prot;
        pvma-&gt;flags = flags;
        pvma-&gt;fd = fd;
        pvma-&gt;filep = filep;
        filedup(pvma-&gt;filep); // increase reference count

        pp-&gt;cur_max = start_addr;
    } else {
        return ~0;
    }

    return start_addr;
}
</code></pre>
<p>在trap.c中实现lazy page allocation</p>
<pre><code class="language-c">int mmap_read(struct file *f, uint64 dst_va, int off, int size) {
    ilock(f-&gt;ip);
    int n = readi(f-&gt;ip, 1, dst_va, off, size);
    off += n;
    iunlock(f-&gt;ip);
    return off;
}

void
usertrap(void)
{
  int which_dev = 0;

  if((r_sstatus() &amp; SSTATUS_SPP) != 0)
    panic(&quot;usertrap: not from user mode&quot;);

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p-&gt;trapframe-&gt;epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(p-&gt;killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p-&gt;trapframe-&gt;epc += 4;

    // an interrupt will change sstatus &amp;c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
      // ok
  } else if (r_scause() == 15 || r_scause() == 13) {  // Store/AMO page fault, load page fault
      uint64 va = r_stval();
      struct proc* pp = myproc();
      struct vm_area_struct *pvma = 0;
      for (int i = 0; i &lt; VMASIZE; ++i) {
          if (pp-&gt;VMA[i].valid == 1) {
              if (va &gt;= pp-&gt;VMA[i].addr &amp;&amp; va &lt; pp-&gt;VMA[i].addr + pp-&gt;VMA[i].length) {
                  pvma = &amp;pp-&gt;VMA[i];
                  break;
              }
          }
      }

      if (!pvma) {
          printf(&quot;The fault vm address not in the VMA.\n&quot;);
          goto err;
      }
      // if it is, allocate physical page(uvmalloc)
      char * pa = kalloc();
      if (pa == 0) {
          panic(&quot;kalloc in trap.c\n&quot;);
      }
      memset(pa, 0, PGSIZE);

      uint64 fault_page_start = PGROUNDDOWN(va);
      if (mappages(pp-&gt;pagetable, fault_page_start, PGSIZE, (uint64)pa, (pvma-&gt;prot &lt;&lt; 1) | PTE_U ) != 0) {
          kfree(pa);
          goto err;
      }
      // write the file content to the mapped page
      int offset = fault_page_start - pvma-&gt;addr; // the offset in the file
      mmap_read(pvma-&gt;filep, fault_page_start, offset, PGSIZE);
  } else {
err:
    printf(&quot;usertrap(): unexpected scause %p pid=%d\n&quot;, r_scause(), p-&gt;pid);
    printf(&quot;            sepc=%p stval=%p\n&quot;, r_sepc(), r_stval());
    p-&gt;killed = 1;
  }

  if(p-&gt;killed)
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
</code></pre>
<p>实现unmap。 在处理unmap的region的时候，题目给了简化的假设： An munmap call might cover only a portion of an mmap-ed region, but you can assume that it will either unmap at the start, or at the end, or the whole region (but not punch a hole in the middle of a region).</p>
<pre><code class="language-c">uint64
sys_munmap(void)
{
    uint64 addr;
    int length;
    if (argaddr(0, &amp;addr) &lt; 0 || argint(1, &amp;length) &lt; 0) {
        return -1;
    }
    if (addr % PGSIZE || length &lt; 0) {
        return -1;
    }
    // find the vma include the addr
    uint64 start_addr = PGROUNDDOWN(addr);
    uint64 end_addr = PGROUNDDOWN(addr + length);

//    printf(&quot;The start addr(%p), end add (%p)\n&quot;, start_addr, end_addr);
    struct vm_area_struct *pvma = 0;
    struct proc *pp = myproc();

    for (int i = 0; i &lt; VMASIZE; ++i) {
        if (pp-&gt;VMA[i].valid == 1 &amp;&amp;
                pp-&gt;VMA[i].addr &lt;= start_addr &amp;&amp;
                end_addr &lt;= pp-&gt;VMA[i].addr + pp-&gt;VMA[i].length) {
            pvma = &amp;pp-&gt;VMA[i];
            break;
        }
    }

    if (!pvma) {
        printf(&quot;Cannot find VMA, start from (%p) to (%p).\n&quot;, start_addr, end_addr);
        return -1;
    }

    // write back if flags is MAP_SHARED
    if ((pvma-&gt;flags &amp; MAP_SHARED) &amp;&amp; pvma-&gt;filep-&gt;writable) {
        struct file *f =pvma-&gt;filep;
        begin_op();
        ilock(f-&gt;ip);
        // todo: only write the dirty page
        writei(f-&gt;ip, 1, pvma-&gt;addr, 0, pvma-&gt;length);
        iunlock(f-&gt;ip);
        end_op();
    }

    // unmap the page from rounddown(addr) ~ roundup(addr + length)
    pte_t *pte;
    for (uint64 va = start_addr; va &lt; end_addr; va += PGSIZE) {  // 注意类型！！
//        printf(&quot;Unmap the address :%p\n&quot;, va);
        if ((pte = walk(pp-&gt;pagetable, va, 0)) != 0) {
            if (*pte &amp; PTE_V) {
                uvmunmap(pp-&gt;pagetable, va, 1, 1);
            }
        }
    }

    // if the whole vma is unmapped, decrease refcount
    if (start_addr == pvma-&gt;addr &amp;&amp; end_addr &lt; pvma-&gt;addr + pvma-&gt;length) {
        pvma-&gt;addr = end_addr;
        pvma-&gt;length -= length;
    } else if (start_addr &gt; pvma-&gt;addr &amp;&amp; end_addr == pvma-&gt;addr + pvma-&gt;length) {
        pvma-&gt;length -= length;
    } else if (start_addr == pvma-&gt;addr &amp;&amp; end_addr == pvma-&gt;addr + pvma-&gt;length) {
        // unmap the whole VMA
        pvma-&gt;valid = 0;
        pvma-&gt;filep-&gt;ref--;
        pvma-&gt;length = 0;
    } else {
        printf(&quot;You punch a whole in the vma. not supported.\n&quot;);
        return -1;
    }

    return 0;
}
</code></pre>
<p>在exit中unmap所有VMA</p>
<pre><code class="language-c">void
exit(int status)
{
  struct proc *p = myproc();

  if(p == initproc)
    panic(&quot;init exiting&quot;);

  // Close all open files.
  for(int fd = 0; fd &lt; NOFILE; fd++){
    if(p-&gt;ofile[fd]){
      struct file *f = p-&gt;ofile[fd];
      fileclose(f);
      p-&gt;ofile[fd] = 0;
    }
  }

  // unmap all mapped region
    struct vm_area_struct *vm = 0;
    for (int i = 0; i &lt; VMASIZE; ++i) {
        if (p-&gt;VMA[i].valid) {
            vm = &amp;p-&gt;VMA[i];

            // write back if flags is MAP_SHARED
            if ((vm-&gt;flags &amp; MAP_SHARED) &amp;&amp; vm-&gt;filep-&gt;writable) {
                struct file *f =vm-&gt;filep;
                begin_op();
                ilock(f-&gt;ip);
                // todo: only write the dirty page
                writei(f-&gt;ip, 1, vm-&gt;addr, 0, vm-&gt;length);
                iunlock(f-&gt;ip);
                end_op();
            }

            vm-&gt;valid = 0;
            pte_t *pte;
            for (uint64 j = vm-&gt;addr; j &lt; vm-&gt;addr + vm-&gt;length; j += PGSIZE) {
                if((pte = walk(p-&gt;pagetable, j, 0)) != 0) {
                    if(*pte &amp; PTE_V) {
                        uvmunmap(p-&gt;pagetable, j, 1, 1);
                    }
                }
            }
        }
    }
....
}
</code></pre>
<p>实现fork中复制VMA给子进程</p>
<pre><code class="language-c">int
fork(void)
{
  int i, pid;
  struct proc *np;
  struct proc *p = myproc();

  // .....
    // copy all VMA from parent to children
    for (int i = 0; i &lt; VMASIZE; ++i) {
        if (p-&gt;VMA[i].valid) {
            np-&gt;VMA[i] = p-&gt;VMA[i];
            filedup(p-&gt;VMA[i].filep);
        }
    }

  safestrcpy(np-&gt;name, p-&gt;name, sizeof(p-&gt;name));

  pid = np-&gt;pid;

  release(&amp;np-&gt;lock);

  acquire(&amp;wait_lock);
  np-&gt;parent = p;
  release(&amp;wait_lock);

  acquire(&amp;np-&gt;lock);
  np-&gt;state = RUNNABLE;
  release(&amp;np-&gt;lock);

  return pid;
}
</code></pre>
<p>要注意的点：address的类型时uint64，在写循环变量的时候不要写错了；对于MAP_SHARE类型的VMA，在写回时注意检查文件是否可写。</p>

                        <div id="comment-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="blog20220726.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="blog20220519.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="blog20220726.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="blog20220519.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        
        <!-- Custom JS scripts -->
        <script type="text/javascript" src="theme/comments.js"></script>
        <script type="text/javascript" src="theme/toc.js"></script>
    </body>
</html>
